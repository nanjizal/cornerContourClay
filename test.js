// Generated by Haxe 4.3.0-rc.1+5f599ba
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	if(x != null) {
		var _g = 0;
		var _g1 = x.length;
		while(_g < _g1) {
			var i = _g++;
			var c = x.charCodeAt(i);
			if(c <= 8 || c >= 14 && c != 32 && c != 45) {
				var nc = x.charCodeAt(i + 1);
				var v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
				if(isNaN(v)) {
					return null;
				} else {
					return v;
				}
			}
		}
	}
	return null;
};
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return s.lastIndexOf(start,0) == 0;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.hex = function(n,digits) {
	var s = "";
	var hexChars = "0123456789ABCDEF";
	while(true) {
		s = hexChars.charAt(n & 15) + s;
		n >>>= 4;
		if(!(n > 0)) {
			break;
		}
	}
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
var clay_ArrayPool = function(arrayLengths) {
	this.nextFree = 0;
	this.arrays = null;
	this.arrayLengths = arrayLengths;
};
clay_ArrayPool.__name__ = true;
clay_ArrayPool.pool = function(size) {
	if(size <= 10) {
		return clay_ArrayPool.dynPool10;
	} else if(size <= 100) {
		return clay_ArrayPool.dynPool100;
	} else if(size <= 1000) {
		return clay_ArrayPool.dynPool1000;
	} else if(size <= 10000) {
		return clay_ArrayPool.dynPool10000;
	} else if(size <= 100000) {
		return clay_ArrayPool.dynPool100000;
	} else {
		if(!clay_ArrayPool.didNotifyLargePool) {
			clay_ArrayPool.didNotifyLargePool = true;
			clay_Log.warning("You should avoid asking a pool for arrays with more than 100000 elements (asked: " + size + ") because it needs allocating a temporary one-time pool each time for that.",{ fileName : "clay/ArrayPool.hx", lineNumber : 47, className : "clay.ArrayPool", methodName : "pool"});
		}
		return new clay_ArrayPool(size);
	}
};
clay_ArrayPool.prototype = {
	get: function() {
		if(this.arrays == null) {
			this.arrays = new clay_ReusableArray(clay_ArrayPool.ALLOC_STEP);
		} else if(this.nextFree >= this.arrays.length) {
			var fh = this.arrays;
			fh.set_length(fh.length + clay_ArrayPool.ALLOC_STEP);
		}
		var result = this.arrays.vector[this.nextFree];
		if(result == null) {
			result = new clay_ReusableArray(this.arrayLengths);
			this.arrays.vector[this.nextFree] = result;
		}
		result._poolIndex = this.nextFree;
		while(true) {
			this.nextFree++;
			if(this.nextFree == this.arrays.length) {
				break;
			}
			var item = this.arrays.vector[this.nextFree];
			if(item == null) {
				break;
			}
			if(item._poolIndex == -1) {
				break;
			}
		}
		return result;
	}
	,release: function(array) {
		var poolIndex = array._poolIndex;
		array._poolIndex = -1;
		if(this.nextFree > poolIndex) {
			this.nextFree = poolIndex;
		}
		var _g = 0;
		var _g1 = array.length;
		while(_g < _g1) {
			var i = _g++;
			array.vector[i] = null;
		}
	}
};
var clay_BackgroundQueue = function(checkInterval) {
	if(checkInterval == null) {
		checkInterval = 0.05;
	}
	this.pending = [];
	this.stop = false;
	this.runsInBackground = false;
	this.checkInterval = checkInterval;
};
clay_BackgroundQueue.__name__ = true;
clay_BackgroundQueue.prototype = {
	schedule: function(fn) {
		fn();
	}
	,destroy: function() {
		this.stop = true;
	}
};
var clay_Clay = function(configure,events) {
	this.windowInBackground = false;
	this.ready = false;
	this.freeze = false;
	this.nextTick = 0;
	this.immediateShutdown = false;
	this.timestamp = -1;
	this.hasShutdown = false;
	this.shuttingDown = false;
	clay_Clay.app = this;
	clay_Runner.init();
	this.extractAppId();
	this.config = this.defaultConfig();
	configure(this.config);
	this.events = events;
	this.io = new clay_web_WebIO(this);
	clay_Immediate.flush();
	this.assets = new clay_web_WebAssets(this);
	clay_Immediate.flush();
	this.audio = new clay_web_WebAudio(this);
	clay_Immediate.flush();
	this.input = new clay_Input(this);
	clay_Immediate.flush();
	this.runtime = new clay_web_WebRuntime(this);
	clay_Immediate.flush();
	this.backgroundQueue = new clay_BackgroundQueue();
	this.init();
};
clay_Clay.__name__ = true;
clay_Clay.prototype = {
	set_freeze: function(freeze) {
		this.freeze = freeze;
		if(freeze) {
			this.events.freeze();
			this.audio.suspend();
		} else {
			this.events.unfreeze();
			this.audio.resume();
		}
		return freeze;
	}
	,init: function() {
		clay_Log.debug("Clay / init",{ fileName : "clay/Clay.hx", lineNumber : 160, className : "clay.Clay", methodName : "init"});
		this.io.init();
		clay_Immediate.flush();
		this.audio.init();
		clay_Immediate.flush();
		this.input.init();
		clay_Immediate.flush();
		this.runtime.init();
		clay_Immediate.flush();
		clay_Log.debug("Clay / ready",{ fileName : "clay/Clay.hx", lineNumber : 174, className : "clay.Clay", methodName : "init"});
		this.runtime.ready();
		clay_Immediate.flush();
		this.audio.ready();
		clay_Immediate.flush();
		this.timestamp = window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart;
		this.ready = true;
		this.nextTick = this.timestamp;
		this.updateScreen();
		this.events.ready();
		var shouldExit = this.runtime.run();
		if(shouldExit && !(this.hasShutdown || this.shuttingDown)) {
			this.shutdown();
		}
	}
	,shutdown: function() {
		if(this.shuttingDown) {
			clay_Log.debug("Clay / shutdown() called again, already shutting down - ignoring",{ fileName : "clay/Clay.hx", lineNumber : 199, className : "clay.Clay", methodName : "shutdown"});
			return;
		}
		if(this.hasShutdown) {
			throw haxe_Exception.thrown("Clay / calling shutdown() more than once is disallowed");
		}
		this.shuttingDown = true;
		this.io.shutdown();
		this.audio.shutdown();
		this.input.shutdown();
		this.runtime.shutdown(this.immediateShutdown);
		clay_Log.debug("Clay / shutdown",{ fileName : "clay/Clay.hx", lineNumber : 215, className : "clay.Clay", methodName : "shutdown"});
		this.hasShutdown = true;
	}
	,emitQuit: function() {
		this.shutdown();
	}
	,shouldUpdate: function(newTimestamp) {
		if(this.config.updateRate > 0) {
			if(newTimestamp < this.nextTick) {
				return false;
			}
			while(this.nextTick <= newTimestamp) this.nextTick += this.config.updateRate;
		} else {
			this.nextTick = newTimestamp;
		}
		return true;
	}
	,emitTick: function(newTimestamp) {
		if(this.freeze) {
			return;
		}
		clay_Runner.tick();
		clay_Immediate.flush();
		this.updateScreen();
		if(!this.shuttingDown && this.ready) {
			var delta = newTimestamp - this.timestamp;
			this.timestamp = newTimestamp;
			this.audio.tick(delta);
			this.events.tick(delta);
		}
	}
	,emitWindowEvent: function(type,timestamp,windowId,x,y) {
		this.events.windowEvent(type,timestamp,windowId,x,y);
	}
	,emitAppEvent: function(type) {
		this.events.appEvent(type);
	}
	,extractAppId: function() {
		var rawAppId = "CornerContourClay";
		if(StringTools.startsWith(rawAppId,"\"")) {
			this.appId = JSON.parse(rawAppId);
		} else {
			this.appId = rawAppId;
		}
	}
	,defaultConfig: function() {
		var _g = clay_web_WebRuntime.defaultConfig();
		return new clay_Config(this.defaultWindowConfig(),this.defaultRenderConfig(),_g,null);
	}
	,defaultWindowConfig: function() {
		var $window = new clay_WindowConfig(false,false,true,false,536805376,536805376,960,640,"clay app",false,0.0666666666666666657);
		return $window;
	}
	,defaultRenderConfig: function() {
		return new clay_RenderConfig(0,0,0,8,8,8,8,new clay_graphics_Color(0,0,0,1),new clay_RenderConfigWebGL(1,null,null,null,null,null,null,null,null));
	}
	,defaultRuntimeConfig: function() {
		return new clay_web_WebConfig(null,null,null,null,null,null,null);
	}
	,copyWindowConfig: function(config) {
		return new clay_WindowConfig(config.fullscreen,config.trueFullscreen,config.resizable,config.borderless,config.x,config.y,config.width,config.height,"" + config.title,config.noInput,config.backgroundSleep);
	}
	,copyRenderConfig: function(config) {
		return new clay_RenderConfig(config.depth,config.stencil,config.antialiasing,config.redBits,config.greenBits,config.blueBits,config.alphaBits,new clay_graphics_Color(config.defaultClear.r,config.defaultClear.g,config.defaultClear.b,config.defaultClear.a),new clay_RenderConfigWebGL(config.webgl.version,null,null,null,null,null,null,null,null));
	}
	,updateScreen: function() {
		this.screenDensity = clay_Clay.app.runtime.windowDevicePixelRatio();
		var _this = clay_Clay.app.runtime;
		this.screenWidth = Math.round(Math.round(_this.windowW * _this.windowDevicePixelRatio()) / this.screenDensity);
		var _this = clay_Clay.app.runtime;
		this.screenHeight = Math.round(Math.round(_this.windowH * _this.windowDevicePixelRatio()) / this.screenDensity);
	}
};
var clay_RenderConfig = function(depth,stencil,antialiasing,redBits,greenBits,blueBits,alphaBits,defaultClear,webgl) {
	this.webgl = null;
	this.defaultClear = new clay_graphics_Color(0,0,0,1);
	this.alphaBits = 8;
	this.blueBits = 8;
	this.greenBits = 8;
	this.redBits = 8;
	this.antialiasing = 0;
	this.stencil = 0;
	this.depth = 0;
	if(depth != null) {
		this.depth = depth;
	}
	if(stencil != null) {
		this.stencil = stencil;
	}
	if(antialiasing != null) {
		this.antialiasing = antialiasing;
	}
	if(redBits != null) {
		this.redBits = redBits;
	}
	if(greenBits != null) {
		this.greenBits = greenBits;
	}
	if(blueBits != null) {
		this.blueBits = blueBits;
	}
	if(alphaBits != null) {
		this.alphaBits = alphaBits;
	}
	if(defaultClear != null) {
		this.defaultClear = defaultClear;
	}
	if(webgl != null) {
		this.webgl = webgl;
	}
};
clay_RenderConfig.__name__ = true;
var clay_RenderConfigWebGL = function(version,alpha,depth,stencil,antialias,premultipliedAlpha,preserveDrawingBuffer,preferLowPowerToHighPerformance,failIfMajorPerformanceCaveat) {
	this.failIfMajorPerformanceCaveat = false;
	this.preferLowPowerToHighPerformance = false;
	this.preserveDrawingBuffer = false;
	this.premultipliedAlpha = false;
	this.antialias = true;
	this.stencil = false;
	this.depth = true;
	this.alpha = false;
	this.version = 1;
	if(version != null) {
		this.version = version;
	}
	if(alpha != null) {
		this.alpha = alpha;
	}
	if(depth != null) {
		this.depth = depth;
	}
	if(stencil != null) {
		this.stencil = stencil;
	}
	if(antialias != null) {
		this.antialias = antialias;
	}
	if(premultipliedAlpha != null) {
		this.premultipliedAlpha = premultipliedAlpha;
	}
	if(preserveDrawingBuffer != null) {
		this.preserveDrawingBuffer = preserveDrawingBuffer;
	}
	if(preferLowPowerToHighPerformance != null) {
		this.preferLowPowerToHighPerformance = preferLowPowerToHighPerformance;
	}
	if(failIfMajorPerformanceCaveat != null) {
		this.failIfMajorPerformanceCaveat = failIfMajorPerformanceCaveat;
	}
};
clay_RenderConfigWebGL.__name__ = true;
var clay_WindowConfig = function(fullscreen,trueFullscreen,resizable,borderless,x,y,width,height,title,noInput,backgroundSleep) {
	this.backgroundSleep = 0.0666666666666666657;
	this.noInput = false;
	this.title = null;
	this.height = 640;
	this.width = 960;
	this.y = 0;
	this.x = 0;
	this.borderless = false;
	this.resizable = true;
	this.trueFullscreen = false;
	this.fullscreen = false;
	if(fullscreen != null) {
		this.fullscreen = fullscreen;
	}
	if(trueFullscreen != null) {
		this.trueFullscreen = trueFullscreen;
	}
	if(resizable != null) {
		this.resizable = resizable;
	}
	if(borderless != null) {
		this.borderless = borderless;
	}
	if(x != null) {
		this.x = x;
	}
	if(y != null) {
		this.y = y;
	}
	if(width != null) {
		this.width = width;
	}
	if(height != null) {
		this.height = height;
	}
	if(title != null) {
		this.title = title;
	}
	if(noInput != null) {
		this.noInput = noInput;
	}
	if(backgroundSleep != null) {
		this.backgroundSleep = backgroundSleep;
	}
};
clay_WindowConfig.__name__ = true;
var clay_Config = function($window,render,runtime,updateRate) {
	this.updateRate = 0;
	this.runtime = null;
	this.render = null;
	this.window = null;
	if($window != null) {
		this.window = $window;
	}
	if(render != null) {
		this.render = render;
	}
	if(runtime != null) {
		this.runtime = runtime;
	}
	if(updateRate != null) {
		this.updateRate = updateRate;
	}
};
clay_Config.__name__ = true;
var clay_Events = function() { };
clay_Events.__name__ = true;
clay_Events.prototype = {
	ready: function() {
	}
	,tick: function(delta) {
	}
	,freeze: function() {
	}
	,unfreeze: function() {
	}
	,keyDown: function(keycode,scancode,repeat,mod,timestamp,windowId) {
	}
	,keyUp: function(keycode,scancode,repeat,mod,timestamp,windowId) {
	}
	,text: function(text,start,length,type,timestamp,windowId) {
	}
	,mouseMove: function(x,y,xrel,yrel,timestamp,windowId) {
	}
	,mouseDown: function(x,y,button,timestamp,windowId) {
	}
	,mouseUp: function(x,y,button,timestamp,windowId) {
	}
	,mouseWheel: function(x,y,timestamp,windowId) {
	}
	,touchDown: function(x,y,dx,dy,touchId,timestamp) {
	}
	,touchUp: function(x,y,dx,dy,touchId,timestamp) {
	}
	,touchMove: function(x,y,dx,dy,touchId,timestamp) {
	}
	,gamepadAxis: function(gamepad,axis,value,timestamp) {
	}
	,gamepadDown: function(gamepad,button,value,timestamp) {
	}
	,gamepadUp: function(gamepad,button,value,timestamp) {
	}
	,gamepadDevice: function(gamepad,name,type,timestamp) {
	}
	,windowEvent: function(type,timestamp,windowId,x,y) {
	}
	,appEvent: function(type) {
	}
	,audioEvent: function(event,handle) {
	}
};
var clay_Extensions = function() { };
clay_Extensions.__name__ = true;
clay_Extensions.unsafeGet = function(array,index) {
	return array[index];
};
clay_Extensions.unsafeSet = function(array,index,value) {
	array[index] = value;
};
var clay_Image = function(width,height,widthActual,heightActual,bitsPerPixel,sourceBitsPerPixel,pixels) {
	this.pixels = null;
	this.sourceBitsPerPixel = 4;
	this.bitsPerPixel = 4;
	this.heightActual = 0;
	this.widthActual = 0;
	this.height = 0;
	this.width = 0;
	if(width != null) {
		this.width = width;
	}
	if(height != null) {
		this.height = height;
	}
	if(widthActual != null) {
		this.widthActual = widthActual;
	}
	if(heightActual != null) {
		this.heightActual = heightActual;
	}
	if(bitsPerPixel != null) {
		this.bitsPerPixel = bitsPerPixel;
	}
	if(sourceBitsPerPixel != null) {
		this.sourceBitsPerPixel = sourceBitsPerPixel;
	}
	if(pixels != null) {
		this.pixels = pixels;
	}
};
clay_Image.__name__ = true;
clay_Image.prototype = {
	premultiplyAlpha: function() {
		if(this.bitsPerPixel == 4) {
			clay_PremultiplyAlpha.premultiplyAlpha(this.pixels);
		} else {
			clay_Log.warning("Can only premultiply alpha on images with 4 bits per pixels (RGBA)",{ fileName : "clay/Image.hx", lineNumber : 29, className : "clay.Image", methodName : "premultiplyAlpha"});
		}
	}
	,reversePremultiplyAlpha: function() {
		if(this.bitsPerPixel == 4) {
			clay_PremultiplyAlpha.reversePremultiplyAlpha(this.pixels);
		} else {
			clay_Log.warning("Can only reverse premultiply alpha on images with 4 bits per pixels (RGBA)",{ fileName : "clay/Image.hx", lineNumber : 40, className : "clay.Image", methodName : "reversePremultiplyAlpha"});
		}
	}
};
var clay_Immediate = function() { };
clay_Immediate.__name__ = true;
clay_Immediate.push = function(handleImmediate) {
	if(handleImmediate == null) {
		throw haxe_Exception.thrown("Immediate callback should not be null!");
	}
	if(clay_Immediate.immediateCallbacksLen < clay_Immediate.immediateCallbacksCapacity) {
		clay_Immediate.immediateCallbacks[clay_Immediate.immediateCallbacksLen] = handleImmediate;
		clay_Immediate.immediateCallbacksLen++;
	} else {
		clay_Immediate.immediateCallbacks[clay_Immediate.immediateCallbacksLen++] = handleImmediate;
		clay_Immediate.immediateCallbacksCapacity++;
	}
};
clay_Immediate.flush = function() {
	var didFlush = false;
	while(clay_Immediate.immediateCallbacksLen > 0) {
		didFlush = true;
		var pool = clay_ArrayPool.pool(clay_Immediate.immediateCallbacksLen);
		var callbacks = pool.get();
		var len = clay_Immediate.immediateCallbacksLen;
		clay_Immediate.immediateCallbacksLen = 0;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			callbacks.vector[i] = clay_Immediate.immediateCallbacks[i];
			clay_Immediate.immediateCallbacks[i] = null;
		}
		var _g2 = 0;
		var _g3 = len;
		while(_g2 < _g3) {
			var i1 = _g2++;
			var cb = callbacks.vector[i1];
			cb();
		}
		pool.release(callbacks);
	}
	return didFlush;
};
var clay_Input = function(app) {
	this.app = app;
	this.modState = new clay_ModState();
	this.modState.none = true;
};
clay_Input.__name__ = true;
clay_Input.prototype = {
	init: function() {
	}
	,shutdown: function() {
	}
	,emitKeyDown: function(keyCode,scanCode,repeat,mod,timestamp,windowId) {
		this.app.events.keyDown(keyCode,scanCode,repeat,mod,timestamp,windowId);
	}
	,emitKeyUp: function(keyCode,scanCode,repeat,mod,timestamp,windowId) {
		this.app.events.keyUp(keyCode,scanCode,repeat,mod,timestamp,windowId);
	}
	,emitText: function(text,start,length,type,timestamp,windowId) {
		this.app.events.text(text,start,length,type,timestamp,windowId);
	}
	,emitMouseMove: function(x,y,xrel,yrel,timestamp,windowId) {
		this.app.events.mouseMove(x,y,xrel,yrel,timestamp,windowId);
	}
	,emitMouseDown: function(x,y,button,timestamp,windowId) {
		this.app.events.mouseDown(x,y,button,timestamp,windowId);
	}
	,emitMouseUp: function(x,y,button,timestamp,windowId) {
		this.app.events.mouseUp(x,y,button,timestamp,windowId);
	}
	,emitMouseWheel: function(x,y,timestamp,windowId) {
		this.app.events.mouseWheel(x,y,timestamp,windowId);
	}
	,emitTouchDown: function(x,y,dx,dy,touchId,timestamp) {
		this.app.events.touchDown(x,y,dx,dy,touchId,timestamp);
	}
	,emitTouchUp: function(x,y,dx,dy,touchId,timestamp) {
		this.app.events.touchUp(x,y,dx,dy,touchId,timestamp);
	}
	,emitTouchMove: function(x,y,dx,dy,touchId,timestamp) {
		this.app.events.touchMove(x,y,dx,dy,touchId,timestamp);
	}
	,emitGamepadAxis: function(gamepad,axis,value,timestamp) {
		this.app.events.gamepadAxis(gamepad,axis,value,timestamp);
	}
	,emitGamepadDown: function(gamepad,button,value,timestamp) {
		this.app.events.gamepadDown(gamepad,button,value,timestamp);
	}
	,emitGamepadUp: function(gamepad,button,value,timestamp) {
		this.app.events.gamepadUp(gamepad,button,value,timestamp);
	}
	,emitGamepadDevice: function(gamepad,name,type,timestamp) {
		this.app.events.gamepadDevice(gamepad,name,type,timestamp);
	}
};
var clay_KeyCode = {};
clay_KeyCode.$name = function(keyCode) {
	if((keyCode & clay_ScanCode.MASK) != 0) {
		return clay_ScanCode.$name(keyCode & ~clay_ScanCode.MASK);
	}
	switch(keyCode) {
	case 8:
		return clay_ScanCode.$name(42);
	case 9:
		return clay_ScanCode.$name(43);
	case 13:
		return clay_ScanCode.$name(40);
	case 27:
		return clay_ScanCode.$name(41);
	case 32:
		return clay_ScanCode.$name(44);
	case 97:
		return clay_ScanCode.$name(4);
	case 98:
		return clay_ScanCode.$name(5);
	case 99:
		return clay_ScanCode.$name(6);
	case 100:
		return clay_ScanCode.$name(7);
	case 101:
		return clay_ScanCode.$name(8);
	case 102:
		return clay_ScanCode.$name(9);
	case 103:
		return clay_ScanCode.$name(10);
	case 104:
		return clay_ScanCode.$name(11);
	case 105:
		return clay_ScanCode.$name(12);
	case 106:
		return clay_ScanCode.$name(13);
	case 107:
		return clay_ScanCode.$name(14);
	case 108:
		return clay_ScanCode.$name(15);
	case 109:
		return clay_ScanCode.$name(16);
	case 110:
		return clay_ScanCode.$name(17);
	case 111:
		return clay_ScanCode.$name(18);
	case 112:
		return clay_ScanCode.$name(19);
	case 113:
		return clay_ScanCode.$name(20);
	case 114:
		return clay_ScanCode.$name(21);
	case 115:
		return clay_ScanCode.$name(22);
	case 116:
		return clay_ScanCode.$name(23);
	case 117:
		return clay_ScanCode.$name(24);
	case 118:
		return clay_ScanCode.$name(25);
	case 119:
		return clay_ScanCode.$name(26);
	case 120:
		return clay_ScanCode.$name(27);
	case 121:
		return clay_ScanCode.$name(28);
	case 122:
		return clay_ScanCode.$name(29);
	case 127:
		return clay_ScanCode.$name(76);
	default:
		return String.fromCodePoint(keyCode);
	}
};
clay_KeyCode.toScanCode = function(keycode) {
	if((keycode & clay_ScanCode.MASK) != 0) {
		return keycode & ~clay_ScanCode.MASK;
	}
	switch(keycode) {
	case 8:
		return 42;
	case 9:
		return 43;
	case 13:
		return 40;
	case 27:
		return 41;
	case 32:
		return 44;
	case 47:
		return 56;
	case 48:
		return 39;
	case 49:
		return 30;
	case 50:
		return 31;
	case 51:
		return 32;
	case 52:
		return 33;
	case 53:
		return 34;
	case 54:
		return 35;
	case 55:
		return 36;
	case 56:
		return 37;
	case 57:
		return 38;
	case 59:
		return 51;
	case 61:
		return 46;
	case 91:
		return 47;
	case 92:
		return 49;
	case 93:
		return 48;
	case 96:
		return 53;
	case 97:
		return 4;
	case 98:
		return 5;
	case 99:
		return 6;
	case 100:
		return 7;
	case 101:
		return 8;
	case 102:
		return 9;
	case 103:
		return 10;
	case 104:
		return 11;
	case 105:
		return 12;
	case 106:
		return 13;
	case 107:
		return 14;
	case 108:
		return 15;
	case 109:
		return 16;
	case 110:
		return 17;
	case 111:
		return 18;
	case 112:
		return 19;
	case 113:
		return 20;
	case 114:
		return 21;
	case 115:
		return 22;
	case 116:
		return 23;
	case 117:
		return 24;
	case 118:
		return 25;
	case 119:
		return 26;
	case 120:
		return 27;
	case 121:
		return 28;
	case 122:
		return 29;
	}
	return 0;
};
clay_KeyCode.toString = function(this1) {
	return "KeyCode(" + this1 + " " + clay_KeyCode.$name(this1) + ")";
};
var clay_Log = function() { };
clay_Log.__name__ = true;
clay_Log.debug = function(message,pos) {
};
clay_Log.info = function(message,pos) {
	haxe_Log.trace("[info] " + message,pos);
};
clay_Log.warning = function(message,pos) {
	haxe_Log.trace("[warning] " + message,pos);
};
clay_Log.error = function(message,pos) {
	haxe_Log.trace("[error] " + message,pos);
};
clay_Log.success = function(message,pos) {
	haxe_Log.trace("[success] " + message,pos);
};
var clay_Macros = function() { };
clay_Macros.__name__ = true;
var clay_PremultiplyAlpha = function() { };
clay_PremultiplyAlpha.__name__ = true;
clay_PremultiplyAlpha.premultiplyAlpha = function(pixels) {
	var count = pixels.length;
	var index = 0;
	while(index < count) {
		var r = pixels[index];
		var g = pixels[index + 1];
		var b = pixels[index + 2];
		var a = pixels[index + 3] / 255.0;
		pixels[index] = r * a | 0;
		pixels[index + 1] = g * a | 0;
		pixels[index + 2] = b * a | 0;
		index += 4;
	}
};
clay_PremultiplyAlpha.reversePremultiplyAlpha = function(pixels) {
	var count = pixels.length;
	var index = 0;
	while(index < count) {
		var r = pixels[index];
		var g = pixels[index + 1];
		var b = pixels[index + 2];
		var a = pixels[index + 3] / 255.0;
		if(a > 0) {
			pixels[index] = r / a | 0;
			pixels[index + 1] = g / a | 0;
			pixels[index + 2] = b / a | 0;
		}
		index += 4;
	}
};
var clay_Resource = function() {
	this.id = null;
};
clay_Resource.__name__ = true;
var clay_ReusableArray = function(length) {
	this._poolIndex = -1;
	this.set_length(length);
};
clay_ReusableArray.__name__ = true;
clay_ReusableArray.prototype = {
	set_length: function(length) {
		if(this.vector == null) {
			var this1 = new Array(length);
			this.vector = this1;
			this.length = length;
			return length;
		}
		if(length == this.length) {
			return length;
		}
		if(length > this.vector.length) {
			var this1 = new Array(length);
			var newVector = this1;
			var _g = 0;
			var _g1 = this.length;
			while(_g < _g1) {
				var i = _g++;
				newVector[i] = this.vector[i];
				this.vector[i] = null;
			}
			this.vector = newVector;
			var _g = this.length;
			var _g1 = length;
			while(_g < _g1) {
				var i = _g++;
				this.vector[i] = null;
			}
		} else {
			var _g = length;
			var _g1 = this.length;
			while(_g < _g1) {
				var i = _g++;
				this.vector[i] = null;
			}
		}
		this.length = length;
		return length;
	}
	,get: function(index) {
		return this.vector[index];
	}
	,set: function(index,value) {
		this.vector[index] = value;
	}
};
var clay_Runner = function() { };
clay_Runner.__name__ = true;
clay_Runner.currentIsMainThread = function() {
	return true;
};
clay_Runner.init = function() {
};
clay_Runner.tick = function() {
};
clay_Runner.isEmulatingBackgroundWithMain = function() {
	return true;
};
clay_Runner.runInMain = function(_fn) {
	clay_Immediate.push(_fn);
};
clay_Runner.runInBackground = function(fn) {
	clay_Immediate.push(fn);
};
var clay_ScanCode = {};
clay_ScanCode.$name = function(scanCode) {
	var res = null;
	if(scanCode >= 0 && scanCode < clay_ScanCode.scanCodeNames.length) {
		res = clay_ScanCode.scanCodeNames[scanCode];
	}
	if(res != null) {
		return res;
	} else {
		return "";
	}
};
clay_ScanCode.toString = function(this1) {
	return "ScanCode(" + this1 + " " + clay_ScanCode.$name(this1) + ")";
};
var clay_GamepadDeviceEventType = {};
clay_GamepadDeviceEventType.toString = function(this1) {
	switch(this1) {
	case 0:
		return "UNKNOWN";
	case 1:
		return "DEVICE_ADDED";
	case 2:
		return "DEVICE_REMOVED";
	case 3:
		return "DEVICE_REMAPPED";
	default:
		return "" + this1;
	}
};
var clay_ModState = function() {
	this.meta = false;
	this.alt = false;
	this.shift = false;
	this.ctrl = false;
	this.mode = false;
	this.caps = false;
	this.num = false;
	this.rmeta = false;
	this.lmeta = false;
	this.ralt = false;
	this.lalt = false;
	this.rctrl = false;
	this.lctrl = false;
	this.rshift = false;
	this.lshift = false;
	this.none = false;
};
clay_ModState.__name__ = true;
clay_ModState.prototype = {
	toString: function() {
		var s = "{ \"ModState\":true ";
		if(this.none) {
			return s + ", \"none\":true }";
		}
		if(this.lshift) {
			s += ", \"lshift\":true";
		}
		if(this.rshift) {
			s += ", \"rshift\":true";
		}
		if(this.lctrl) {
			s += ", \"lctrl\":true";
		}
		if(this.rctrl) {
			s += ", \"rctrl\":true";
		}
		if(this.lalt) {
			s += ", \"lalt\":true";
		}
		if(this.ralt) {
			s += ", \"ralt\":true";
		}
		if(this.lmeta) {
			s += ", \"lmeta\":true";
		}
		if(this.rmeta) {
			s += ", \"rmeta\":true";
		}
		if(this.num) {
			s += ", \"num\":true";
		}
		if(this.caps) {
			s += ", \"caps\":true";
		}
		if(this.mode) {
			s += ", \"mode\":true";
		}
		if(this.ctrl) {
			s += ", \"ctrl\":true";
		}
		if(this.shift) {
			s += ", \"shift\":true";
		}
		if(this.alt) {
			s += ", \"alt\":true";
		}
		if(this.meta) {
			s += ", \"meta\":true";
		}
		s += "}";
		return s;
	}
};
var clay_TextEventType = {};
clay_TextEventType.toString = function(this1) {
	switch(this1) {
	case 0:
		return "UNKNOWN";
	case 1:
		return "EDIT";
	case 2:
		return "INPUT";
	default:
		return "" + this1;
	}
};
var clay_WindowEventType = {};
clay_WindowEventType.toString = function(this1) {
	switch(this1) {
	case 0:
		return "UNKNOWN";
	case 1:
		return "SHOWN";
	case 2:
		return "HIDDEN";
	case 3:
		return "EXPOSED";
	case 4:
		return "MOVED";
	case 5:
		return "RESIZED";
	case 6:
		return "SIZE_CHANGED";
	case 7:
		return "MINIMIZED";
	case 8:
		return "MAXIMIZED";
	case 9:
		return "RESTORED";
	case 10:
		return "ENTER";
	case 11:
		return "LEAVE";
	case 12:
		return "FOCUS_GAINED";
	case 13:
		return "FOCUS_LOST";
	case 14:
		return "CLOSE";
	case 15:
		return "ENTER_FULLSCREEN";
	case 16:
		return "EXIT_FULLSCREEN";
	default:
		return "" + this1;
	}
};
var clay_AppEventType = {};
clay_AppEventType.toString = function(this1) {
	switch(this1) {
	case 0:
		return "UNKNOWN";
	case 11:
		return "TERMINATING";
	case 12:
		return "LOW_MEMORY";
	case 13:
		return "WILL_ENTER_BACKGROUND";
	case 14:
		return "DID_ENTER_BACKGROUND";
	case 15:
		return "WILL_ENTER_FOREGROUND";
	case 16:
		return "DID_ENTER_FOREGROUND";
	default:
		return "" + this1;
	}
};
var clay_Utils = function() { };
clay_Utils.__name__ = true;
clay_Utils.uniqueId = function() {
	switch(clay_Utils._nextUniqueIntCursor) {
	case 0:
		clay_Utils._nextUniqueInt0 = (clay_Utils._nextUniqueInt0 + 1) % 2147483647;
		break;
	case 1:
		clay_Utils._nextUniqueInt1 = (clay_Utils._nextUniqueInt1 + 1) % 2147483647;
		break;
	case 2:
		clay_Utils._nextUniqueInt2 = (clay_Utils._nextUniqueInt2 + 1) % 2147483647;
		break;
	case 3:
		clay_Utils._nextUniqueInt3 = (clay_Utils._nextUniqueInt3 + 1) % 2147483647;
		break;
	}
	clay_Utils._nextUniqueIntCursor = (clay_Utils._nextUniqueIntCursor + 1) % 4;
	var val = clay_Utils._nextUniqueInt0;
	if(val == null) {
		val = Math.random() * 2147483646 | 0;
	}
	var r = val % 62 | 0;
	var q = val / 62 | 0;
	var result;
	if(q > 0) {
		var val = q;
		if(val == null) {
			val = Math.random() * 2147483646 | 0;
		}
		var r1 = val % 62 | 0;
		var q = val / 62 | 0;
		var result1;
		if(q > 0) {
			var result2 = clay_Utils.base62Id(q);
			var result3;
			if(r1 > 9) {
				var ascii = 65 + (r1 - 10);
				if(ascii > 90) {
					ascii += 6;
				}
				result3 = String.fromCodePoint(ascii);
			} else {
				result3 = Std.string(r1).charAt(0);
			}
			result1 = result2 + result3;
		} else {
			var result2;
			if(r1 > 9) {
				var ascii = 65 + (r1 - 10);
				if(ascii > 90) {
					ascii += 6;
				}
				result2 = String.fromCodePoint(ascii);
			} else {
				result2 = Std.string(r1).charAt(0);
			}
			result1 = Std.string(result2);
		}
		var result2;
		if(r > 9) {
			var ascii = 65 + (r - 10);
			if(ascii > 90) {
				ascii += 6;
			}
			result2 = String.fromCodePoint(ascii);
		} else {
			result2 = Std.string(r).charAt(0);
		}
		result = result1 + result2;
	} else {
		var result1;
		if(r > 9) {
			var ascii = 65 + (r - 10);
			if(ascii > 90) {
				ascii += 6;
			}
			result1 = String.fromCodePoint(ascii);
		} else {
			result1 = Std.string(r).charAt(0);
		}
		result = Std.string(result1);
	}
	var val = null;
	if(val == null) {
		val = Math.random() * 2147483646 | 0;
	}
	var r = val % 62 | 0;
	var q = val / 62 | 0;
	var result1;
	if(q > 0) {
		var val = q;
		if(val == null) {
			val = Math.random() * 2147483646 | 0;
		}
		var r1 = val % 62 | 0;
		var q = val / 62 | 0;
		var result2;
		if(q > 0) {
			var result3 = clay_Utils.base62Id(q);
			var result4;
			if(r1 > 9) {
				var ascii = 65 + (r1 - 10);
				if(ascii > 90) {
					ascii += 6;
				}
				result4 = String.fromCodePoint(ascii);
			} else {
				result4 = Std.string(r1).charAt(0);
			}
			result2 = result3 + result4;
		} else {
			var result3;
			if(r1 > 9) {
				var ascii = 65 + (r1 - 10);
				if(ascii > 90) {
					ascii += 6;
				}
				result3 = String.fromCodePoint(ascii);
			} else {
				result3 = Std.string(r1).charAt(0);
			}
			result2 = Std.string(result3);
		}
		var result3;
		if(r > 9) {
			var ascii = 65 + (r - 10);
			if(ascii > 90) {
				ascii += 6;
			}
			result3 = String.fromCodePoint(ascii);
		} else {
			result3 = Std.string(r).charAt(0);
		}
		result1 = result2 + result3;
	} else {
		var result2;
		if(r > 9) {
			var ascii = 65 + (r - 10);
			if(ascii > 90) {
				ascii += 6;
			}
			result2 = String.fromCodePoint(ascii);
		} else {
			result2 = Std.string(r).charAt(0);
		}
		result1 = Std.string(result2);
	}
	var val = clay_Utils._nextUniqueInt1;
	if(val == null) {
		val = Math.random() * 2147483646 | 0;
	}
	var r = val % 62 | 0;
	var q = val / 62 | 0;
	var result2;
	if(q > 0) {
		var val = q;
		if(val == null) {
			val = Math.random() * 2147483646 | 0;
		}
		var r1 = val % 62 | 0;
		var q = val / 62 | 0;
		var result3;
		if(q > 0) {
			var result4 = clay_Utils.base62Id(q);
			var result5;
			if(r1 > 9) {
				var ascii = 65 + (r1 - 10);
				if(ascii > 90) {
					ascii += 6;
				}
				result5 = String.fromCodePoint(ascii);
			} else {
				result5 = Std.string(r1).charAt(0);
			}
			result3 = result4 + result5;
		} else {
			var result4;
			if(r1 > 9) {
				var ascii = 65 + (r1 - 10);
				if(ascii > 90) {
					ascii += 6;
				}
				result4 = String.fromCodePoint(ascii);
			} else {
				result4 = Std.string(r1).charAt(0);
			}
			result3 = Std.string(result4);
		}
		var result4;
		if(r > 9) {
			var ascii = 65 + (r - 10);
			if(ascii > 90) {
				ascii += 6;
			}
			result4 = String.fromCodePoint(ascii);
		} else {
			result4 = Std.string(r).charAt(0);
		}
		result2 = result3 + result4;
	} else {
		var result3;
		if(r > 9) {
			var ascii = 65 + (r - 10);
			if(ascii > 90) {
				ascii += 6;
			}
			result3 = String.fromCodePoint(ascii);
		} else {
			result3 = Std.string(r).charAt(0);
		}
		result2 = Std.string(result3);
	}
	var val = null;
	if(val == null) {
		val = Math.random() * 2147483646 | 0;
	}
	var r = val % 62 | 0;
	var q = val / 62 | 0;
	var result3;
	if(q > 0) {
		var val = q;
		if(val == null) {
			val = Math.random() * 2147483646 | 0;
		}
		var r1 = val % 62 | 0;
		var q = val / 62 | 0;
		var result4;
		if(q > 0) {
			var result5 = clay_Utils.base62Id(q);
			var result6;
			if(r1 > 9) {
				var ascii = 65 + (r1 - 10);
				if(ascii > 90) {
					ascii += 6;
				}
				result6 = String.fromCodePoint(ascii);
			} else {
				result6 = Std.string(r1).charAt(0);
			}
			result4 = result5 + result6;
		} else {
			var result5;
			if(r1 > 9) {
				var ascii = 65 + (r1 - 10);
				if(ascii > 90) {
					ascii += 6;
				}
				result5 = String.fromCodePoint(ascii);
			} else {
				result5 = Std.string(r1).charAt(0);
			}
			result4 = Std.string(result5);
		}
		var result5;
		if(r > 9) {
			var ascii = 65 + (r - 10);
			if(ascii > 90) {
				ascii += 6;
			}
			result5 = String.fromCodePoint(ascii);
		} else {
			result5 = Std.string(r).charAt(0);
		}
		result3 = result4 + result5;
	} else {
		var result4;
		if(r > 9) {
			var ascii = 65 + (r - 10);
			if(ascii > 90) {
				ascii += 6;
			}
			result4 = String.fromCodePoint(ascii);
		} else {
			result4 = Std.string(r).charAt(0);
		}
		result3 = Std.string(result4);
	}
	var val = clay_Utils._nextUniqueInt2;
	if(val == null) {
		val = Math.random() * 2147483646 | 0;
	}
	var r = val % 62 | 0;
	var q = val / 62 | 0;
	var result4;
	if(q > 0) {
		var val = q;
		if(val == null) {
			val = Math.random() * 2147483646 | 0;
		}
		var r1 = val % 62 | 0;
		var q = val / 62 | 0;
		var result5;
		if(q > 0) {
			var result6 = clay_Utils.base62Id(q);
			var result7;
			if(r1 > 9) {
				var ascii = 65 + (r1 - 10);
				if(ascii > 90) {
					ascii += 6;
				}
				result7 = String.fromCodePoint(ascii);
			} else {
				result7 = Std.string(r1).charAt(0);
			}
			result5 = result6 + result7;
		} else {
			var result6;
			if(r1 > 9) {
				var ascii = 65 + (r1 - 10);
				if(ascii > 90) {
					ascii += 6;
				}
				result6 = String.fromCodePoint(ascii);
			} else {
				result6 = Std.string(r1).charAt(0);
			}
			result5 = Std.string(result6);
		}
		var result6;
		if(r > 9) {
			var ascii = 65 + (r - 10);
			if(ascii > 90) {
				ascii += 6;
			}
			result6 = String.fromCodePoint(ascii);
		} else {
			result6 = Std.string(r).charAt(0);
		}
		result4 = result5 + result6;
	} else {
		var result5;
		if(r > 9) {
			var ascii = 65 + (r - 10);
			if(ascii > 90) {
				ascii += 6;
			}
			result5 = String.fromCodePoint(ascii);
		} else {
			result5 = Std.string(r).charAt(0);
		}
		result4 = Std.string(result5);
	}
	var val = null;
	if(val == null) {
		val = Math.random() * 2147483646 | 0;
	}
	var r = val % 62 | 0;
	var q = val / 62 | 0;
	var result5;
	if(q > 0) {
		var val = q;
		if(val == null) {
			val = Math.random() * 2147483646 | 0;
		}
		var r1 = val % 62 | 0;
		var q = val / 62 | 0;
		var result6;
		if(q > 0) {
			var result7 = clay_Utils.base62Id(q);
			var result8;
			if(r1 > 9) {
				var ascii = 65 + (r1 - 10);
				if(ascii > 90) {
					ascii += 6;
				}
				result8 = String.fromCodePoint(ascii);
			} else {
				result8 = Std.string(r1).charAt(0);
			}
			result6 = result7 + result8;
		} else {
			var result7;
			if(r1 > 9) {
				var ascii = 65 + (r1 - 10);
				if(ascii > 90) {
					ascii += 6;
				}
				result7 = String.fromCodePoint(ascii);
			} else {
				result7 = Std.string(r1).charAt(0);
			}
			result6 = Std.string(result7);
		}
		var result7;
		if(r > 9) {
			var ascii = 65 + (r - 10);
			if(ascii > 90) {
				ascii += 6;
			}
			result7 = String.fromCodePoint(ascii);
		} else {
			result7 = Std.string(r).charAt(0);
		}
		result5 = result6 + result7;
	} else {
		var result6;
		if(r > 9) {
			var ascii = 65 + (r - 10);
			if(ascii > 90) {
				ascii += 6;
			}
			result6 = String.fromCodePoint(ascii);
		} else {
			result6 = Std.string(r).charAt(0);
		}
		result5 = Std.string(result6);
	}
	var val = clay_Utils._nextUniqueInt3;
	if(val == null) {
		val = Math.random() * 2147483646 | 0;
	}
	var r = val % 62 | 0;
	var q = val / 62 | 0;
	var result6;
	if(q > 0) {
		var val = q;
		if(val == null) {
			val = Math.random() * 2147483646 | 0;
		}
		var r1 = val % 62 | 0;
		var q = val / 62 | 0;
		var result7;
		if(q > 0) {
			var result8 = clay_Utils.base62Id(q);
			var result9;
			if(r1 > 9) {
				var ascii = 65 + (r1 - 10);
				if(ascii > 90) {
					ascii += 6;
				}
				result9 = String.fromCodePoint(ascii);
			} else {
				result9 = Std.string(r1).charAt(0);
			}
			result7 = result8 + result9;
		} else {
			var result8;
			if(r1 > 9) {
				var ascii = 65 + (r1 - 10);
				if(ascii > 90) {
					ascii += 6;
				}
				result8 = String.fromCodePoint(ascii);
			} else {
				result8 = Std.string(r1).charAt(0);
			}
			result7 = Std.string(result8);
		}
		var result8;
		if(r > 9) {
			var ascii = 65 + (r - 10);
			if(ascii > 90) {
				ascii += 6;
			}
			result8 = String.fromCodePoint(ascii);
		} else {
			result8 = Std.string(r).charAt(0);
		}
		result6 = result7 + result8;
	} else {
		var result7;
		if(r > 9) {
			var ascii = 65 + (r - 10);
			if(ascii > 90) {
				ascii += 6;
			}
			result7 = String.fromCodePoint(ascii);
		} else {
			result7 = Std.string(r).charAt(0);
		}
		result6 = Std.string(result7);
	}
	var result7 = result + "-" + result1 + "-" + result2 + "-" + result3 + "-" + result4 + "-" + result5 + "-" + result6;
	return result7;
};
clay_Utils.base62Id = function(val) {
	if(val == null) {
		val = Math.random() * 2147483646 | 0;
	}
	var r = val % 62 | 0;
	var q = val / 62 | 0;
	if(q > 0) {
		var tmp = clay_Utils.base62Id(q);
		var tmp1;
		if(r > 9) {
			var ascii = 65 + (r - 10);
			if(ascii > 90) {
				ascii += 6;
			}
			tmp1 = String.fromCodePoint(ascii);
		} else {
			tmp1 = (r == null ? "null" : "" + r).charAt(0);
		}
		return tmp + tmp1;
	} else {
		var tmp;
		if(r > 9) {
			var ascii = 65 + (r - 10);
			if(ascii > 90) {
				ascii += 6;
			}
			tmp = String.fromCodePoint(ascii);
		} else {
			tmp = (r == null ? "null" : "" + r).charAt(0);
		}
		return Std.string(tmp);
	}
};
var clay_audio_AudioDataOptions = function(id,rate,length,channels,bitsPerSample,format,samples,isStream) {
	this.isStream = null;
	this.samples = null;
	this.format = null;
	this.bitsPerSample = null;
	this.channels = null;
	this.length = null;
	this.rate = null;
	this.id = null;
	if(id != null) {
		this.id = id;
	}
	if(rate != null) {
		this.rate = rate;
	}
	if(length != null) {
		this.length = length;
	}
	if(channels != null) {
		this.channels = channels;
	}
	if(bitsPerSample != null) {
		this.bitsPerSample = bitsPerSample;
	}
	if(format != null) {
		this.format = format;
	}
	if(samples != null) {
		this.samples = samples;
	}
	if(isStream != null) {
		this.isStream = isStream;
	}
};
clay_audio_AudioDataOptions.__name__ = true;
var clay_audio_AudioData = function(app,options) {
	this.destroyed = false;
	this.isStream = false;
	this.format = 0;
	this.bitsPerSample = 16;
	this.channels = 1;
	this.length = 0;
	this.rate = 44100;
	this.id = "AudioData";
	this.app = app;
	if(options.id != null) {
		this.id = options.id;
	}
	if(options.rate != null) {
		this.rate = options.rate;
	}
	if(options.length != null) {
		this.length = options.length;
	}
	if(options.format != null) {
		this.format = options.format;
	}
	if(options.channels != null) {
		this.channels = options.channels;
	}
	if(options.bitsPerSample != null) {
		this.bitsPerSample = options.bitsPerSample;
	}
	if(options.isStream != null) {
		this.isStream = options.isStream;
	}
	if(options.samples != null) {
		this.samples = options.samples;
	}
	options = null;
};
clay_audio_AudioData.__name__ = true;
clay_audio_AudioData.prototype = {
	destroy: function() {
		if(this.destroyed) {
			return;
		}
		clay_Log.debug("Audio / destroy AudioData `" + this.id + "`",{ fileName : "clay/audio/AudioData.hx", lineNumber : 95, className : "clay.audio.AudioData", methodName : "destroy"});
		this.destroyed = true;
		this.id = null;
		this.samples = null;
	}
	,seek: function(to) {
		return false;
	}
	,portion: function(into,start,len,intoResult) {
		return intoResult;
	}
	,toString: function() {
		var tmp = "{ \"AudioData\":true, \"id\":" + this.id + ", \"rate\":" + this.rate + ", \"length\":" + this.length + ", \"channels\":" + this.channels + ", \"format\":\"";
		var tmp1;
		if(this.format == null) {
			tmp1 = "null";
		} else {
			var this1 = this.format;
			if(this1 == null) {
				tmp1 = "" + this1;
			} else {
				switch(this1) {
				case 0:
					tmp1 = "UNKNOWN";
					break;
				case 1:
					tmp1 = "CUSTOM";
					break;
				case 2:
					tmp1 = "OGG";
					break;
				case 3:
					tmp1 = "WAV";
					break;
				case 4:
					tmp1 = "PCM";
					break;
				default:
					tmp1 = "" + this1;
				}
			}
		}
		return tmp + tmp1 + "\", \"isStream\":" + Std.string(this.isStream) + " }";
	}
};
var clay_audio_AudioEvent = {};
clay_audio_AudioEvent.toString = function(this1) {
	switch(this1) {
	case 0:
		return "END";
	case 1:
		return "DESTROYED";
	case 2:
		return "DESTROYED_SOURCE";
	default:
		return "" + this1;
	}
};
var clay_audio_AudioFormat = {};
clay_audio_AudioFormat.toString = function(this1) {
	if(this1 == null) {
		return "" + this1;
	} else {
		switch(this1) {
		case 0:
			return "UNKNOWN";
		case 1:
			return "CUSTOM";
		case 2:
			return "OGG";
		case 3:
			return "WAV";
		case 4:
			return "PCM";
		default:
			return "" + this1;
		}
	}
};
clay_audio_AudioFormat.fromPath = function(path) {
	var ext = haxe_io_Path.extension(path);
	switch(ext.toLowerCase()) {
	case "ogg":
		return 2;
	case "pcm":
		return 4;
	case "wav":
		return 3;
	default:
		return 0;
	}
};
var clay_audio_AudioInstance = function(source,handle) {
	this.destroyed = false;
	this.source = source;
	this.handle = handle;
};
clay_audio_AudioInstance.__name__ = true;
clay_audio_AudioInstance.prototype = {
	hasEnded: function() {
		if(this.destroyed) {
			throw haxe_Exception.thrown("Audio / Instance hasEnded queried after being destroyed");
		}
		return this.source.app.audio.stateOf(this.handle) == 2;
	}
	,destroy: function() {
		if(this.destroyed) {
			throw haxe_Exception.thrown("Audio / Instance being destroyed more than once");
		}
		this.source.app.audio.handleInstanceDestroyed(this.handle);
		this.source.instanceKilled(this);
		this.destroyed = true;
		this.source = null;
		this.handle = -1;
	}
	,dataGet: function(into,start,length,intoResult) {
		if(this.destroyed) {
			throw haxe_Exception.thrown("Audio / Instance dataGet queried after being destroyed");
		}
		return this.source.data.portion(into,start,length,intoResult);
	}
	,dataSeek: function(toSamples) {
		if(this.destroyed) {
			throw haxe_Exception.thrown("Audio / Instance dataSeek queried after being destroyed");
		}
		return this.source.data.seek(toSamples);
	}
};
var clay_audio_AudioSource = function(app,data) {
	this.destroyed = false;
	this.streamBufferCount = 2;
	this.streamBufferLength = 176400;
	this.app = app;
	this.data = data;
	this.sourceId = clay_Utils.uniqueId();
	clay_Log.debug("AudioSource / `" + this.sourceId + "` / " + this.data.id,{ fileName : "clay/audio/AudioSource.hx", lineNumber : 34, className : "clay.audio.AudioSource", methodName : "new"});
	this.instances = [];
};
clay_audio_AudioSource.__name__ = true;
clay_audio_AudioSource.prototype = {
	instance: function(handle) {
		var instance = new clay_audio_AudioInstance(this,handle);
		if(this.instances.indexOf(instance) == -1) {
			this.instances.push(instance);
		}
		return instance;
	}
	,bytesToSeconds: function(bytes) {
		var word = this.data.bitsPerSample == 16 ? 2 : 1;
		var sampleFrames = this.data.rate * this.data.channels * word;
		return bytes / sampleFrames;
	}
	,secondsToBytes: function(seconds) {
		var word = this.data.bitsPerSample == 16 ? 2 : 1;
		var sampleFrames = this.data.rate * this.data.channels * word;
		return seconds * sampleFrames | 0;
	}
	,getDuration: function() {
		return this.bytesToSeconds(this.data.length);
	}
	,destroy: function() {
		if(this.destroyed) {
			clay_Log.debug("AudioSource / destroying already destroyed source!",{ fileName : "clay/audio/AudioSource.hx", lineNumber : 82, className : "clay.audio.AudioSource", methodName : "destroy"});
			return;
		}
		this.destroyed = true;
		var c = this.instances.length;
		var i = 0;
		clay_Log.debug("AudioSource / destroy / " + this.sourceId + " / " + this.data.id + ", stream=" + Std.string(this.data.isStream) + ", instances=" + c,{ fileName : "clay/audio/AudioSource.hx", lineNumber : 91, className : "clay.audio.AudioSource", methodName : "destroy"});
		while(i < c) {
			var instance = this.instances.pop();
			instance.destroy();
			instance = null;
			++i;
		}
		this.app.audio.handleSourceDestroyed(this);
		this.data.destroy();
		this.data = null;
		this.instances = null;
		this.app = null;
	}
	,instanceKilled: function(instance) {
		HxOverrides.remove(this.instances,instance);
	}
};
var clay_audio_AudioState = {};
clay_audio_AudioState.toString = function(this1) {
	switch(this1) {
	case -1:
		return "INVALID";
	case 0:
		return "PAUSED";
	case 1:
		return "PLAYING";
	case 2:
		return "STOPPED";
	default:
		return "" + this1;
	}
};
var clay_base_BaseAssets = function(app) {
	this.app = app;
};
clay_base_BaseAssets.__name__ = true;
clay_base_BaseAssets.prototype = {
	isSynchronous: function() {
		return false;
	}
	,fullPath: function(path) {
		if(haxe_io_Path.isAbsolute(path)) {
			return path;
		} else {
			return haxe_io_Path.join([this.app.io.appPath(),path]);
		}
	}
	,loadImage: function(path,components,async,callback) {
		if(async == null) {
			async = false;
		}
		if(components == null) {
			components = 4;
		}
		if(callback != null) {
			clay_Immediate.push(function() {
				callback(null);
			});
		}
		return null;
	}
};
var clay_base_BaseAudio = function(app) {
	this.app = app;
};
clay_base_BaseAudio.__name__ = true;
clay_base_BaseAudio.prototype = {
	isSynchronous: function() {
		return false;
	}
	,init: function() {
	}
	,ready: function() {
	}
	,tick: function(delta) {
	}
	,shutdown: function() {
	}
	,loadData: function(path,isStream,format,async,callback) {
		if(async == null) {
			async = false;
		}
		if(callback != null) {
			clay_Immediate.push(function() {
				callback(null);
			});
		}
		return null;
	}
	,emitAudioEvent: function(event,handle) {
		this.app.events.audioEvent(event,handle);
	}
};
var clay_base_BaseIO = function(app) {
	this.app = app;
};
clay_base_BaseIO.__name__ = true;
clay_base_BaseIO.prototype = {
	init: function() {
	}
	,shutdown: function() {
	}
	,isSynchronous: function() {
		return false;
	}
	,appPath: function() {
		return null;
	}
	,appPathPrefs: function() {
		return null;
	}
	,loadData: function(path,binary,async,callback) {
		if(async == null) {
			async = false;
		}
		if(binary == null) {
			binary = false;
		}
		if(callback != null) {
			clay_Immediate.push(function() {
				callback(null);
			});
		}
		return null;
	}
};
var clay_base_BaseRuntime = function(app) {
	this.name = null;
	this.app = app;
};
clay_base_BaseRuntime.__name__ = true;
clay_base_BaseRuntime.prototype = {
	init: function() {
	}
	,shutdown: function(immediate) {
		if(immediate == null) {
			immediate = false;
		}
	}
	,ready: function() {
	}
	,run: function() {
		return true;
	}
	,windowDevicePixelRatio: function() {
		return 1.0;
	}
	,windowWidth: function() {
		return 0;
	}
	,windowHeight: function() {
		return 0;
	}
};
var clay_buffers_Float32ArrayImplJS = {};
clay_buffers_Float32ArrayImplJS._new = function(_elements) {
	var this1 = new Float32Array(_elements);
	return this1;
};
clay_buffers_Float32ArrayImplJS.fromArray = function(_array) {
	return new Float32Array(_array);
};
clay_buffers_Float32ArrayImplJS.fromView = function(_view) {
	return new Float32Array(_view);
};
clay_buffers_Float32ArrayImplJS.fromBuffer = function(_buffer,_byteOffset,_byteLength) {
	return new Float32Array(_buffer,_byteOffset,_byteLength / 4 | 0);
};
clay_buffers_Float32ArrayImplJS.fromBytes = function(bytes,byteOffset,len) {
	if(byteOffset == null) {
		byteOffset = 0;
	}
	if(byteOffset == null) {
		return new Float32Array(bytes.b.bufferValue);
	}
	if(len == null) {
		return new Float32Array(bytes.b.bufferValue,byteOffset);
	}
	return new Float32Array(bytes.b.bufferValue,byteOffset,len);
};
clay_buffers_Float32ArrayImplJS.toBytes = function(this1) {
	return new haxe_io_Bytes(new Uint8Array(this1.buffer));
};
clay_buffers_Float32ArrayImplJS.toString = function(this1) {
	return "Float32Array [byteLength:" + this1.byteLength + ", length:" + this1.length + "]";
};
var clay_buffers_Int32ArrayImplJS = {};
clay_buffers_Int32ArrayImplJS._new = function(_elements) {
	var this1 = new Int32Array(_elements);
	return this1;
};
clay_buffers_Int32ArrayImplJS.fromArray = function(_array) {
	return new Int32Array(_array);
};
clay_buffers_Int32ArrayImplJS.fromView = function(_view) {
	return new Int32Array(_view);
};
clay_buffers_Int32ArrayImplJS.fromBuffer = function(_buffer,_byteOffset,_byteLength) {
	return new Int32Array(_buffer,_byteOffset,_byteLength / 4 | 0);
};
clay_buffers_Int32ArrayImplJS.fromBytes = function(bytes,byteOffset,len) {
	if(byteOffset == null) {
		byteOffset = 0;
	}
	if(byteOffset == null) {
		return new Int32Array(bytes.b.bufferValue);
	}
	if(len == null) {
		return new Int32Array(bytes.b.bufferValue,byteOffset);
	}
	return new Int32Array(bytes.b.bufferValue,byteOffset,len);
};
clay_buffers_Int32ArrayImplJS.toBytes = function(this1) {
	return new haxe_io_Bytes(new Uint8Array(this1.buffer));
};
clay_buffers_Int32ArrayImplJS.toString = function(this1) {
	return "Int32Array [byteLength:" + this1.byteLength + ", length:" + this1.length + "]";
};
var clay_buffers_Uint8ArrayImplJS = {};
clay_buffers_Uint8ArrayImplJS._new = function(_elements) {
	var this1 = new Uint8Array(_elements);
	return this1;
};
clay_buffers_Uint8ArrayImplJS.fromArray = function(_array) {
	return new Uint8Array(_array);
};
clay_buffers_Uint8ArrayImplJS.fromView = function(_view) {
	return new Uint8Array(_view);
};
clay_buffers_Uint8ArrayImplJS.fromBuffer = function(_buffer,_byteOffset,_byteLength) {
	return new Uint8Array(_buffer,_byteOffset,_byteLength);
};
clay_buffers_Uint8ArrayImplJS.fromBytes = function(bytes,byteOffset,len) {
	if(byteOffset == null) {
		return new Uint8Array(bytes.b.bufferValue);
	}
	if(len == null) {
		return new Uint8Array(bytes.b.bufferValue,byteOffset);
	}
	return new Uint8Array(bytes.b.bufferValue,byteOffset,len);
};
clay_buffers_Uint8ArrayImplJS.toBytes = function(this1) {
	return new haxe_io_Bytes(new Uint8Array(this1.buffer));
};
clay_buffers_Uint8ArrayImplJS.toString = function(this1) {
	return "Uint8Array [byteLength:" + this1.byteLength + ", length:" + this1.length + "]";
};
var clay_graphics_Color = function(r,g,b,a) {
	this.a = 1;
	this.b = 0;
	this.g = 0;
	this.r = 0;
	if(r != null) {
		this.r = r;
	}
	if(g != null) {
		this.g = g;
	}
	if(b != null) {
		this.b = b;
	}
	if(a != null) {
		this.a = a;
	}
};
clay_graphics_Color.__name__ = true;
var clay_graphics_Shader = function() {
	this.gpuShader = null;
	this.uniforms = null;
	this.textures = null;
	this.attributes = null;
	this.fragSource = null;
	this.vertSource = null;
	clay_Resource.call(this);
};
clay_graphics_Shader.__name__ = true;
clay_graphics_Shader.__super__ = clay_Resource;
clay_graphics_Shader.prototype = $extend(clay_Resource.prototype,{
	init: function() {
		this.gpuShader = clay_opengl_GLGraphics.createShader(this.vertSource,this.fragSource,this.attributes,this.textures);
		if(this.gpuShader == null) {
			throw haxe_Exception.thrown("Failed to create shader (id=" + this.id + ")");
		}
		this.uniforms = new clay_graphics_Uniforms(this.gpuShader);
	}
	,activate: function() {
		var shader = this.gpuShader;
		if(clay_opengl_GLGraphics._boundProgram != shader.program) {
			clay_opengl_GLGraphics._boundProgram = shader.program;
			clay_opengl_web_GL.gl.useProgram(shader.program);
		}
		if(this.uniforms != null) {
			this.uniforms.apply();
		}
	}
	,destroy: function() {
		clay_opengl_GLGraphics.deleteShader(this.gpuShader);
	}
});
var clay_graphics_Texture = function() {
	this.wrapT = 33071;
	this.wrapS = 33071;
	this.filterMag = 9729;
	this.filterMin = 9729;
	this.pixels = null;
	this.heightActual = -1;
	this.widthActual = -1;
	this.height = -1;
	this.width = -1;
	this.dataType = 5121;
	this.type = 3553;
	this.format = 6408;
	this.compressed = false;
	this.textureId = null;
	clay_Resource.call(this);
	this.index = clay_graphics_Texture._nextIndex++;
};
clay_graphics_Texture.__name__ = true;
clay_graphics_Texture.fromImage = function(image,premultiplyAlpha) {
	if(premultiplyAlpha == null) {
		premultiplyAlpha = false;
	}
	var texture = new clay_graphics_Texture();
	texture.premultiplyAlpha = premultiplyAlpha;
	if(premultiplyAlpha) {
		image.premultiplyAlpha();
	}
	if(image.bitsPerPixel != 4) {
		throw haxe_Exception.thrown("Image must have 4 bits per pixels (RGBA format)");
	}
	texture.width = image.width;
	texture.height = image.height;
	texture.widthActual = image.widthActual;
	texture.heightActual = image.heightActual;
	texture.pixels = image.pixels;
	return texture;
};
clay_graphics_Texture.__super__ = clay_Resource;
clay_graphics_Texture.prototype = $extend(clay_Resource.prototype,{
	set_filterMin: function(filterMin) {
		if(this.textureId != null) {
			this.bind();
			clay_opengl_web_GL.gl.texParameteri(3553,10241,filterMin);
		}
		return this.filterMin = filterMin;
	}
	,set_filterMag: function(filterMag) {
		if(this.textureId != null) {
			this.bind();
			clay_opengl_web_GL.gl.texParameteri(3553,10240,filterMag);
		}
		return this.filterMag = filterMag;
	}
	,set_wrapS: function(wrapS) {
		if(this.textureId != null) {
			this.bind();
			clay_opengl_web_GL.gl.texParameteri(3553,10242,wrapS);
		}
		return this.wrapS = wrapS;
	}
	,set_wrapT: function(wrapT) {
		if(this.textureId != null) {
			this.bind();
			clay_opengl_web_GL.gl.texParameteri(3553,10243,wrapT);
		}
		return this.wrapT = wrapT;
	}
	,init: function() {
		this.textureId = clay_opengl_web_GL.gl.createTexture();
		if(this.width > 0 && this.widthActual <= 0) {
			this.widthActual = this.width;
		}
		if(this.height > 0 && this.heightActual <= 0) {
			this.heightActual = this.height;
		}
		this.bind();
		clay_opengl_web_GL.gl.texParameteri(3553,10241,this.filterMin);
		clay_opengl_web_GL.gl.texParameteri(3553,10240,this.filterMag);
		clay_opengl_web_GL.gl.texParameteri(3553,10243,this.wrapT);
		clay_opengl_web_GL.gl.texParameteri(3553,10242,this.wrapS);
		if(this.pixels != null) {
			if(this.width <= 0 || this.height <= 0) {
				throw haxe_Exception.thrown("Provided texture pixels with invalid size (width=" + this.width + " height=" + this.height + ")");
			}
			this.submit(this.pixels);
		}
	}
	,destroy: function() {
		if(this.textureId != null) {
			var textureId = this.textureId;
			clay_opengl_web_GL.gl.deleteTexture(textureId);
			var _g = 0;
			var _g1 = clay_opengl_GLGraphics._boundTexture2D.length;
			while(_g < _g1) {
				var i = _g++;
				if(clay_opengl_GLGraphics._boundTexture2D[i] == textureId) {
					clay_opengl_GLGraphics._boundTexture2D[i] = null;
				}
			}
			this.textureId = null;
		}
	}
	,bind: function(slot) {
		if(slot == null) {
			slot = 0;
		}
		if(slot != -1) {
			if(clay_opengl_GLGraphics._activeTextureSlot != slot) {
				clay_opengl_GLGraphics._activeTextureSlot = slot;
				while(clay_opengl_GLGraphics._boundTexture2D.length <= clay_opengl_GLGraphics._activeTextureSlot) clay_opengl_GLGraphics._boundTexture2D.push(null);
				clay_opengl_web_GL.gl.activeTexture(33984 + slot);
			}
		}
		if(this.type == 3553) {
			var textureId = this.textureId;
			if(clay_opengl_GLGraphics._boundTexture2D[clay_opengl_GLGraphics._activeTextureSlot] != textureId) {
				clay_opengl_GLGraphics._boundTexture2D[clay_opengl_GLGraphics._activeTextureSlot] = textureId;
				clay_opengl_web_GL.gl.bindTexture(3553,textureId);
			}
		}
	}
	,submit: function(pixels) {
		var size = clay_opengl_web_GL.gl.getParameter(3379);
		if(size <= 0) {
			size = 4096;
		}
		var max = size;
		if(pixels == null) {
			pixels = this.pixels;
		}
		if(pixels == null) {
			throw haxe_Exception.thrown("Cannot submit texture pixels: pixels is null");
		}
		if(this.widthActual > max) {
			throw haxe_Exception.thrown("Texture actual width bigger than maximum hardware size (width=" + this.widthActual + " max=" + max + ")");
		}
		if(this.heightActual > max) {
			throw haxe_Exception.thrown("Texture actual height bigger than maximum hardware size (height=" + this.heightActual + " max=" + max + ")");
		}
		this.bind();
		if(this.type == 3553) {
			if(this.compressed) {
				var premultipliedAlpha = this.premultiplyAlpha;
				clay_opengl_web_GL.gl.compressedTexImage2D(3553,0,this.format,this.widthActual,this.heightActual,0,pixels);
			} else {
				var format = this.format;
				var width = this.widthActual;
				var height = this.heightActual;
				var dataType = this.dataType;
				clay_opengl_web_GL.gl.pixelStorei(37441,this.premultiplyAlpha ? 1 : 0);
				clay_opengl_web_GL.gl.texImage2D(3553,0,format,width,height,0,format,dataType,pixels);
			}
		}
	}
	,fetch: function(into,x,y,w,h) {
		if(h == null) {
			h = -1;
		}
		if(w == null) {
			w = -1;
		}
		if(y == null) {
			y = 0;
		}
		if(x == null) {
			x = 0;
		}
		if(w <= 0) {
			w = this.width;
		}
		if(h <= 0) {
			h = this.height;
		}
		this.bind();
		if(this.type == 3553) {
			clay_opengl_GLGraphics.fetchTexture2dPixels(into,x,y,w,h);
		}
		return into;
	}
});
var clay_graphics_TextureAndSlot = function(texture,slot) {
	this.texture = texture;
	this.slot = slot;
};
clay_graphics_TextureAndSlot.__name__ = true;
var clay_graphics_Uniforms = function(gpuShader) {
	this.dirtyTextures = [];
	this.dirtyColors = [];
	this.dirtyMatrix4s = [];
	this.dirtyVector4s = [];
	this.dirtyVector3s = [];
	this.dirtyVector2s = [];
	this.dirtyFloatArrays = [];
	this.dirtyFloats = [];
	this.dirtyIntArrays = [];
	this.dirtyInts = [];
	this.textures = new haxe_ds_StringMap();
	this.colors = new haxe_ds_StringMap();
	this.matrix4s = new haxe_ds_StringMap();
	this.vector4s = new haxe_ds_StringMap();
	this.vector3s = new haxe_ds_StringMap();
	this.vector2s = new haxe_ds_StringMap();
	this.floatArrays = new haxe_ds_StringMap();
	this.floats = new haxe_ds_StringMap();
	this.intArrays = new haxe_ds_StringMap();
	this.ints = new haxe_ds_StringMap();
	this.gpuShader = gpuShader;
};
clay_graphics_Uniforms.__name__ = true;
clay_graphics_Uniforms.prototype = {
	setInt: function(name,value) {
		var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
		this.ints.h[name] = value;
		this.dirtyInts.push(name);
	}
	,setIntArray: function(name,value) {
		var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
		this.intArrays.h[name] = value;
		this.dirtyIntArrays.push(name);
	}
	,setFloat: function(name,value) {
		var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
		this.floats.h[name] = value;
		this.dirtyFloats.push(name);
	}
	,setFloatArray: function(name,value) {
		var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
		this.floatArrays.h[name] = value;
		this.dirtyFloatArrays.push(name);
	}
	,setVector2: function(name,x,y) {
		var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
		var existing = this.vector2s.h[name];
		if(existing != null) {
			existing.x = x;
			existing.y = y;
		} else {
			var this1 = this.vector2s;
			var value = new clay_graphics_Vector2(x,y);
			this1.h[name] = value;
		}
		this.dirtyVector2s.push(name);
	}
	,setVector3: function(name,x,y,z) {
		var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
		var existing = this.vector3s.h[name];
		if(existing != null) {
			existing.x = x;
			existing.y = y;
			existing.z = z;
		} else {
			var this1 = this.vector3s;
			var value = new clay_graphics_Vector3(x,y,z);
			this1.h[name] = value;
		}
		this.dirtyVector3s.push(name);
	}
	,setVector4: function(name,x,y,z,w) {
		var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
		var existing = this.vector4s.h[name];
		if(existing != null) {
			existing.x = x;
			existing.y = y;
			existing.z = z;
			existing.w = w;
		} else {
			var this1 = this.vector4s;
			var value = new clay_graphics_Vector4(x,y,z,w);
			this1.h[name] = value;
		}
		this.dirtyVector4s.push(name);
	}
	,setMatrix4: function(name,value) {
		var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
		var existing = this.matrix4s.h[name];
		if(existing == null) {
			var this1 = new Float32Array(16);
			existing = this1;
			this.matrix4s.h[name] = existing;
		}
		existing[0] = value[0];
		existing[1] = value[1];
		existing[2] = value[2];
		existing[3] = value[3];
		existing[4] = value[4];
		existing[5] = value[5];
		existing[6] = value[6];
		existing[7] = value[7];
		existing[8] = value[8];
		existing[9] = value[9];
		existing[10] = value[10];
		existing[11] = value[11];
		existing[12] = value[12];
		existing[13] = value[13];
		existing[14] = value[14];
		existing[15] = value[15];
		this.dirtyMatrix4s.push(name);
	}
	,setColor: function(name,r,g,b,a) {
		var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
		var existing = this.colors.h[name];
		if(existing != null) {
			existing.r = r;
			existing.g = g;
			existing.b = b;
			existing.a = a;
		} else {
			var this1 = this.colors;
			var value = new clay_graphics_Color(r,g,b,a);
			this1.h[name] = value;
		}
		this.dirtyColors.push(name);
	}
	,setTexture: function(name,slot,texture) {
		var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
		var existing = this.textures.h[name];
		if(existing != null) {
			existing.texture = texture;
			existing.slot = slot;
		} else {
			var this1 = this.textures;
			var value = new clay_graphics_TextureAndSlot(texture,slot);
			this1.h[name] = value;
		}
		if(this.dirtyTextures.indexOf(name) == -1) {
			this.dirtyTextures.push(name);
		}
	}
	,apply: function() {
		var shader = this.gpuShader;
		if(clay_opengl_GLGraphics._boundProgram != shader.program) {
			clay_opengl_GLGraphics._boundProgram = shader.program;
			clay_opengl_web_GL.gl.useProgram(shader.program);
		}
		while(this.dirtyInts.length > 0) {
			var name = this.dirtyInts.pop();
			var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
			var shader = this.gpuShader;
			var value = this.ints.h[name];
			if(clay_opengl_GLGraphics._boundProgram != shader.program) {
				clay_opengl_GLGraphics._boundProgram = shader.program;
				clay_opengl_web_GL.gl.useProgram(shader.program);
			}
			clay_opengl_web_GL.gl.uniform1i(location,value);
		}
		while(this.dirtyIntArrays.length > 0) {
			var name = this.dirtyIntArrays.pop();
			var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
			var shader = this.gpuShader;
			var value = this.intArrays.h[name];
			if(clay_opengl_GLGraphics._boundProgram != shader.program) {
				clay_opengl_GLGraphics._boundProgram = shader.program;
				clay_opengl_web_GL.gl.useProgram(shader.program);
			}
			clay_opengl_web_GL.gl.uniform1iv(location,value);
		}
		while(this.dirtyFloats.length > 0) {
			var name = this.dirtyFloats.pop();
			var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
			var shader = this.gpuShader;
			var value = this.floats.h[name];
			if(clay_opengl_GLGraphics._boundProgram != shader.program) {
				clay_opengl_GLGraphics._boundProgram = shader.program;
				clay_opengl_web_GL.gl.useProgram(shader.program);
			}
			clay_opengl_web_GL.gl.uniform1f(location,value);
		}
		while(this.dirtyFloatArrays.length > 0) {
			var name = this.dirtyFloatArrays.pop();
			var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
			var shader = this.gpuShader;
			var value = this.floatArrays.h[name];
			if(clay_opengl_GLGraphics._boundProgram != shader.program) {
				clay_opengl_GLGraphics._boundProgram = shader.program;
				clay_opengl_web_GL.gl.useProgram(shader.program);
			}
			clay_opengl_web_GL.gl.uniform1fv(location,value);
		}
		while(this.dirtyVector2s.length > 0) {
			var name = this.dirtyVector2s.pop();
			var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
			var value = this.vector2s.h[name];
			var shader = this.gpuShader;
			var x = value.x;
			var y = value.y;
			if(clay_opengl_GLGraphics._boundProgram != shader.program) {
				clay_opengl_GLGraphics._boundProgram = shader.program;
				clay_opengl_web_GL.gl.useProgram(shader.program);
			}
			clay_opengl_web_GL.gl.uniform2f(location,x,y);
		}
		while(this.dirtyVector3s.length > 0) {
			var name = this.dirtyVector3s.pop();
			var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
			var value = this.vector3s.h[name];
			var shader = this.gpuShader;
			var x = value.x;
			var y = value.y;
			var z = value.z;
			if(clay_opengl_GLGraphics._boundProgram != shader.program) {
				clay_opengl_GLGraphics._boundProgram = shader.program;
				clay_opengl_web_GL.gl.useProgram(shader.program);
			}
			clay_opengl_web_GL.gl.uniform3f(location,x,y,z);
		}
		while(this.dirtyVector4s.length > 0) {
			var name = this.dirtyVector4s.pop();
			var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
			var value = this.vector4s.h[name];
			var shader = this.gpuShader;
			var x = value.x;
			var y = value.y;
			var z = value.z;
			var w = value.w;
			if(clay_opengl_GLGraphics._boundProgram != shader.program) {
				clay_opengl_GLGraphics._boundProgram = shader.program;
				clay_opengl_web_GL.gl.useProgram(shader.program);
			}
			clay_opengl_web_GL.gl.uniform4f(location,x,y,z,w);
		}
		while(this.dirtyMatrix4s.length > 0) {
			var name = this.dirtyMatrix4s.pop();
			var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
			var shader = this.gpuShader;
			var value = this.matrix4s.h[name];
			if(clay_opengl_GLGraphics._boundProgram != shader.program) {
				clay_opengl_GLGraphics._boundProgram = shader.program;
				clay_opengl_web_GL.gl.useProgram(shader.program);
			}
			clay_opengl_web_GL.gl.uniformMatrix4fv(location,false,value);
		}
		while(this.dirtyColors.length > 0) {
			var name = this.dirtyColors.pop();
			var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
			var value = this.colors.h[name];
			var shader = this.gpuShader;
			var r = value.r;
			var g = value.g;
			var b = value.b;
			var a = value.a;
			if(clay_opengl_GLGraphics._boundProgram != shader.program) {
				clay_opengl_GLGraphics._boundProgram = shader.program;
				clay_opengl_web_GL.gl.useProgram(shader.program);
			}
			clay_opengl_web_GL.gl.uniform4f(location,r,g,b,a);
		}
		var _g = 0;
		var _g1 = this.dirtyTextures.length;
		while(_g < _g1) {
			var i = _g++;
			var name = this.dirtyTextures[i];
			var location = clay_opengl_web_GL.gl.getUniformLocation(this.gpuShader.program,name);
			var value = this.textures.h[name];
			if(value.texture.type == 3553) {
				clay_opengl_GLGraphics.setTexture2dUniform(this.gpuShader,location,value.slot,value.texture.textureId);
			}
		}
	}
	,clone: function() {
		var uniforms = new clay_graphics_Uniforms(this.gpuShader);
		return uniforms;
	}
};
var clay_graphics_Vector2 = function(x,y) {
	this.y = 0;
	this.x = 0;
	if(x != null) {
		this.x = x;
	}
	if(y != null) {
		this.y = y;
	}
};
clay_graphics_Vector2.__name__ = true;
var clay_graphics_Vector3 = function(x,y,z) {
	this.z = 0;
	this.y = 0;
	this.x = 0;
	if(x != null) {
		this.x = x;
	}
	if(y != null) {
		this.y = y;
	}
	if(z != null) {
		this.z = z;
	}
};
clay_graphics_Vector3.__name__ = true;
var clay_graphics_Vector4 = function(x,y,z,w) {
	this.w = 0;
	this.z = 0;
	this.y = 0;
	this.x = 0;
	if(x != null) {
		this.x = x;
	}
	if(y != null) {
		this.y = y;
	}
	if(z != null) {
		this.z = z;
	}
	if(w != null) {
		this.w = w;
	}
};
clay_graphics_Vector4.__name__ = true;
var clay_opengl_GLGraphics = function() { };
clay_opengl_GLGraphics.__name__ = true;
clay_opengl_GLGraphics.setup = function() {
	clay_opengl_GLGraphics._defaultFramebuffer = clay_opengl_web_GL.gl.getParameter(36006);
	clay_opengl_GLGraphics._defaultRenderbuffer = clay_opengl_web_GL.gl.getParameter(36007);
	clay_opengl_GLGraphics._didFetchDefaultBuffers = true;
};
clay_opengl_GLGraphics.clear = function(r,g,b,a,clearDepth) {
	if(clearDepth == null) {
		clearDepth = true;
	}
	clay_opengl_web_GL.gl.clearColor(r,g,b,a);
	if(clearDepth && clay_Clay.app.config.render.depth > 0) {
		clay_opengl_web_GL.gl.clear(16640);
		clay_opengl_web_GL.gl.clearDepth(1.0);
	} else {
		clay_opengl_web_GL.gl.clear(16384);
	}
};
clay_opengl_GLGraphics.createTextureId = function() {
	return clay_opengl_web_GL.gl.createTexture();
};
clay_opengl_GLGraphics.setActiveTexture = function(slot) {
	if(clay_opengl_GLGraphics._activeTextureSlot != slot) {
		clay_opengl_GLGraphics._activeTextureSlot = slot;
		while(clay_opengl_GLGraphics._boundTexture2D.length <= clay_opengl_GLGraphics._activeTextureSlot) clay_opengl_GLGraphics._boundTexture2D.push(null);
		clay_opengl_web_GL.gl.activeTexture(33984 + slot);
	}
};
clay_opengl_GLGraphics.deleteTexture = function(textureId) {
	clay_opengl_web_GL.gl.deleteTexture(textureId);
	var _g = 0;
	var _g1 = clay_opengl_GLGraphics._boundTexture2D.length;
	while(_g < _g1) {
		var i = _g++;
		if(clay_opengl_GLGraphics._boundTexture2D[i] == textureId) {
			clay_opengl_GLGraphics._boundTexture2D[i] = null;
		}
	}
};
clay_opengl_GLGraphics.setViewport = function(x,y,width,height) {
	clay_opengl_web_GL.gl.viewport(x,y,width,height);
};
clay_opengl_GLGraphics.bindTexture2d = function(textureId) {
	if(clay_opengl_GLGraphics._boundTexture2D[clay_opengl_GLGraphics._activeTextureSlot] != textureId) {
		clay_opengl_GLGraphics._boundTexture2D[clay_opengl_GLGraphics._activeTextureSlot] = textureId;
		clay_opengl_web_GL.gl.bindTexture(3553,textureId);
	}
};
clay_opengl_GLGraphics.maxTextureSize = function() {
	var size = clay_opengl_web_GL.gl.getParameter(3379);
	if(size <= 0) {
		size = 4096;
	}
	return size;
};
clay_opengl_GLGraphics.needsPreprocessedPremultipliedAlpha = function() {
	return true;
};
clay_opengl_GLGraphics.submitCompressedTexture2dPixels = function(level,format,width,height,pixels,premultipliedAlpha) {
	clay_opengl_web_GL.gl.compressedTexImage2D(3553,level,format,width,height,0,pixels);
};
clay_opengl_GLGraphics.submitTexture2dPixels = function(level,format,width,height,dataType,pixels,premultipliedAlpha) {
	clay_opengl_web_GL.gl.pixelStorei(37441,premultipliedAlpha ? 1 : 0);
	clay_opengl_web_GL.gl.texImage2D(3553,level,format,width,height,0,format,dataType,pixels);
};
clay_opengl_GLGraphics.fetchTexture2dPixels = function(into,x,y,w,h) {
	if(into == null) {
		throw haxe_Exception.thrown("Texture fetch requires a valid buffer to store the pixels.");
	}
	var textureId = clay_opengl_GLGraphics._boundTexture2D[clay_opengl_GLGraphics._activeTextureSlot];
	var required = w * h * 4;
	if(into.length < required) {
		throw haxe_Exception.thrown("Texture fetch requires at least " + required + " (w * h * 4) bytes for the pixels, you have " + into.length + "!");
	}
	var fb = clay_opengl_web_GL.gl.createFramebuffer();
	clay_opengl_web_GL.gl.bindFramebuffer(36160,fb);
	clay_opengl_web_GL.gl.framebufferTexture2D(36160,36064,3553,textureId,0);
	if(clay_opengl_web_GL.gl.checkFramebufferStatus(36160) != 36053) {
		throw haxe_Exception.thrown("Incomplete framebuffer");
	}
	clay_opengl_web_GL.gl.readPixels(x,y,w,h,6408,5121,into);
	clay_opengl_web_GL.gl.bindFramebuffer(36160,null);
	clay_opengl_web_GL.gl.deleteFramebuffer(fb);
	fb = null;
};
clay_opengl_GLGraphics.createFramebuffer = function() {
	return clay_opengl_web_GL.gl.createFramebuffer();
};
clay_opengl_GLGraphics.bindFramebuffer = function(framebuffer) {
	if(clay_opengl_GLGraphics._boundFramebuffer != framebuffer) {
		clay_opengl_GLGraphics._boundFramebuffer = framebuffer;
		if(framebuffer == null) {
			framebuffer = clay_opengl_GLGraphics._defaultFramebuffer;
		}
		clay_opengl_web_GL.gl.bindFramebuffer(36160,framebuffer);
	}
};
clay_opengl_GLGraphics.createRenderbuffer = function() {
	return clay_opengl_web_GL.gl.createRenderbuffer();
};
clay_opengl_GLGraphics.bindRenderbuffer = function(renderbuffer) {
	if(clay_opengl_GLGraphics._boundRenderbuffer != renderbuffer) {
		clay_opengl_GLGraphics._boundRenderbuffer = renderbuffer;
		if(renderbuffer == null) {
			renderbuffer = clay_opengl_GLGraphics._defaultRenderbuffer;
		}
		clay_opengl_web_GL.gl.bindRenderbuffer(36161,renderbuffer);
	}
};
clay_opengl_GLGraphics.setTexture2dMinFilter = function(minFilter) {
	clay_opengl_web_GL.gl.texParameteri(3553,10241,minFilter);
};
clay_opengl_GLGraphics.setTexture2dMagFilter = function(magFilter) {
	clay_opengl_web_GL.gl.texParameteri(3553,10240,magFilter);
};
clay_opengl_GLGraphics.setTexture2dWrapS = function(wrapS) {
	clay_opengl_web_GL.gl.texParameteri(3553,10242,wrapS);
};
clay_opengl_GLGraphics.setTexture2dWrapT = function(wrapT) {
	clay_opengl_web_GL.gl.texParameteri(3553,10243,wrapT);
};
clay_opengl_GLGraphics.configureRenderTargetBuffersStorage = function(renderTarget,textureId,width,height,stencil,antialiasing) {
	var framebuffer = renderTarget.framebuffer;
	var renderbuffer = renderTarget.renderbuffer;
	clay_opengl_GLGraphics.bindFramebuffer(framebuffer);
	clay_opengl_GLGraphics.bindRenderbuffer(renderbuffer);
	if(stencil) {
		clay_opengl_web_GL.gl.renderbufferStorage(36161,34041,width,height);
	} else {
		clay_opengl_web_GL.gl.renderbufferStorage(36161,33189,width,height);
	}
	clay_opengl_web_GL.gl.framebufferTexture2D(36160,36064,3553,textureId,0);
	if(stencil) {
		clay_opengl_web_GL.gl.framebufferRenderbuffer(36160,33306,36161,renderbuffer);
	} else {
		clay_opengl_web_GL.gl.framebufferRenderbuffer(36160,36096,36161,renderbuffer);
	}
	var status = clay_opengl_web_GL.gl.checkFramebufferStatus(36160);
	switch(status) {
	case 36053:
		break;
	case 36054:
		throw haxe_Exception.thrown("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
	case 36055:
		throw haxe_Exception.thrown("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
	case 36057:
		throw haxe_Exception.thrown("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
	case 36059:
		throw haxe_Exception.thrown("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER");
	case 36060:
		throw haxe_Exception.thrown("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_READ_BUFFER");
	case 36061:
		throw haxe_Exception.thrown("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
	default:
		throw haxe_Exception.thrown("Incomplete framebuffer: " + status);
	}
	clay_opengl_GLGraphics.bindFramebuffer(null);
	clay_opengl_GLGraphics.bindRenderbuffer(null);
};
clay_opengl_GLGraphics.createRenderTarget = function(textureId,width,height,stencil,antialiasing,level,format,dataType) {
	var renderTarget = new clay_opengl_GLGraphics_$RenderTarget();
	clay_opengl_web_GL.gl.texImage2D(3553,level,format,width,height,0,format,dataType,null);
	renderTarget.framebuffer = clay_opengl_web_GL.gl.createFramebuffer();
	renderTarget.renderbuffer = clay_opengl_web_GL.gl.createRenderbuffer();
	var framebuffer = renderTarget.framebuffer;
	var renderbuffer = renderTarget.renderbuffer;
	clay_opengl_GLGraphics.bindFramebuffer(framebuffer);
	clay_opengl_GLGraphics.bindRenderbuffer(renderbuffer);
	if(stencil) {
		clay_opengl_web_GL.gl.renderbufferStorage(36161,34041,width,height);
	} else {
		clay_opengl_web_GL.gl.renderbufferStorage(36161,33189,width,height);
	}
	clay_opengl_web_GL.gl.framebufferTexture2D(36160,36064,3553,textureId,0);
	if(stencil) {
		clay_opengl_web_GL.gl.framebufferRenderbuffer(36160,33306,36161,renderbuffer);
	} else {
		clay_opengl_web_GL.gl.framebufferRenderbuffer(36160,36096,36161,renderbuffer);
	}
	var status = clay_opengl_web_GL.gl.checkFramebufferStatus(36160);
	switch(status) {
	case 36053:
		break;
	case 36054:
		throw haxe_Exception.thrown("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
	case 36055:
		throw haxe_Exception.thrown("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
	case 36057:
		throw haxe_Exception.thrown("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
	case 36059:
		throw haxe_Exception.thrown("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER");
	case 36060:
		throw haxe_Exception.thrown("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_READ_BUFFER");
	case 36061:
		throw haxe_Exception.thrown("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
	default:
		throw haxe_Exception.thrown("Incomplete framebuffer: " + status);
	}
	clay_opengl_GLGraphics.bindFramebuffer(null);
	clay_opengl_GLGraphics.bindRenderbuffer(null);
	return renderTarget;
};
clay_opengl_GLGraphics.deleteRenderTarget = function(renderTarget) {
	if(renderTarget.framebuffer != null) {
		if(clay_opengl_GLGraphics._boundFramebuffer == renderTarget.framebuffer) {
			clay_opengl_GLGraphics._boundFramebuffer = null;
		}
		clay_opengl_web_GL.gl.deleteFramebuffer(renderTarget.framebuffer);
		renderTarget.framebuffer = null;
	}
	if(renderTarget.renderbuffer != null) {
		if(clay_opengl_GLGraphics._boundRenderbuffer == renderTarget.renderbuffer) {
			clay_opengl_GLGraphics._boundRenderbuffer = null;
		}
		clay_opengl_web_GL.gl.deleteRenderbuffer(renderTarget.renderbuffer);
		renderTarget.renderbuffer = null;
	}
};
clay_opengl_GLGraphics.setRenderTarget = function(renderTarget) {
	if(renderTarget != null) {
		clay_opengl_GLGraphics.bindFramebuffer(renderTarget.framebuffer);
		clay_opengl_GLGraphics.bindRenderbuffer(renderTarget.renderbuffer);
	} else {
		clay_opengl_GLGraphics.bindFramebuffer(null);
		clay_opengl_GLGraphics.bindRenderbuffer(null);
	}
};
clay_opengl_GLGraphics.enableBlending = function() {
	clay_opengl_web_GL.gl.enable(3042);
};
clay_opengl_GLGraphics.disableBlending = function() {
	clay_opengl_web_GL.gl.disable(3042);
};
clay_opengl_GLGraphics.createShader = function(vertSource,fragSource,attributes,textures) {
	if(vertSource == null) {
		throw haxe_Exception.thrown("Cannot create shader: vertSource is null!");
	}
	if(fragSource == null) {
		throw haxe_Exception.thrown("Cannot create shader: fragSource is null!");
	}
	var shader = new clay_opengl_GLGraphics_$GpuShader();
	shader.vertShader = clay_opengl_GLGraphics.compileGLShader(35633,vertSource);
	if(shader.vertShader == null) {
		clay_opengl_GLGraphics.deleteShader(shader);
		return null;
	}
	shader.fragShader = clay_opengl_GLGraphics.compileGLShader(35632,fragSource);
	if(shader.fragShader == null) {
		clay_opengl_GLGraphics.deleteShader(shader);
		return null;
	}
	if(!clay_opengl_GLGraphics.linkShader(shader,attributes)) {
		clay_opengl_GLGraphics.deleteShader(shader);
		return null;
	}
	if(textures != null) {
		clay_opengl_GLGraphics.configureShaderTextureSlots(shader,textures);
	}
	return shader;
};
clay_opengl_GLGraphics.linkShader = function(shader,attributes) {
	var program = clay_opengl_web_GL.gl.createProgram();
	clay_opengl_web_GL.gl.attachShader(program,shader.vertShader);
	clay_opengl_web_GL.gl.attachShader(program,shader.fragShader);
	if(attributes != null) {
		var _g = 0;
		var _g1 = attributes.length;
		while(_g < _g1) {
			var i = _g++;
			clay_opengl_web_GL.gl.bindAttribLocation(program,i,attributes[i]);
		}
	}
	clay_opengl_web_GL.gl.linkProgram(program);
	if(clay_opengl_web_GL.gl.getProgramParameter(program,35714) == 0) {
		clay_Log.error("\tFailed to link shader program:",{ fileName : "clay/opengl/GLGraphics.hx", lineNumber : 571, className : "clay.opengl.GLGraphics", methodName : "linkShader"});
		var items = clay_opengl_web_GL.gl.getProgramInfoLog(program).split("\n");
		var _g = [];
		var _g1 = 0;
		var _g2 = items;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(StringTools.trim(v) != "") {
				_g.push(v);
			}
		}
		items = _g;
		var result = new Array(items.length);
		var _g = 0;
		var _g1 = items.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = "\t\t" + StringTools.trim(items[i]);
		}
		items = result;
		clay_Log.error(items.join("\n"),{ fileName : "clay/opengl/GLGraphics.hx", lineNumber : 572, className : "clay.opengl.GLGraphics", methodName : "linkShader"});
		clay_opengl_web_GL.gl.deleteProgram(program);
		return false;
	}
	shader.program = program;
	return true;
};
clay_opengl_GLGraphics.configureShaderTextureSlots = function(shader,textures) {
	if(clay_opengl_GLGraphics._boundProgram != shader.program) {
		clay_opengl_GLGraphics._boundProgram = shader.program;
		clay_opengl_web_GL.gl.useProgram(shader.program);
	}
	var _g = 0;
	var _g1 = textures.length;
	while(_g < _g1) {
		var i = _g++;
		var texture = textures[i];
		var attr = clay_opengl_web_GL.gl.getUniformLocation(shader.program,texture);
		if(attr != null) {
			clay_opengl_web_GL.gl.uniform1i(attr,i);
			shader.textures[i] = texture;
		}
	}
};
clay_opengl_GLGraphics.useShader = function(shader) {
	if(clay_opengl_GLGraphics._boundProgram != shader.program) {
		clay_opengl_GLGraphics._boundProgram = shader.program;
		clay_opengl_web_GL.gl.useProgram(shader.program);
	}
};
clay_opengl_GLGraphics.deleteShader = function(shader) {
	if(clay_opengl_GLGraphics._boundProgram == shader.program) {
		clay_opengl_GLGraphics._boundProgram = null;
	}
	if(shader.vertShader != null) {
		clay_opengl_web_GL.gl.deleteShader(shader.vertShader);
		shader.vertShader = null;
	}
	if(shader.fragShader != null) {
		clay_opengl_web_GL.gl.deleteShader(shader.fragShader);
		shader.fragShader = null;
	}
	if(shader.program != null) {
		clay_opengl_web_GL.gl.deleteProgram(shader.program);
		shader.program = null;
	}
};
clay_opengl_GLGraphics.compileGLShader = function(type,source) {
	var shader = clay_opengl_web_GL.gl.createShader(type);
	clay_opengl_web_GL.gl.shaderSource(shader,source);
	clay_opengl_web_GL.gl.compileShader(shader);
	var compileLog = clay_opengl_web_GL.gl.getShaderInfoLog(shader);
	var log = "";
	if(compileLog != null && compileLog.length > 0) {
		var isFrag = type == 35632;
		var typeName = isFrag ? "frag" : "vert";
		log += "\n\t// start -- (" + typeName + ") compile log --\n";
		var items = compileLog.split("\n");
		var _g = [];
		var _g1 = 0;
		var _g2 = items;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(StringTools.trim(v) != "") {
				_g.push(v);
			}
		}
		items = _g;
		var result = new Array(items.length);
		var _g = 0;
		var _g1 = items.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = "\t\t" + StringTools.trim(items[i]);
		}
		items = result;
		log += items.join("\n");
		log += "\n\t// end --\n";
	}
	if(clay_opengl_web_GL.gl.getShaderParameter(shader,35713) == 0) {
		clay_Log.error("GL / Failed to compile shader:",{ fileName : "clay/opengl/GLGraphics.hx", lineNumber : 659, className : "clay.opengl.GLGraphics", methodName : "compileGLShader"});
		var tmp;
		if(log.length == 0) {
			var items = clay_opengl_web_GL.gl.getShaderInfoLog(shader).split("\n");
			var _g = [];
			var _g1 = 0;
			var _g2 = items;
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				if(StringTools.trim(v) != "") {
					_g.push(v);
				}
			}
			items = _g;
			var result = new Array(items.length);
			var _g = 0;
			var _g1 = items.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = "\t\t" + StringTools.trim(items[i]);
			}
			items = result;
			tmp = items.join("\n");
		} else {
			tmp = log;
		}
		clay_Log.error(tmp,{ fileName : "clay/opengl/GLGraphics.hx", lineNumber : 660, className : "clay.opengl.GLGraphics", methodName : "compileGLShader"});
		clay_opengl_web_GL.gl.deleteShader(shader);
		shader = null;
	}
	return shader;
};
clay_opengl_GLGraphics.getUniformLocation = function(shader,name) {
	return clay_opengl_web_GL.gl.getUniformLocation(shader.program,name);
};
clay_opengl_GLGraphics.setIntUniform = function(shader,location,value) {
	if(clay_opengl_GLGraphics._boundProgram != shader.program) {
		clay_opengl_GLGraphics._boundProgram = shader.program;
		clay_opengl_web_GL.gl.useProgram(shader.program);
	}
	clay_opengl_web_GL.gl.uniform1i(location,value);
};
clay_opengl_GLGraphics.setIntArrayUniform = function(shader,location,value) {
	if(clay_opengl_GLGraphics._boundProgram != shader.program) {
		clay_opengl_GLGraphics._boundProgram = shader.program;
		clay_opengl_web_GL.gl.useProgram(shader.program);
	}
	clay_opengl_web_GL.gl.uniform1iv(location,value);
};
clay_opengl_GLGraphics.setFloatUniform = function(shader,location,value) {
	if(clay_opengl_GLGraphics._boundProgram != shader.program) {
		clay_opengl_GLGraphics._boundProgram = shader.program;
		clay_opengl_web_GL.gl.useProgram(shader.program);
	}
	clay_opengl_web_GL.gl.uniform1f(location,value);
};
clay_opengl_GLGraphics.setFloatArrayUniform = function(shader,location,value) {
	if(clay_opengl_GLGraphics._boundProgram != shader.program) {
		clay_opengl_GLGraphics._boundProgram = shader.program;
		clay_opengl_web_GL.gl.useProgram(shader.program);
	}
	clay_opengl_web_GL.gl.uniform1fv(location,value);
};
clay_opengl_GLGraphics.setVector2Uniform = function(shader,location,x,y) {
	if(clay_opengl_GLGraphics._boundProgram != shader.program) {
		clay_opengl_GLGraphics._boundProgram = shader.program;
		clay_opengl_web_GL.gl.useProgram(shader.program);
	}
	clay_opengl_web_GL.gl.uniform2f(location,x,y);
};
clay_opengl_GLGraphics.setVector3Uniform = function(shader,location,x,y,z) {
	if(clay_opengl_GLGraphics._boundProgram != shader.program) {
		clay_opengl_GLGraphics._boundProgram = shader.program;
		clay_opengl_web_GL.gl.useProgram(shader.program);
	}
	clay_opengl_web_GL.gl.uniform3f(location,x,y,z);
};
clay_opengl_GLGraphics.setVector4Uniform = function(shader,location,x,y,z,w) {
	if(clay_opengl_GLGraphics._boundProgram != shader.program) {
		clay_opengl_GLGraphics._boundProgram = shader.program;
		clay_opengl_web_GL.gl.useProgram(shader.program);
	}
	clay_opengl_web_GL.gl.uniform4f(location,x,y,z,w);
};
clay_opengl_GLGraphics.setColorUniform = function(shader,location,r,g,b,a) {
	if(clay_opengl_GLGraphics._boundProgram != shader.program) {
		clay_opengl_GLGraphics._boundProgram = shader.program;
		clay_opengl_web_GL.gl.useProgram(shader.program);
	}
	clay_opengl_web_GL.gl.uniform4f(location,r,g,b,a);
};
clay_opengl_GLGraphics.setMatrix4Uniform = function(shader,location,value) {
	if(clay_opengl_GLGraphics._boundProgram != shader.program) {
		clay_opengl_GLGraphics._boundProgram = shader.program;
		clay_opengl_web_GL.gl.useProgram(shader.program);
	}
	clay_opengl_web_GL.gl.uniformMatrix4fv(location,false,value);
};
clay_opengl_GLGraphics.setTexture2dUniform = function(shader,location,slot,texture) {
	if(clay_opengl_GLGraphics._boundProgram != shader.program) {
		clay_opengl_GLGraphics._boundProgram = shader.program;
		clay_opengl_web_GL.gl.useProgram(shader.program);
	}
	clay_opengl_web_GL.gl.uniform1i(location,slot);
	if(clay_opengl_GLGraphics._activeTextureSlot != slot) {
		clay_opengl_GLGraphics._activeTextureSlot = slot;
		while(clay_opengl_GLGraphics._boundTexture2D.length <= clay_opengl_GLGraphics._activeTextureSlot) clay_opengl_GLGraphics._boundTexture2D.push(null);
		clay_opengl_web_GL.gl.activeTexture(33984 + slot);
	}
	if(clay_opengl_GLGraphics._boundTexture2D[clay_opengl_GLGraphics._activeTextureSlot] != texture) {
		clay_opengl_GLGraphics._boundTexture2D[clay_opengl_GLGraphics._activeTextureSlot] = texture;
		clay_opengl_web_GL.gl.bindTexture(3553,texture);
	}
};
clay_opengl_GLGraphics.setBlendFuncSeparate = function(srcRgb,dstRgb,srcAlpha,dstAlpha) {
	clay_opengl_web_GL.gl.blendFuncSeparate(srcRgb,dstRgb,srcAlpha,dstAlpha);
};
clay_opengl_GLGraphics.ensureNoError = function() {
	var error = clay_opengl_web_GL.gl.getError();
	if(error != 0) {
		throw haxe_Exception.thrown("Failed with GL error: " + error);
	}
};
var clay_opengl_GLGraphics_$RenderTarget = function() {
};
clay_opengl_GLGraphics_$RenderTarget.__name__ = true;
var clay_opengl_GLGraphics_$GpuShader = function() {
	this.textures = [];
};
clay_opengl_GLGraphics_$GpuShader.__name__ = true;
var clay_opengl_web_GL = function() { };
clay_opengl_web_GL.__name__ = true;
clay_opengl_web_GL.versionString = function() {
	var ver = clay_opengl_web_GL.gl.getParameter(7938);
	var slver = clay_opengl_web_GL.gl.getParameter(35724);
	var ren = clay_opengl_web_GL.gl.getParameter(7937);
	var ven = clay_opengl_web_GL.gl.getParameter(7936);
	return "/ " + ver + " / " + slver + " / " + ren + " / " + ven + " /";
};
clay_opengl_web_GL.activeTexture = function(texture) {
	clay_opengl_web_GL.gl.activeTexture(texture);
};
clay_opengl_web_GL.attachShader = function(program,shader) {
	clay_opengl_web_GL.gl.attachShader(program,shader);
};
clay_opengl_web_GL.bindAttribLocation = function(program,index,name) {
	clay_opengl_web_GL.gl.bindAttribLocation(program,index,name);
};
clay_opengl_web_GL.bindBuffer = function(target,buffer) {
	clay_opengl_web_GL.gl.bindBuffer(target,buffer);
};
clay_opengl_web_GL.bindFramebuffer = function(target,framebuffer) {
	clay_opengl_web_GL.gl.bindFramebuffer(target,framebuffer);
};
clay_opengl_web_GL.bindRenderbuffer = function(target,renderbuffer) {
	clay_opengl_web_GL.gl.bindRenderbuffer(target,renderbuffer);
};
clay_opengl_web_GL.bindTexture = function(target,texture) {
	clay_opengl_web_GL.gl.bindTexture(target,texture);
};
clay_opengl_web_GL.blendColor = function(red,green,blue,alpha) {
	clay_opengl_web_GL.gl.blendColor(red,green,blue,alpha);
};
clay_opengl_web_GL.blendEquation = function(mode) {
	clay_opengl_web_GL.gl.blendEquation(mode);
};
clay_opengl_web_GL.blendEquationSeparate = function(modeRGB,modeAlpha) {
	clay_opengl_web_GL.gl.blendEquationSeparate(modeRGB,modeAlpha);
};
clay_opengl_web_GL.blendFunc = function(sfactor,dfactor) {
	clay_opengl_web_GL.gl.blendFunc(sfactor,dfactor);
};
clay_opengl_web_GL.blendFuncSeparate = function(srcRGB,dstRGB,srcAlpha,dstAlpha) {
	clay_opengl_web_GL.gl.blendFuncSeparate(srcRGB,dstRGB,srcAlpha,dstAlpha);
};
clay_opengl_web_GL.bufferData = function(target,data,usage) {
	clay_opengl_web_GL.gl.bufferData(target,data,usage);
};
clay_opengl_web_GL.bufferSubData = function(target,offset,data) {
	clay_opengl_web_GL.gl.bufferSubData(target,offset,data);
};
clay_opengl_web_GL.checkFramebufferStatus = function(target) {
	return clay_opengl_web_GL.gl.checkFramebufferStatus(target);
};
clay_opengl_web_GL.clear = function(mask) {
	clay_opengl_web_GL.gl.clear(mask);
};
clay_opengl_web_GL.clearColor = function(red,green,blue,alpha) {
	clay_opengl_web_GL.gl.clearColor(red,green,blue,alpha);
};
clay_opengl_web_GL.clearDepth = function(depth) {
	clay_opengl_web_GL.gl.clearDepth(depth);
};
clay_opengl_web_GL.clearStencil = function(s) {
	clay_opengl_web_GL.gl.clearStencil(s);
};
clay_opengl_web_GL.colorMask = function(red,green,blue,alpha) {
	clay_opengl_web_GL.gl.colorMask(red,green,blue,alpha);
};
clay_opengl_web_GL.compileShader = function(shader) {
	clay_opengl_web_GL.gl.compileShader(shader);
};
clay_opengl_web_GL.compressedTexImage2D = function(target,level,internalformat,width,height,border,data) {
	clay_opengl_web_GL.gl.compressedTexImage2D(target,level,internalformat,width,height,border,data);
};
clay_opengl_web_GL.compressedTexSubImage2D = function(target,level,xoffset,yoffset,width,height,format,data) {
	clay_opengl_web_GL.gl.compressedTexSubImage2D(target,level,xoffset,yoffset,width,height,format,data);
};
clay_opengl_web_GL.copyTexImage2D = function(target,level,internalformat,x,y,width,height,border) {
	clay_opengl_web_GL.gl.copyTexImage2D(target,level,internalformat,x,y,width,height,border);
};
clay_opengl_web_GL.copyTexSubImage2D = function(target,level,xoffset,yoffset,x,y,width,height) {
	clay_opengl_web_GL.gl.copyTexSubImage2D(target,level,xoffset,yoffset,x,y,width,height);
};
clay_opengl_web_GL.createBuffer = function() {
	return clay_opengl_web_GL.gl.createBuffer();
};
clay_opengl_web_GL.createFramebuffer = function() {
	return clay_opengl_web_GL.gl.createFramebuffer();
};
clay_opengl_web_GL.createProgram = function() {
	return clay_opengl_web_GL.gl.createProgram();
};
clay_opengl_web_GL.createRenderbuffer = function() {
	return clay_opengl_web_GL.gl.createRenderbuffer();
};
clay_opengl_web_GL.createShader = function(type) {
	return clay_opengl_web_GL.gl.createShader(type);
};
clay_opengl_web_GL.createTexture = function() {
	return clay_opengl_web_GL.gl.createTexture();
};
clay_opengl_web_GL.cullFace = function(mode) {
	clay_opengl_web_GL.gl.cullFace(mode);
};
clay_opengl_web_GL.deleteBuffer = function(buffer) {
	clay_opengl_web_GL.gl.deleteBuffer(buffer);
};
clay_opengl_web_GL.deleteFramebuffer = function(framebuffer) {
	clay_opengl_web_GL.gl.deleteFramebuffer(framebuffer);
};
clay_opengl_web_GL.deleteProgram = function(program) {
	clay_opengl_web_GL.gl.deleteProgram(program);
};
clay_opengl_web_GL.deleteRenderbuffer = function(renderbuffer) {
	clay_opengl_web_GL.gl.deleteRenderbuffer(renderbuffer);
};
clay_opengl_web_GL.deleteShader = function(shader) {
	clay_opengl_web_GL.gl.deleteShader(shader);
};
clay_opengl_web_GL.deleteTexture = function(texture) {
	clay_opengl_web_GL.gl.deleteTexture(texture);
};
clay_opengl_web_GL.depthFunc = function(func) {
	clay_opengl_web_GL.gl.depthFunc(func);
};
clay_opengl_web_GL.depthMask = function(flag) {
	clay_opengl_web_GL.gl.depthMask(flag);
};
clay_opengl_web_GL.depthRange = function(zNear,zFar) {
	clay_opengl_web_GL.gl.depthRange(zNear,zFar);
};
clay_opengl_web_GL.detachShader = function(program,shader) {
	clay_opengl_web_GL.gl.detachShader(program,shader);
};
clay_opengl_web_GL.disable = function(cap) {
	clay_opengl_web_GL.gl.disable(cap);
};
clay_opengl_web_GL.disableVertexAttribArray = function(index) {
	clay_opengl_web_GL.gl.disableVertexAttribArray(index);
};
clay_opengl_web_GL.drawArrays = function(mode,first,count) {
	clay_opengl_web_GL.gl.drawArrays(mode,first,count);
};
clay_opengl_web_GL.drawElements = function(mode,count,type,offset) {
	clay_opengl_web_GL.gl.drawElements(mode,count,type,offset);
};
clay_opengl_web_GL.enable = function(cap) {
	clay_opengl_web_GL.gl.enable(cap);
};
clay_opengl_web_GL.enableVertexAttribArray = function(index) {
	clay_opengl_web_GL.gl.enableVertexAttribArray(index);
};
clay_opengl_web_GL.finish = function() {
	clay_opengl_web_GL.gl.finish();
};
clay_opengl_web_GL.flush = function() {
	clay_opengl_web_GL.gl.flush();
};
clay_opengl_web_GL.framebufferRenderbuffer = function(target,attachment,renderbuffertarget,renderbuffer) {
	clay_opengl_web_GL.gl.framebufferRenderbuffer(target,attachment,renderbuffertarget,renderbuffer);
};
clay_opengl_web_GL.framebufferTexture2D = function(target,attachment,textarget,texture,level) {
	clay_opengl_web_GL.gl.framebufferTexture2D(target,attachment,textarget,texture,level);
};
clay_opengl_web_GL.frontFace = function(mode) {
	clay_opengl_web_GL.gl.frontFace(mode);
};
clay_opengl_web_GL.generateMipmap = function(target) {
	clay_opengl_web_GL.gl.generateMipmap(target);
};
clay_opengl_web_GL.getActiveAttrib = function(program,index) {
	return clay_opengl_web_GL.gl.getActiveAttrib(program,index);
};
clay_opengl_web_GL.getActiveUniform = function(program,index) {
	return clay_opengl_web_GL.gl.getActiveUniform(program,index);
};
clay_opengl_web_GL.getAttachedShaders = function(program) {
	return clay_opengl_web_GL.gl.getAttachedShaders(program);
};
clay_opengl_web_GL.getAttribLocation = function(program,name) {
	return clay_opengl_web_GL.gl.getAttribLocation(program,name);
};
clay_opengl_web_GL.getBufferParameter = function(target,pname) {
	return clay_opengl_web_GL.gl.getBufferParameter(target,pname);
};
clay_opengl_web_GL.getContextAttributes = function() {
	return clay_opengl_web_GL.gl.getContextAttributes();
};
clay_opengl_web_GL.getError = function() {
	return clay_opengl_web_GL.gl.getError();
};
clay_opengl_web_GL.getExtension = function(name) {
	return clay_opengl_web_GL.gl.getExtension(name);
};
clay_opengl_web_GL.getFramebufferAttachmentParameter = function(target,attachment,pname) {
	return clay_opengl_web_GL.gl.getFramebufferAttachmentParameter(target,attachment,pname);
};
clay_opengl_web_GL.getParameter = function(pname) {
	return clay_opengl_web_GL.gl.getParameter(pname);
};
clay_opengl_web_GL.getProgramInfoLog = function(program) {
	return clay_opengl_web_GL.gl.getProgramInfoLog(program);
};
clay_opengl_web_GL.getProgramParameter = function(program,pname) {
	return clay_opengl_web_GL.gl.getProgramParameter(program,pname);
};
clay_opengl_web_GL.getRenderbufferParameter = function(target,pname) {
	return clay_opengl_web_GL.gl.getRenderbufferParameter(target,pname);
};
clay_opengl_web_GL.getShaderInfoLog = function(shader) {
	return clay_opengl_web_GL.gl.getShaderInfoLog(shader);
};
clay_opengl_web_GL.getShaderParameter = function(shader,pname) {
	return clay_opengl_web_GL.gl.getShaderParameter(shader,pname);
};
clay_opengl_web_GL.getShaderPrecisionFormat = function(shadertype,precisiontype) {
	return clay_opengl_web_GL.gl.getShaderPrecisionFormat(shadertype,precisiontype);
};
clay_opengl_web_GL.getShaderSource = function(shader) {
	return clay_opengl_web_GL.gl.getShaderSource(shader);
};
clay_opengl_web_GL.getSupportedExtensions = function() {
	return clay_opengl_web_GL.gl.getSupportedExtensions();
};
clay_opengl_web_GL.getTexParameter = function(target,pname) {
	return clay_opengl_web_GL.gl.getTexParameter(target,pname);
};
clay_opengl_web_GL.getUniform = function(program,location) {
	return clay_opengl_web_GL.gl.getUniform(program,location);
};
clay_opengl_web_GL.getUniformLocation = function(program,name) {
	return clay_opengl_web_GL.gl.getUniformLocation(program,name);
};
clay_opengl_web_GL.getVertexAttrib = function(index,pname) {
	return clay_opengl_web_GL.gl.getVertexAttrib(index,pname);
};
clay_opengl_web_GL.getVertexAttribOffset = function(index,pname) {
	return clay_opengl_web_GL.gl.getVertexAttribOffset(index,pname);
};
clay_opengl_web_GL.hint = function(target,mode) {
	clay_opengl_web_GL.gl.hint(target,mode);
};
clay_opengl_web_GL.isBuffer = function(buffer) {
	return clay_opengl_web_GL.gl.isBuffer(buffer);
};
clay_opengl_web_GL.isEnabled = function(cap) {
	return clay_opengl_web_GL.gl.isEnabled(cap);
};
clay_opengl_web_GL.isFramebuffer = function(framebuffer) {
	return clay_opengl_web_GL.gl.isFramebuffer(framebuffer);
};
clay_opengl_web_GL.isProgram = function(program) {
	return clay_opengl_web_GL.gl.isProgram(program);
};
clay_opengl_web_GL.isRenderbuffer = function(renderbuffer) {
	return clay_opengl_web_GL.gl.isRenderbuffer(renderbuffer);
};
clay_opengl_web_GL.isShader = function(shader) {
	return clay_opengl_web_GL.gl.isShader(shader);
};
clay_opengl_web_GL.isTexture = function(texture) {
	return clay_opengl_web_GL.gl.isTexture(texture);
};
clay_opengl_web_GL.lineWidth = function(width) {
	clay_opengl_web_GL.gl.lineWidth(width);
};
clay_opengl_web_GL.linkProgram = function(program) {
	clay_opengl_web_GL.gl.linkProgram(program);
};
clay_opengl_web_GL.pixelStorei = function(pname,param) {
	clay_opengl_web_GL.gl.pixelStorei(pname,param);
};
clay_opengl_web_GL.polygonOffset = function(factor,units) {
	clay_opengl_web_GL.gl.polygonOffset(factor,units);
};
clay_opengl_web_GL.readPixels = function(x,y,width,height,format,type,data) {
	clay_opengl_web_GL.gl.readPixels(x,y,width,height,format,type,data);
};
clay_opengl_web_GL.renderbufferStorage = function(target,internalformat,width,height) {
	clay_opengl_web_GL.gl.renderbufferStorage(target,internalformat,width,height);
};
clay_opengl_web_GL.sampleCoverage = function(value,invert) {
	clay_opengl_web_GL.gl.sampleCoverage(value,invert);
};
clay_opengl_web_GL.scissor = function(x,y,width,height) {
	clay_opengl_web_GL.gl.scissor(x,y,width,height);
};
clay_opengl_web_GL.shaderSource = function(shader,source) {
	clay_opengl_web_GL.gl.shaderSource(shader,source);
};
clay_opengl_web_GL.stencilFunc = function(func,ref,mask) {
	clay_opengl_web_GL.gl.stencilFunc(func,ref,mask);
};
clay_opengl_web_GL.stencilFuncSeparate = function(face,func,ref,mask) {
	clay_opengl_web_GL.gl.stencilFuncSeparate(face,func,ref,mask);
};
clay_opengl_web_GL.stencilMask = function(mask) {
	clay_opengl_web_GL.gl.stencilMask(mask);
};
clay_opengl_web_GL.stencilMaskSeparate = function(face,mask) {
	clay_opengl_web_GL.gl.stencilMaskSeparate(face,mask);
};
clay_opengl_web_GL.stencilOp = function(fail,zfail,zpass) {
	clay_opengl_web_GL.gl.stencilOp(fail,zfail,zpass);
};
clay_opengl_web_GL.stencilOpSeparate = function(face,fail,zfail,zpass) {
	clay_opengl_web_GL.gl.stencilOpSeparate(face,fail,zfail,zpass);
};
clay_opengl_web_GL.texImage2D = function(target,level,internalformat,width,height,border,format,type,data) {
	clay_opengl_web_GL.gl.texImage2D(target,level,internalformat,width,height,border,format,type,data);
};
clay_opengl_web_GL.texParameterf = function(target,pname,param) {
	clay_opengl_web_GL.gl.texParameterf(target,pname,param);
};
clay_opengl_web_GL.texParameteri = function(target,pname,param) {
	clay_opengl_web_GL.gl.texParameteri(target,pname,param);
};
clay_opengl_web_GL.texSubImage2D = function(target,level,xoffset,yoffset,width,height,format,type,data) {
	clay_opengl_web_GL.gl.texSubImage2D(target,level,xoffset,yoffset,width,height,format,type,data);
};
clay_opengl_web_GL.uniform1f = function(location,x) {
	clay_opengl_web_GL.gl.uniform1f(location,x);
};
clay_opengl_web_GL.uniform1fv = function(location,data) {
	clay_opengl_web_GL.gl.uniform1fv(location,data);
};
clay_opengl_web_GL.uniform1i = function(location,x) {
	clay_opengl_web_GL.gl.uniform1i(location,x);
};
clay_opengl_web_GL.uniform1iv = function(location,data) {
	clay_opengl_web_GL.gl.uniform1iv(location,data);
};
clay_opengl_web_GL.uniform2f = function(location,x,y) {
	clay_opengl_web_GL.gl.uniform2f(location,x,y);
};
clay_opengl_web_GL.uniform2fv = function(location,data) {
	clay_opengl_web_GL.gl.uniform2fv(location,data);
};
clay_opengl_web_GL.uniform2i = function(location,x,y) {
	clay_opengl_web_GL.gl.uniform2i(location,x,y);
};
clay_opengl_web_GL.uniform2iv = function(location,data) {
	clay_opengl_web_GL.gl.uniform2iv(location,data);
};
clay_opengl_web_GL.uniform3f = function(location,x,y,z) {
	clay_opengl_web_GL.gl.uniform3f(location,x,y,z);
};
clay_opengl_web_GL.uniform3fv = function(location,data) {
	clay_opengl_web_GL.gl.uniform3fv(location,data);
};
clay_opengl_web_GL.uniform3i = function(location,x,y,z) {
	clay_opengl_web_GL.gl.uniform3i(location,x,y,z);
};
clay_opengl_web_GL.uniform3iv = function(location,data) {
	clay_opengl_web_GL.gl.uniform3iv(location,data);
};
clay_opengl_web_GL.uniform4f = function(location,x,y,z,w) {
	clay_opengl_web_GL.gl.uniform4f(location,x,y,z,w);
};
clay_opengl_web_GL.uniform4fv = function(location,data) {
	clay_opengl_web_GL.gl.uniform4fv(location,data);
};
clay_opengl_web_GL.uniform4i = function(location,x,y,z,w) {
	clay_opengl_web_GL.gl.uniform4i(location,x,y,z,w);
};
clay_opengl_web_GL.uniform4iv = function(location,data) {
	clay_opengl_web_GL.gl.uniform4iv(location,data);
};
clay_opengl_web_GL.uniformMatrix2fv = function(location,transpose,data) {
	clay_opengl_web_GL.gl.uniformMatrix2fv(location,transpose,data);
};
clay_opengl_web_GL.uniformMatrix3fv = function(location,transpose,data) {
	clay_opengl_web_GL.gl.uniformMatrix3fv(location,transpose,data);
};
clay_opengl_web_GL.uniformMatrix4fv = function(location,transpose,data) {
	clay_opengl_web_GL.gl.uniformMatrix4fv(location,transpose,data);
};
clay_opengl_web_GL.useProgram = function(program) {
	clay_opengl_web_GL.gl.useProgram(program);
};
clay_opengl_web_GL.validateProgram = function(program) {
	clay_opengl_web_GL.gl.validateProgram(program);
};
clay_opengl_web_GL.vertexAttrib1f = function(indx,x) {
	clay_opengl_web_GL.gl.vertexAttrib1f(indx,x);
};
clay_opengl_web_GL.vertexAttrib1fv = function(indx,data) {
	clay_opengl_web_GL.gl.vertexAttrib1fv(indx,data);
};
clay_opengl_web_GL.vertexAttrib2f = function(indx,x,y) {
	clay_opengl_web_GL.gl.vertexAttrib2f(indx,x,y);
};
clay_opengl_web_GL.vertexAttrib2fv = function(indx,data) {
	clay_opengl_web_GL.gl.vertexAttrib2fv(indx,data);
};
clay_opengl_web_GL.vertexAttrib3f = function(indx,x,y,z) {
	clay_opengl_web_GL.gl.vertexAttrib3f(indx,x,y,z);
};
clay_opengl_web_GL.vertexAttrib3fv = function(indx,data) {
	clay_opengl_web_GL.gl.vertexAttrib3fv(indx,data);
};
clay_opengl_web_GL.vertexAttrib4f = function(indx,x,y,z,w) {
	clay_opengl_web_GL.gl.vertexAttrib4f(indx,x,y,z,w);
};
clay_opengl_web_GL.vertexAttrib4fv = function(indx,data) {
	clay_opengl_web_GL.gl.vertexAttrib4fv(indx,data);
};
clay_opengl_web_GL.vertexAttribPointer = function(indx,size,type,normalized,stride,offset) {
	clay_opengl_web_GL.gl.vertexAttribPointer(indx,size,type,normalized,stride,offset);
};
clay_opengl_web_GL.viewport = function(x,y,width,height) {
	clay_opengl_web_GL.gl.viewport(x,y,width,height);
};
clay_opengl_web_GL.get_version = function() {
	return 7938;
};
var clay_web_WebAssets = function(app) {
	clay_base_BaseAssets.call(this,app);
};
clay_web_WebAssets.__name__ = true;
clay_web_WebAssets.__super__ = clay_base_BaseAssets;
clay_web_WebAssets.prototype = $extend(clay_base_BaseAssets.prototype,{
	isSynchronous: function() {
		return false;
	}
	,loadImage: function(path,components,async,callback) {
		if(async == null) {
			async = false;
		}
		if(components == null) {
			components = 4;
		}
		var _gthis = this;
		if(path == null) {
			throw haxe_Exception.thrown("Image path is null!");
		}
		var ext = haxe_io_Path.extension(path);
		this.app.io.loadData(path,true,null,function(bytes) {
			if(bytes == null) {
				if(callback != null) {
					clay_Immediate.push(function() {
						callback(null);
					});
				}
				return;
			}
			_gthis.imageFromBytesUsingImageElement(bytes,ext,4,null,function(image) {
				if(callback != null) {
					clay_Immediate.push(function() {
						callback(image);
					});
				}
			});
		});
		return null;
	}
	,decodeImageFromElement: function(elem,pot) {
		if(pot == null) {
			pot = true;
		}
		var widthActual = pot ? this.nearestPowerOfTwo(elem.width) : elem.width;
		var heightActual = pot ? this.nearestPowerOfTwo(elem.height) : elem.height;
		var imageBytes = this.paddedBytesFromElement(elem.width,elem.height,widthActual,heightActual,elem);
		var image = new clay_Image(elem.width,elem.height,widthActual,heightActual,4,4,imageBytes);
		imageBytes = null;
		return image;
	}
	,imageFromBytes: function(bytes,ext,components,pot,callback) {
		if(pot == null) {
			pot = true;
		}
		if(components == null) {
			components = 4;
		}
		return this.imageFromBytesUsingImageElement(bytes,ext,components,pot,callback);
	}
	,imageFromBytesUsingImageElement: function(bytes,ext,components,pot,callback) {
		if(pot == null) {
			pot = true;
		}
		if(components == null) {
			components = 4;
		}
		var _gthis = this;
		if(bytes == null) {
			throw haxe_Exception.thrown("Image bytes are null!");
		}
		var str = "";
		var i = 0;
		var len = bytes.length;
		while(i < len) {
			var code = bytes[i++] & 255;
			str += String.fromCodePoint(code);
		}
		var b64 = window.btoa(str);
		var src = "data:image/" + ext + ";base64," + b64;
		var img = new Image();
		img.onload = function(_) {
			var image = _gthis.decodeImageFromElement(img,pot);
			if(callback != null) {
				clay_Immediate.push(function() {
					callback(image);
				});
			}
		};
		img.onerror = function(e) {
			clay_Log.error("failed to load image from bytes, on error: " + e,{ fileName : "clay/web/WebAssets.hx", lineNumber : 216, className : "clay.web.WebAssets", methodName : "imageFromBytesUsingImageElement"});
		};
		img.src = src;
		return null;
	}
	,pixelsToPngData: function(width,height,pixels,callback) {
		var tmpCanvas = window.document.createElement("canvas");
		tmpCanvas.width = width;
		tmpCanvas.height = height;
		var tmpContext = tmpCanvas.getContext("2d",null);
		tmpContext.clearRect(0,0,tmpCanvas.width,tmpCanvas.height);
		var imageBytes = null;
		var pixels1 = new Uint8ClampedArray(pixels.buffer);
		var imgdata = tmpContext.createImageData(width,height);
		imgdata.data.set(pixels1);
		try {
			tmpContext.putImageData(imgdata,0,0);
			tmpCanvas.toBlob(function(blob) {
				blob.arrayBuffer().then(function(buffer) {
					var pngData = new Uint8Array(buffer,0,buffer.byteLength);
					callback(pngData);
					tmpCanvas = null;
					tmpContext = null;
					imgdata = null;
				});
			},"image/png");
		} catch( _g ) {
			var e = haxe_Exception.caught(_g).unwrap();
			throw haxe_Exception.thrown(e);
		}
	}
	,paddedBytesFromPixels: function(width,height,widthPadded,heightPadded,source) {
		var tmpCanvas = window.document.createElement("canvas");
		tmpCanvas.width = widthPadded;
		tmpCanvas.height = heightPadded;
		var tmpContext = tmpCanvas.getContext("2d",null);
		tmpContext.clearRect(0,0,tmpCanvas.width,tmpCanvas.height);
		var imageBytes = null;
		var pixels = new Uint8ClampedArray(source.buffer);
		var imgdata = tmpContext.createImageData(width,height);
		imgdata.data.set(pixels);
		try {
			tmpContext.putImageData(imgdata,0,0);
			imageBytes = tmpContext.getImageData(0,0,tmpCanvas.width,tmpCanvas.height);
		} catch( _g ) {
			var e = haxe_Exception.caught(_g).unwrap();
			throw haxe_Exception.thrown(e);
		}
		tmpCanvas = null;
		tmpContext = null;
		imgdata = null;
		return new Uint8Array(imageBytes.data);
	}
	,paddedBytesFromElement: function(width,height,widthPadded,heightPadded,source) {
		var tmpCanvas = window.document.createElement("canvas");
		tmpCanvas.width = widthPadded;
		tmpCanvas.height = heightPadded;
		var tmpContext = tmpCanvas.getContext("2d",null);
		tmpContext.clearRect(0,0,tmpCanvas.width,tmpCanvas.height);
		tmpContext.drawImage(source,0,0,width,height);
		var imageBytes = null;
		try {
			imageBytes = tmpContext.getImageData(0,0,tmpCanvas.width,tmpCanvas.height);
		} catch( _g ) {
			var e = haxe_Exception.caught(_g).unwrap();
			var tips = "- textures served from file:/// throw security errors\n";
			tips += "- textures served over http:// work for cross origin byte requests";
			clay_Log.info(tips,{ fileName : "clay/web/WebAssets.hx", lineNumber : 333, className : "clay.web.WebAssets", methodName : "paddedBytesFromElement"});
			throw haxe_Exception.thrown(e);
		}
		tmpCanvas = null;
		tmpContext = null;
		return new Uint8Array(imageBytes.data);
	}
	,nearestPowerOfTwo: function(value) {
		if(!clay_web_WebAssets.POT) {
			return value;
		}
		--value;
		value |= value >> 1;
		value |= value >> 2;
		value |= value >> 4;
		value |= value >> 8;
		value |= value >> 16;
		return ++value;
	}
});
var clay_web_WebAudio = function(app) {
	this.active = false;
	this.handleSeq = 0;
	this.suspended = false;
	clay_base_BaseAudio.call(this,app);
	this.instances = new haxe_ds_IntMap();
};
clay_web_WebAudio.__name__ = true;
clay_web_WebAudio.__super__ = clay_base_BaseAudio;
clay_web_WebAudio.prototype = $extend(clay_base_BaseAudio.prototype,{
	init: function() {
		this.initWebAudio();
	}
	,initWebAudio: function() {
		try {
			this.context = new AudioContext();
		} catch( _g ) {
			try {
				this.context = new window.webkitAudioContext();
			} catch( _g1 ) {
				clay_Log.debug("Audio / webaudio / no AudioContext could be created! No audio loading or playback will be available.",{ fileName : "clay/web/WebAudio.hx", lineNumber : 73, className : "clay.web.WebAudio", methodName : "initWebAudio"});
				return;
			}
		}
		if(this.context == null) {
			throw haxe_Exception.thrown("Audio / webaudio / no AudioContext could be created, is the Web Audio API supported?");
		}
		var info = "channelCount: " + this.context.destination.channelCount + ", " + ("channelCountMode: \"" + this.context.destination.channelCountMode + "\", ") + ("channelInterpretation: \"" + this.context.destination.channelInterpretation + "\", ") + ("maxChannelCount: " + this.context.destination.maxChannelCount + ", ") + ("numberOfInputs: " + this.context.destination.numberOfInputs + ", ") + ("numberOfOutputs: " + this.context.destination.numberOfOutputs);
		clay_Log.debug("Audio / webaudio: " + Std.string(this.context) + " / sampleRate: " + this.context.sampleRate + " / destination: " + info,{ fileName : "clay/web/WebAudio.hx", lineNumber : 89, className : "clay.web.WebAudio", methodName : "initWebAudio"});
		this.active = true;
	}
	,shutdown: function() {
		this.context.close();
	}
	,soundOf: function(handle) {
		return this.instances.h[handle];
	}
	,playBuffer: function(data) {
		var node = this.context.createBufferSource();
		node.buffer = data.buffer;
		return node;
	}
	,playBufferAgain: function(handle,sound,startTime) {
		sound.bufferNode = this.playBuffer(sound.source.data);
		sound.bufferNode.connect(sound.panNode);
		sound.bufferNode.loop = sound.loop;
		sound.panNode.connect(sound.gainNode);
		sound.gainNode.connect(this.context.destination);
		sound.bufferNode.start(0,startTime);
		var _g = $bind(this,this.destroySound);
		var sound1 = sound;
		var tmp = function() {
			_g(sound1);
		};
		sound.bufferNode.onended = tmp;
	}
	,playInstance: function(handle,source,inst,data,bufferNode,volume,loop) {
		var _gthis = this;
		var gain = this.context.createGain();
		var pan = this.context.createPanner();
		var node = null;
		var panVal = 0;
		gain.gain.value = volume;
		pan.panningModel = "equalpower";
		pan.setPosition(Math.cos(-1.5707),0,Math.sin(1.5707));
		if(bufferNode != null) {
			node = bufferNode;
			bufferNode.loop = loop;
		}
		if(data.mediaNode != null) {
			node = data.mediaNode;
			data.mediaElem.loop = loop;
		}
		node.connect(pan);
		pan.connect(gain);
		gain.connect(this.context.destination);
		var sound = { handle : handle, source : source, instance : inst, bufferNode : bufferNode, mediaNode : data.mediaNode, mediaElem : data.mediaElem, gainNode : gain, panNode : pan, state : 1, loop : loop, pan : 0, timeResumeAppTime : this.app.timestamp, timeResume : 0.0, timePause : null};
		this.instances.h[handle] = sound;
		if(bufferNode != null) {
			bufferNode.start(0);
			var _g = $bind(this,this.destroySound);
			var sound1 = sound;
			bufferNode.onended = function() {
				_g(sound1);
			};
		}
		if(data.mediaNode != null) {
			data.mediaElem.play();
			data.mediaNode.addEventListener("ended",function() {
				_gthis.app.events.audioEvent(0,handle);
				sound.state = 2;
			});
		}
	}
	,play: function(source,volume,paused) {
		var data = source.data;
		var handle = this.handleSeq;
		var inst = source.instance(handle);
		if(source.data.isStream) {
			data.mediaElem.play();
			data.mediaElem.volume = 1.0;
			this.playInstance(handle,source,inst,data,null,volume,false);
		} else {
			this.playInstance(handle,source,inst,data,this.playBuffer(data),volume,false);
		}
		this.handleSeq++;
		return handle;
	}
	,loop: function(source,volume,paused) {
		var data = source.data;
		var handle = this.handleSeq;
		var inst = source.instance(handle);
		if(source.data.isStream) {
			data.mediaElem.play();
			data.mediaElem.volume = 1.0;
			this.playInstance(handle,source,inst,data,null,volume,true);
		} else {
			this.playInstance(handle,source,inst,data,this.playBuffer(data),volume,true);
		}
		this.handleSeq++;
		return handle;
	}
	,stopBuffer: function(sound) {
		sound.bufferNode.stop();
		sound.bufferNode.disconnect();
		sound.gainNode.disconnect();
		sound.panNode.disconnect();
		sound.bufferNode = null;
	}
	,pause: function(handle) {
		var sound = this.instances.h[handle];
		if(sound == null) {
			return;
		}
		clay_Log.debug("Audio / pause handle=" + handle + ", " + sound.source.data.id,{ fileName : "clay/web/WebAudio.hx", lineNumber : 260, className : "clay.web.WebAudio", methodName : "pause"});
		var timePause = sound.timeResume + this.app.timestamp - sound.timeResumeAppTime;
		var duration = sound.source.getDuration();
		if(duration > 0) {
			if(sound.loop) {
				timePause %= duration;
			} else if(timePause > duration) {
				timePause = duration;
			}
		}
		sound.timePause = timePause;
		sound.state = 0;
		if(sound.bufferNode != null) {
			this.stopBuffer(sound);
		} else if(sound.mediaNode != null) {
			sound.mediaElem.pause();
		}
	}
	,unPause: function(handle) {
		var sound = this.instances.h[handle];
		if(sound == null) {
			return;
		}
		if(sound.state != 0) {
			return;
		}
		clay_Log.debug("Audio / unpause handle=" + handle + ", " + sound.source.data.id,{ fileName : "clay/web/WebAudio.hx", lineNumber : 290, className : "clay.web.WebAudio", methodName : "unPause"});
		sound.timeResume = sound.timePause != null ? sound.timePause : 0;
		sound.timeResumeAppTime = this.app.timestamp;
		if(sound.mediaNode == null) {
			this.playBufferAgain(handle,sound,sound.timePause);
		} else {
			sound.mediaElem.play();
		}
		sound.state = 1;
	}
	,destroySound: function(sound) {
		if(sound.bufferNode != null) {
			sound.bufferNode.stop();
			sound.bufferNode.disconnect();
			sound.bufferNode = null;
		}
		if(sound.mediaNode != null) {
			sound.mediaElem.pause();
			sound.mediaElem.currentTime = 0;
			sound.mediaNode.disconnect();
			sound.mediaElem = null;
			sound.mediaNode = null;
		}
		if(sound.gainNode != null) {
			sound.gainNode.disconnect();
			sound.gainNode = null;
		}
		if(sound.panNode != null) {
			sound.panNode.disconnect();
			sound.panNode = null;
		}
		this.instances.remove(sound.handle);
		sound = null;
	}
	,stop: function(handle) {
		var sound = this.instances.h[handle];
		if(sound == null) {
			return;
		}
		clay_Log.debug("Audio / stop handle=" + handle + ", " + sound.source.data.id,{ fileName : "clay/web/WebAudio.hx", lineNumber : 342, className : "clay.web.WebAudio", methodName : "stop"});
		this.destroySound(sound);
		sound.state = 2;
	}
	,volume: function(handle,volume) {
		var sound = this.instances.h[handle];
		if(sound == null) {
			return;
		}
		clay_Log.debug("Audio / volume=" + volume + " handle=" + handle + ", " + sound.source.data.id,{ fileName : "clay/web/WebAudio.hx", lineNumber : 356, className : "clay.web.WebAudio", methodName : "volume"});
		sound.gainNode.gain.value = volume;
	}
	,pan: function(handle,pan) {
		var sound = this.instances.h[handle];
		if(sound == null) {
			return;
		}
		clay_Log.debug("Audio / pan=" + pan + " handle=" + handle + ", " + sound.source.data.id,{ fileName : "clay/web/WebAudio.hx", lineNumber : 368, className : "clay.web.WebAudio", methodName : "pan"});
		sound.pan = pan;
		sound.panNode.setPosition(Math.cos((pan - 1) * 1.5707),0,Math.sin((pan + 1) * 1.5707));
	}
	,pitch: function(handle,pitch) {
		var sound = this.instances.h[handle];
		if(sound == null) {
			return;
		}
		clay_Log.debug("Audio / pitch=" + pitch + " handle=" + handle + ", " + sound.source.data.id,{ fileName : "clay/web/WebAudio.hx", lineNumber : 384, className : "clay.web.WebAudio", methodName : "pitch"});
		if(sound.bufferNode != null) {
			sound.bufferNode.playbackRate.value = pitch;
		} else if(sound.mediaNode != null) {
			sound.mediaElem.playbackRate = pitch;
		}
	}
	,position: function(handle,time) {
		var sound = this.instances.h[handle];
		if(sound == null) {
			return;
		}
		clay_Log.debug("Audio / position=" + time + " handle=" + handle + ", " + sound.source.data.id,{ fileName : "clay/web/WebAudio.hx", lineNumber : 400, className : "clay.web.WebAudio", methodName : "position"});
		if(sound.bufferNode != null) {
			this.stopBuffer(sound);
			this.playBufferAgain(handle,sound,time);
		} else {
			sound.mediaElem.currentTime = time;
		}
	}
	,volumeOf: function(handle) {
		var sound = this.instances.h[handle];
		if(sound == null) {
			return 0.0;
		}
		return sound.gainNode.gain.value;
	}
	,panOf: function(handle) {
		var sound = this.instances.h[handle];
		if(sound == null) {
			return 0.0;
		}
		return sound.pan;
	}
	,pitchOf: function(handle) {
		var sound = this.instances.h[handle];
		if(sound == null) {
			return 0.0;
		}
		var result = 1.0;
		if(sound.bufferNode != null) {
			result = sound.bufferNode.playbackRate.value;
		} else if(sound.mediaNode != null) {
			result = sound.mediaElem.playbackRate;
		}
		return result;
	}
	,positionOf: function(handle) {
		var sound = this.instances.h[handle];
		if(sound == null) {
			return 0.0;
		}
		if(sound.bufferNode != null) {
			switch(sound.state) {
			case -1:case 2:
				return 0.0;
			case 0:case 1:
				var time;
				switch(sound.state) {
				case 0:
					time = sound.timePause;
					break;
				case 1:
					time = sound.timeResume + (this.app.timestamp - sound.timeResumeAppTime);
					break;
				default:
					time = 0.0;
				}
				var duration = sound.source.getDuration();
				if(duration > 0) {
					if(sound.loop) {
						time %= duration;
					} else if(time > duration) {
						time = duration;
					}
				}
				return time;
			}
		} else {
			return sound.mediaElem.currentTime;
		}
	}
	,stateOf: function(handle) {
		var sound = this.instances.h[handle];
		if(sound == null) {
			return -1;
		}
		return sound.state;
	}
	,loopOf: function(handle) {
		var sound = this.instances.h[handle];
		if(sound == null) {
			return false;
		}
		return sound.loop;
	}
	,instanceOf: function(handle) {
		var sound = this.instances.h[handle];
		if(sound == null) {
			return null;
		}
		return sound.instance;
	}
	,suspend: function() {
		if(!this.active) {
			return;
		}
		if(this.suspended) {
			return;
		}
		this.suspended = true;
		this.active = false;
		this.context.suspend();
	}
	,resume: function() {
		if(this.active) {
			return;
		}
		if(!this.suspended) {
			return;
		}
		this.suspended = false;
		this.active = true;
		this.context.resume();
	}
	,loadData: function(path,isStream,format,async,callback) {
		if(async == null) {
			async = false;
		}
		if(path == null) {
			throw haxe_Exception.thrown("path is null!");
		}
		if(!this.active) {
			clay_Log.error("Audio / WebAudio context unavailable",{ fileName : "clay/web/WebAudio.hx", lineNumber : 547, className : "clay.web.WebAudio", methodName : "loadData"});
			if(callback != null) {
				clay_Immediate.push(function() {
					callback(null);
				});
			}
			return null;
		}
		if(isStream) {
			this.loadDataFromStream(path,format,callback);
			return null;
		}
		this.loadDataFromSound(path,format,callback);
		return null;
	}
	,dataFromBytes: function(id,bytes,format,callback) {
		var _gthis = this;
		if(!this.active) {
			if(callback != null) {
				clay_Immediate.push(function() {
					callback(null);
				});
			}
			return;
		}
		this.context.decodeAudioData(bytes.buffer,function(buffer) {
			var data = new clay_web__$WebAudio_WebAudioData(_gthis.app,buffer,null,null,new clay_audio_AudioDataOptions(id,buffer.sampleRate | 0,buffer.length,buffer.numberOfChannels,null,format,null,false));
			if(callback != null) {
				clay_Immediate.push(function() {
					callback(data);
				});
			}
		},function() {
			clay_Log.error("Audio / failed to decode audio for `" + id + "`",{ fileName : "clay/web/WebAudio.hx", lineNumber : 598, className : "clay.web.WebAudio", methodName : "dataFromBytes"});
			if(callback != null) {
				clay_Immediate.push(function() {
					callback(null);
				});
			}
		});
	}
	,handleSourceDestroyed: function(source) {
	}
	,handleInstanceDestroyed: function(handle) {
	}
	,loadDataFromSound: function(path,format,callback) {
		var _gthis = this;
		this.app.io.loadData(path,true,null,function(bytes) {
			_gthis.dataFromBytes(path,bytes,format,callback);
		});
	}
	,loadDataFromStream: function(path,format,callback) {
		var _gthis = this;
		var element = new Audio(path);
		element.autoplay = false;
		element.controls = false;
		element.preload = "auto";
		element.onerror = function(err) {
			var error;
			switch(element.error.code) {
			case 1:
				error = "MEDIA_ERR_ABORTED";
				break;
			case 2:
				error = "MEDIA_ERR_NETWORK";
				break;
			case 3:
				error = "MEDIA_ERR_DECODE";
				break;
			case 4:
				error = "MEDIA_ERR_SRC_NOT_SUPPORTED";
				break;
			case 5:
				error = "MEDIA_ERR_ENCRYPTED";
				break;
			default:
				error = "unknown error";
			}
			clay_Log.error("Audio / failed to load `" + path + "` as stream : `" + error + "`",{ fileName : "clay/web/WebAudio.hx", lineNumber : 652, className : "clay.web.WebAudio", methodName : "loadDataFromStream"});
			if(callback != null) {
				clay_Immediate.push(function() {
					callback(null);
				});
			}
		};
		element.onloadedmetadata = function(_) {
			var node = _gthis.context.createMediaElementSource(element);
			var bytesPerSample = 2;
			var rate = _gthis.context.sampleRate | 0;
			var channels = node.channelCount;
			var sampleFrames = rate * channels * bytesPerSample;
			var length = element.duration * sampleFrames | 0;
			var data = new clay_web__$WebAudio_WebAudioData(_gthis.app,null,node,element,new clay_audio_AudioDataOptions(path,rate,length,channels,null,format,null,true));
			if(callback != null) {
				clay_Immediate.push(function() {
					callback(data);
				});
			}
		};
	}
});
var clay_web__$WebAudio_WebAudioData = function(app,buffer,mediaNode,mediaElem,options) {
	this.buffer = buffer;
	this.mediaNode = mediaNode;
	this.mediaElem = mediaElem;
	clay_audio_AudioData.call(this,app,options);
};
clay_web__$WebAudio_WebAudioData.__name__ = true;
clay_web__$WebAudio_WebAudioData.__super__ = clay_audio_AudioData;
clay_web__$WebAudio_WebAudioData.prototype = $extend(clay_audio_AudioData.prototype,{
	destroy: function() {
		this.buffer = null;
		this.mediaNode = null;
		this.mediaElem = null;
		clay_audio_AudioData.prototype.destroy.call(this);
	}
});
var clay_web_WebConfig = function(windowId,windowParent,preventDefaultContextMenu,preventDefaultMouseWheel,preventDefaultTouches,preventDefaultKeys,mouseUseBrowserWindowEvents) {
	this.mouseUseBrowserWindowEvents = true;
	this.preventDefaultKeys = [1073741904,1073741903,1073741906,1073741905,8,9,127,32];
	this.preventDefaultTouches = true;
	this.preventDefaultMouseWheel = true;
	this.preventDefaultContextMenu = true;
	this.windowParent = window.document.body;
	this.windowId = "app";
	if(windowId != null) {
		this.windowId = windowId;
	}
	if(windowParent != null) {
		this.windowParent = windowParent;
	}
	if(preventDefaultContextMenu != null) {
		this.preventDefaultContextMenu = preventDefaultContextMenu;
	}
	if(preventDefaultMouseWheel != null) {
		this.preventDefaultMouseWheel = preventDefaultMouseWheel;
	}
	if(preventDefaultTouches != null) {
		this.preventDefaultTouches = preventDefaultTouches;
	}
	if(preventDefaultKeys != null) {
		this.preventDefaultKeys = preventDefaultKeys;
	}
	if(mouseUseBrowserWindowEvents != null) {
		this.mouseUseBrowserWindowEvents = mouseUseBrowserWindowEvents;
	}
};
clay_web_WebConfig.__name__ = true;
var clay_web_WebIO = function(app) {
	clay_base_BaseIO.call(this,app);
};
clay_web_WebIO.__name__ = true;
clay_web_WebIO.__super__ = clay_base_BaseIO;
clay_web_WebIO.prototype = $extend(clay_base_BaseIO.prototype,{
	isSynchronous: function() {
		return false;
	}
	,loadData: function(path,binary,async,callback) {
		if(async == null) {
			async = false;
		}
		if(binary == null) {
			binary = false;
		}
		if(path == null) {
			throw haxe_Exception.thrown("Path is null!");
		}
		var asyncHttp = true;
		var request = new XMLHttpRequest();
		request.open("GET",path,asyncHttp);
		if(binary) {
			request.overrideMimeType("text/plain; charset=x-user-defined");
		} else {
			request.overrideMimeType("text/plain; charset=UTF-8");
		}
		if(asyncHttp) {
			request.responseType = "arraybuffer";
		}
		request.onload = function(data) {
			if(request.status == 200) {
				var this1 = new Uint8Array(request.response);
				var data1 = this1;
				if(callback != null) {
					clay_Immediate.push(function() {
						callback(data1);
					});
				}
			} else {
				clay_Log.error("Request status was " + request.status + " / " + request.statusText,{ fileName : "clay/web/WebIO.hx", lineNumber : 102, className : "clay.web.WebIO", methodName : "loadData"});
				if(callback != null) {
					clay_Immediate.push(function() {
						callback(data);
					});
				}
			}
		};
		request.send();
		return null;
	}
});
var clay_web_WebRuntime = function(app) {
	this.touches = new haxe_ds_IntMap();
	this.windowDpr = 1.0;
	this.windowY = 0;
	this.windowX = 0;
	this.skipKeyboardEvents = false;
	this.skipMouseEvents = false;
	this.gamepadsSupported = false;
	clay_base_BaseRuntime.call(this,app);
};
clay_web_WebRuntime.__name__ = true;
clay_web_WebRuntime.timestamp = function() {
	return window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart;
};
clay_web_WebRuntime.defaultConfig = function() {
	return new clay_web_WebConfig("app",window.document.body,true,true,true,[1073741904,1073741903,1073741906,1073741905,8,9,127,32],true);
};
clay_web_WebRuntime.__super__ = clay_base_BaseRuntime;
clay_web_WebRuntime.prototype = $extend(clay_base_BaseRuntime.prototype,{
	init: function() {
		clay_web_WebRuntime.timestampStart = window.performance.now() / 1000.0;
		this.name = "web";
		this.initGamepads();
	}
	,ready: function() {
		this.createWindow();
		clay_Log.debug("Web / ready",{ fileName : "clay/web/WebRuntime.hx", lineNumber : 74, className : "clay.web.WebRuntime", methodName : "ready"});
	}
	,run: function() {
		clay_Log.debug("Web / run",{ fileName : "clay/web/WebRuntime.hx", lineNumber : 80, className : "clay.web.WebRuntime", methodName : "run"});
		this.loop(0);
		return false;
	}
	,loop: function(t) {
		if(t == null) {
			t = 0.016;
		}
		if(this.app.hasShutdown) {
			return false;
		}
		if(this.app.ready) {
			if(this.gamepadsSupported) {
				this.pollGamepads();
			}
			this.updateWindowBounds();
		}
		var newTimestamp = window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart;
		if(this.app.shouldUpdate(newTimestamp)) {
			this.app.emitTick(newTimestamp);
		}
		if(!this.app.shuttingDown) {
			window.requestAnimationFrame($bind(this,this.loop));
		}
		return true;
	}
	,createWindow: function() {
		var config = this.app.config.window;
		this.window = window.document.createElement("canvas");
		this.windowDpr = this.windowDevicePixelRatio();
		this.window.width = Math.floor(config.width * this.windowDpr);
		this.window.height = Math.floor(config.height * this.windowDpr);
		this.windowW = config.width;
		this.windowH = config.height;
		this.window.style.width = config.width + "px";
		this.window.style.height = config.height + "px";
		this.window.style.background = "#000000";
		clay_Log.debug("Web / Created window at " + this.windowX + "," + this.windowY + " - " + this.window.width + "x" + this.window.height + " pixels (" + config.width + "x" + config.height + "@" + this.windowDpr + "x)",{ fileName : "clay/web/WebRuntime.hx", lineNumber : 139, className : "clay.web.WebRuntime", methodName : "createWindow"});
		this.window.id = this.app.config.runtime.windowId;
		this.app.config.runtime.windowParent.appendChild(this.window);
		if(config.title != null) {
			window.document.title = config.title;
		}
		if(!this.createRenderContext(this.window)) {
			this.createRenderContextFailed();
			return;
		}
		this.postRenderContext(this.window);
		this.setupEvents();
	}
	,createRenderContext: function($window) {
		var config = this.app.config.render;
		var attr = this.applyGLAttributes(config);
		var gl = null;
		if(config.webgl.version != 1) {
			gl = $window.getContext("webgl" + config.webgl.version,attr);
			if(gl == null) {
				gl = $window.getContext("experimental-webgl" + config.webgl.version,attr);
			}
		}
		if(gl == null) {
			gl = js_html__$CanvasElement_CanvasUtil.getContextWebGL($window,attr);
		}
		clay_opengl_web_GL.gl = gl;
		clay_Log.debug("GL / context: " + Std.string(gl != null),{ fileName : "clay/web/WebRuntime.hx", lineNumber : 181, className : "clay.web.WebRuntime", methodName : "createRenderContext"});
		return gl != null;
	}
	,createRenderContextFailed: function() {
		var msg = "WebGL is required to run this!<br/><br/>";
		msg += "visit <a style=\"color:#06b4fb; text-decoration:none;\" href=\"http://get.webgl.org/\">get.webgl.com</a> for info<br/>";
		msg += "and contact the developer of this app";
		var textEl = window.document.createElement("div");
		var overlayEl = window.document.createElement("div");
		textEl.style.marginLeft = "auto";
		textEl.style.marginRight = "auto";
		textEl.style.color = "#d3d3d3";
		textEl.style.marginTop = "5em";
		textEl.style.fontSize = "1.4em";
		textEl.style.fontFamily = "Helvetica, sans-serif";
		textEl.innerHTML = msg;
		overlayEl.style.top = "0";
		overlayEl.style.left = "0";
		overlayEl.style.width = "100%";
		overlayEl.style.height = "100%";
		overlayEl.style.display = "block";
		overlayEl.style.minWidth = "100%";
		overlayEl.style.minHeight = "100%";
		overlayEl.style.textAlign = "center";
		overlayEl.style.position = "absolute";
		overlayEl.style.background = "rgba(1,1,1,0.90)";
		overlayEl.appendChild(textEl);
		window.document.body.appendChild(overlayEl);
		throw haxe_Exception.thrown("Web / Failed to create render context");
	}
	,applyGLAttributes: function(config) {
		var attr = { alpha : config.webgl.alpha, antialias : config.webgl.antialias, depth : config.webgl.depth, stencil : config.webgl.stencil, failIfMajorPerformanceCaveat : config.webgl.failIfMajorPerformanceCaveat, premultipliedAlpha : config.webgl.premultipliedAlpha, preserveDrawingBuffer : config.webgl.preserveDrawingBuffer};
		if(config.antialiasing > 0) {
			attr.antialias = true;
		}
		if(config.depth > 0) {
			attr.depth = true;
		}
		if(config.stencil > 0) {
			attr.stencil = true;
		}
		return attr;
	}
	,postRenderContext: function($window) {
		var color = this.app.config.render.defaultClear;
		clay_opengl_web_GL.gl.clearDepth(1.0);
		clay_opengl_web_GL.gl.clearStencil(0);
		clay_opengl_web_GL.gl.clearColor(color.r,color.g,color.b,color.a);
		clay_opengl_web_GL.gl.clear(17664);
	}
	,setupEvents: function() {
		window.document.addEventListener("fullscreenchange",$bind(this,this.handleFullscreenChange));
		window.document.addEventListener("fullscreenerror",$bind(this,this.handleFullscreenError));
		this.window.addEventListener("mouseenter",$bind(this,this.handleMouseEnter));
		this.window.addEventListener("mouseleave",$bind(this,this.handleMouseLeave));
		window.document.addEventListener("visibilitychange",$bind(this,this.handleVisibilityChange));
		window.document.addEventListener("keydown",$bind(this,this.handleKeyDown));
		window.document.addEventListener("keyup",$bind(this,this.handleKeyUp));
		window.document.addEventListener("keypress",$bind(this,this.handleKeyPress));
		this.window.addEventListener("contextmenu",$bind(this,this.handleContextMenu));
		var eventsWindow = this.app.config.runtime.mouseUseBrowserWindowEvents ? window : this.window;
		eventsWindow.addEventListener("mousedown",$bind(this,this.handleMouseDown));
		eventsWindow.addEventListener("mouseup",$bind(this,this.handleMouseUp));
		eventsWindow.addEventListener("mousemove",$bind(this,this.handleMouseMove));
		this.window.addEventListener("wheel",$bind(this,this.handleWheel));
		this.window.addEventListener("touchstart",$bind(this,this.handleTouchStart));
		this.window.addEventListener("touchend",$bind(this,this.handleTouchEnd));
		this.window.addEventListener("touchmove",$bind(this,this.handleTouchMove));
		window.addEventListener("gamepadconnected",$bind(this,this.handleGamepadConnected));
		window.addEventListener("gamepaddisconnected",$bind(this,this.handleGamepadDisconnected));
	}
	,handleVisibilityChange: function(_) {
		if(window.document.hidden) {
			this.app.emitWindowEvent(2,window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart,1,0,0);
			this.app.emitWindowEvent(7,window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart,1,0,0);
			this.app.emitWindowEvent(13,window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart,1,0,0);
		} else {
			this.app.emitWindowEvent(1,window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart,1,0,0);
			this.app.emitWindowEvent(9,window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart,1,0,0);
			this.app.emitWindowEvent(12,window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart,1,0,0);
		}
	}
	,handleContextMenu: function(ev) {
		if(this.app.config.runtime.preventDefaultContextMenu) {
			ev.preventDefault();
		}
	}
	,handleFullscreenChange: function(ev) {
		var document = window.document;
		var fullscreenElement = document.fullscreenElement;
		if(fullscreenElement != null) {
			clay_Log.debug("Web / Entering fullscreen (id=" + fullscreenElement.id + ")",{ fileName : "clay/web/WebRuntime.hx", lineNumber : 345, className : "clay.web.WebRuntime", methodName : "handleFullscreenChange"});
			this.app.config.window.fullscreen = true;
			this.app.emitWindowEvent(15,window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart,1,0,0);
		} else {
			clay_Log.debug("Web / Leaving fullscreen",{ fileName : "clay/web/WebRuntime.hx", lineNumber : 350, className : "clay.web.WebRuntime", methodName : "handleFullscreenChange"});
			this.app.config.window.fullscreen = false;
			this.app.emitWindowEvent(16,window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart,1,0,0);
		}
	}
	,handleFullscreenError: function(ev) {
		clay_Log.warning("Web / Failed to change fullscreen setting: " + Std.string(ev),{ fileName : "clay/web/WebRuntime.hx", lineNumber : 359, className : "clay.web.WebRuntime", methodName : "handleFullscreenError"});
	}
	,handleMouseEnter: function(ev) {
		this.app.emitWindowEvent(10,window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart,1,0,0);
	}
	,handleMouseLeave: function(ev) {
		this.app.emitWindowEvent(11,window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart,1,0,0);
	}
	,handleMouseDown: function(ev) {
		if(this.skipMouseEvents) {
			return;
		}
		var _this = this.app.input;
		var x = Math.floor(this.windowDpr * (ev.pageX - this.windowX));
		var y = Math.floor(this.windowDpr * (ev.pageY - this.windowY));
		var button = ev.button;
		var timestamp = window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart;
		_this.app.events.mouseDown(x,y,button,timestamp,1);
	}
	,handleMouseUp: function(ev) {
		if(this.skipMouseEvents) {
			return;
		}
		var _this = this.app.input;
		var x = Math.floor(this.windowDpr * (ev.pageX - this.windowX));
		var y = Math.floor(this.windowDpr * (ev.pageY - this.windowY));
		var button = ev.button;
		var timestamp = window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart;
		_this.app.events.mouseUp(x,y,button,timestamp,1);
	}
	,handleMouseMove: function(ev) {
		if(this.skipMouseEvents) {
			return;
		}
		var movementX = ev.movementX == null ? 0 : ev.movementX;
		var movementY = ev.movementY == null ? 0 : ev.movementY;
		movementX = Math.floor(movementX * this.windowDpr);
		movementY = Math.floor(movementY * this.windowDpr);
		var _this = this.app.input;
		var x = Math.floor(this.windowDpr * (ev.pageX - this.windowX));
		var y = Math.floor(this.windowDpr * (ev.pageY - this.windowY));
		var timestamp = window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart;
		_this.app.events.mouseMove(x,y,movementX,movementY,timestamp,1);
	}
	,handleWheel: function(ev) {
		if(this.app.config.runtime.preventDefaultMouseWheel) {
			ev.preventDefault();
		}
		if(this.skipMouseEvents) {
			return;
		}
		var wheelFactor = 0.1;
		var _this = this.app.input;
		var x = Math.round(ev.deltaX * wheelFactor);
		var y = Math.round(ev.deltaY * wheelFactor);
		var timestamp = window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart;
		_this.app.events.mouseWheel(x,y,timestamp,1);
	}
	,handleTouchStart: function(ev) {
		if(this.app.config.runtime.preventDefaultTouches) {
			ev.preventDefault();
		}
		var bound = this.window.getBoundingClientRect();
		var _g = 0;
		var _g1 = ev.changedTouches;
		while(_g < _g1.length) {
			var touch = _g1[_g];
			++_g;
			var x = touch.clientX - bound.left;
			var y = touch.clientY - bound.top;
			x /= bound.width;
			y /= bound.height;
			var touchInfo = this.touches.h[touch.identifier];
			if(touchInfo == null) {
				touchInfo = { x : x, y : y};
				this.touches.h[touch.identifier] = touchInfo;
			} else {
				touchInfo.x = x;
				touchInfo.y = y;
			}
			var _this = this.app.input;
			var touchId = touch.identifier;
			var timestamp = window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart;
			_this.app.events.touchDown(x,y,0,0,touchId,timestamp);
		}
	}
	,handleTouchEnd: function(ev) {
		if(this.app.config.runtime.preventDefaultTouches) {
			ev.preventDefault();
		}
		var bound = this.window.getBoundingClientRect();
		var _g = 0;
		var _g1 = ev.changedTouches;
		while(_g < _g1.length) {
			var touch = _g1[_g];
			++_g;
			var x = touch.clientX - bound.left;
			var y = touch.clientY - bound.top;
			x /= bound.width;
			y /= bound.height;
			var touchInfo = this.touches.h[touch.identifier];
			if(touchInfo == null) {
				touchInfo = { x : x, y : y};
				this.touches.h[touch.identifier] = touchInfo;
			}
			var _this = this.app.input;
			var dx = x - touchInfo.x;
			var dy = y - touchInfo.y;
			var touchId = touch.identifier;
			var timestamp = window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart;
			_this.app.events.touchUp(x,y,dx,dy,touchId,timestamp);
			touchInfo.x = x;
			touchInfo.y = y;
		}
	}
	,handleTouchMove: function(ev) {
		if(this.app.config.runtime.preventDefaultTouches) {
			ev.preventDefault();
		}
		var bound = this.window.getBoundingClientRect();
		var _g = 0;
		var _g1 = ev.changedTouches;
		while(_g < _g1.length) {
			var touch = _g1[_g];
			++_g;
			var x = touch.clientX - bound.left;
			var y = touch.clientY - bound.top;
			x /= bound.width;
			y /= bound.height;
			var touchInfo = this.touches.h[touch.identifier];
			if(touchInfo == null) {
				touchInfo = { x : x, y : y};
				this.touches.h[touch.identifier] = touchInfo;
			}
			var _this = this.app.input;
			var dx = x - touchInfo.x;
			var dy = y - touchInfo.y;
			var touchId = touch.identifier;
			var timestamp = window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart;
			_this.app.events.touchMove(x,y,dx,dy,touchId,timestamp);
			touchInfo.x = x;
			touchInfo.y = y;
		}
	}
	,handleKeyDown: function(ev) {
		if(this.skipKeyboardEvents) {
			return;
		}
		var keyCode = this.convertKeyCode(ev.keyCode);
		var scanCode = clay_KeyCode.toScanCode(keyCode);
		var modState = this.modStateFromEvent(ev);
		if(this.app.config.runtime.preventDefaultKeys.indexOf(keyCode) != -1) {
			ev.preventDefault();
		}
		var _this = this.app.input;
		var repeat = ev.repeat;
		var timestamp = window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart;
		_this.app.events.keyDown(keyCode,scanCode,repeat,modState,timestamp,1);
	}
	,handleKeyUp: function(ev) {
		if(this.skipKeyboardEvents) {
			return;
		}
		var keyCode = this.convertKeyCode(ev.keyCode);
		var scanCode = clay_KeyCode.toScanCode(keyCode);
		var modState = this.modStateFromEvent(ev);
		if(this.app.config.runtime.preventDefaultKeys.indexOf(keyCode) != -1) {
			ev.preventDefault();
		}
		var _this = this.app.input;
		var repeat = ev.repeat;
		var timestamp = window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart;
		_this.app.events.keyUp(keyCode,scanCode,repeat,modState,timestamp,1);
	}
	,handleKeyPress: function(ev) {
		if(this.skipKeyboardEvents) {
			return;
		}
		if(ev.which != 0 && ev.keyCode != 8 && ev.keyCode != 13) {
			var code = ev.charCode;
			var text = String.fromCodePoint(code);
			var _this = this.app.input;
			var length = text.length;
			var timestamp = window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart;
			_this.app.events.text(text,0,length,2,timestamp,1);
		}
	}
	,handleGamepadConnected: function(ev) {
		clay_Log.debug("Gamepad connected at index " + ev.gamepad.index + ": " + ev.gamepad.id + ". " + ev.gamepad.buttons.length + " buttons, " + ev.gamepad.axes.length + " axes",{ fileName : "clay/web/WebRuntime.hx", lineNumber : 629, className : "clay.web.WebRuntime", methodName : "handleGamepadConnected"});
		var gamepad = ev.gamepad;
		if(this.gamepadButtonCache[gamepad.index] == null) {
			this.gamepadButtonCache[gamepad.index] = [];
			var _g = 0;
			var _g1 = gamepad.buttons.length;
			while(_g < _g1) {
				var i = _g++;
				this.gamepadButtonCache[gamepad.index].push(0);
			}
			this.gamepadAxisCache[gamepad.index] = [];
			var _g = 0;
			var _g1 = gamepad.axes.length;
			while(_g < _g1) {
				var i = _g++;
				this.gamepadAxisCache[gamepad.index].push(0);
			}
		}
		var _this = this.app.input;
		var gamepad = ev.gamepad.index;
		var name = ev.gamepad.id;
		var timestamp = window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart;
		_this.app.events.gamepadDevice(gamepad,name,1,timestamp);
	}
	,handleGamepadDisconnected: function(ev) {
		clay_Log.debug("Gamepad disconnected at index " + ev.gamepad.index + ": " + ev.gamepad.id,{ fileName : "clay/web/WebRuntime.hx", lineNumber : 644, className : "clay.web.WebRuntime", methodName : "handleGamepadDisconnected"});
		var gamepad = ev.gamepad;
		this.gamepadButtonCache[gamepad.index] = null;
		this.gamepadAxisCache[gamepad.index] = null;
		var _this = this.app.input;
		var gamepad = ev.gamepad.index;
		var name = ev.gamepad.id;
		var timestamp = window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart;
		_this.app.events.gamepadDevice(gamepad,name,2,timestamp);
	}
	,convertKeyCode: function(domKeyCode) {
		if(domKeyCode >= 65 && domKeyCode <= 90) {
			return domKeyCode + 32;
		}
		return clay_web__$WebRuntime_DOMKeys.domKeyToKeyCode(domKeyCode);
	}
	,modStateFromEvent: function(keyEvent) {
		var none = !keyEvent.altKey && !keyEvent.ctrlKey && !keyEvent.metaKey && !keyEvent.shiftKey;
		this.app.input.modState.none = none;
		this.app.input.modState.lshift = keyEvent.shiftKey;
		this.app.input.modState.rshift = keyEvent.shiftKey;
		this.app.input.modState.lctrl = keyEvent.ctrlKey;
		this.app.input.modState.rctrl = keyEvent.ctrlKey;
		this.app.input.modState.lalt = keyEvent.altKey;
		this.app.input.modState.ralt = keyEvent.altKey;
		this.app.input.modState.lmeta = keyEvent.metaKey;
		this.app.input.modState.rmeta = keyEvent.metaKey;
		this.app.input.modState.num = false;
		this.app.input.modState.caps = false;
		this.app.input.modState.mode = false;
		this.app.input.modState.ctrl = keyEvent.ctrlKey;
		this.app.input.modState.shift = keyEvent.shiftKey;
		this.app.input.modState.alt = keyEvent.altKey;
		this.app.input.modState.meta = keyEvent.metaKey;
		return this.app.input.modState;
	}
	,getWindowX: function(bounds) {
		return Math.round(bounds.left + window.pageXOffset - window.document.body.clientTop);
	}
	,getWindowY: function(bounds) {
		return Math.round(bounds.top + window.pageYOffset - window.document.body.clientLeft);
	}
	,translateMouseX: function(ev) {
		return Math.floor(this.windowDpr * (ev.pageX - this.windowX));
	}
	,translateMouseY: function(ev) {
		return Math.floor(this.windowDpr * (ev.pageY - this.windowY));
	}
	,updateWindowBounds: function() {
		var dpr = this.windowDpr;
		this.windowDpr = this.windowDevicePixelRatio();
		var bounds = this.window.getBoundingClientRect();
		var x = Math.round(bounds.left + window.pageXOffset - window.document.body.clientTop);
		var y = Math.round(bounds.top + window.pageYOffset - window.document.body.clientLeft);
		var w = Math.round(bounds.width);
		var h = Math.round(bounds.height);
		if(x != this.windowX || y != this.windowY) {
			this.windowX = x;
			this.windowY = y;
			this.app.emitWindowEvent(4,window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart,1,this.windowX,this.windowY);
		}
		if(w != this.windowW || h != this.windowH || dpr != this.windowDpr) {
			this.windowW = w;
			this.windowH = h;
			this.window.width = Math.floor(this.windowW * this.windowDpr);
			this.window.height = Math.floor(this.windowH * this.windowDpr);
			this.app.emitWindowEvent(6,window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart,1,this.window.width,this.window.height);
		}
	}
	,initGamepads: function() {
		var list = this.getGamepadList();
		if(list != null) {
			this.gamepadsSupported = true;
			this.gamepadButtonCache = [];
			this.gamepadAxisCache = [];
			var _g = 0;
			while(_g < list.length) {
				var gamepad = list[_g];
				++_g;
				if(gamepad != null) {
					if(this.gamepadButtonCache[gamepad.index] == null) {
						this.gamepadButtonCache[gamepad.index] = [];
						var _g1 = 0;
						var _g2 = gamepad.buttons.length;
						while(_g1 < _g2) {
							var i = _g1++;
							this.gamepadButtonCache[gamepad.index].push(0);
						}
						this.gamepadAxisCache[gamepad.index] = [];
						var _g3 = 0;
						var _g4 = gamepad.axes.length;
						while(_g3 < _g4) {
							var i1 = _g3++;
							this.gamepadAxisCache[gamepad.index].push(0);
						}
					}
				}
			}
		} else {
			clay_Log.warning("Gamepads are not supported in this browser :(",{ fileName : "clay/web/WebRuntime.hx", lineNumber : 764, className : "clay.web.WebRuntime", methodName : "initGamepads"});
		}
	}
	,getGamepadList: function() {
		if($global.navigator.getGamepads != null) {
			return $global.navigator.getGamepads();
		}
		if($global.navigator.webkitGetGamepads != null) {
			return $global.navigator.webkitGetGamepads();
		}
		return null;
	}
	,initGamepadCacheIfNeeded: function(gamepad) {
		if(this.gamepadButtonCache[gamepad.index] == null) {
			this.gamepadButtonCache[gamepad.index] = [];
			var _g = 0;
			var _g1 = gamepad.buttons.length;
			while(_g < _g1) {
				var i = _g++;
				this.gamepadButtonCache[gamepad.index].push(0);
			}
			this.gamepadAxisCache[gamepad.index] = [];
			var _g = 0;
			var _g1 = gamepad.axes.length;
			while(_g < _g1) {
				var i = _g++;
				this.gamepadAxisCache[gamepad.index].push(0);
			}
		}
	}
	,deleteGamepadCache: function(gamepad) {
		this.gamepadButtonCache[gamepad.index] = null;
		this.gamepadAxisCache[gamepad.index] = null;
	}
	,pollGamepads: function() {
		var list = this.getGamepadList();
		if(list != null) {
			var len = list.length;
			var index = 0;
			while(index < len) {
				var gamepad = list[index];
				if(gamepad == null) {
					++index;
					continue;
				}
				if(this.gamepadButtonCache[gamepad.index] == null) {
					this.gamepadButtonCache[gamepad.index] = [];
					var _g = 0;
					var _g1 = gamepad.buttons.length;
					while(_g < _g1) {
						var i = _g++;
						this.gamepadButtonCache[gamepad.index].push(0);
					}
					this.gamepadAxisCache[gamepad.index] = [];
					var _g2 = 0;
					var _g3 = gamepad.axes.length;
					while(_g2 < _g3) {
						var i1 = _g2++;
						this.gamepadAxisCache[gamepad.index].push(0);
					}
				}
				var axisCache = this.gamepadAxisCache[gamepad.index];
				var _g4 = 0;
				var _g5 = gamepad.axes.length;
				while(_g4 < _g5) {
					var axisIndex = _g4++;
					var axis = gamepad.axes[axisIndex];
					if(axis != axisCache[axisIndex]) {
						axisCache[axisIndex] = axis;
						var _this = this.app.input;
						var gamepad1 = gamepad.index;
						var timestamp = window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart;
						_this.app.events.gamepadAxis(gamepad1,axisIndex,axis,timestamp);
					}
				}
				var buttonCache = this.gamepadButtonCache[gamepad.index];
				var _g6 = 0;
				var _g7 = gamepad.buttons.length;
				while(_g6 < _g7) {
					var buttonIndex = _g6++;
					var button = gamepad.buttons[buttonIndex];
					if(button.value != buttonCache[buttonIndex]) {
						buttonCache[buttonIndex] = button.value;
						if(button.pressed) {
							var _this1 = this.app.input;
							var gamepad2 = gamepad.index;
							var value = button.value;
							var timestamp1 = window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart;
							_this1.app.events.gamepadDown(gamepad2,buttonIndex,value,timestamp1);
						} else {
							var _this2 = this.app.input;
							var gamepad3 = gamepad.index;
							var value1 = button.value;
							var timestamp2 = window.performance.now() / 1000.0 - clay_web_WebRuntime.timestampStart;
							_this2.app.events.gamepadUp(gamepad3,buttonIndex,value1,timestamp2);
						}
					}
				}
				++index;
			}
		}
	}
	,windowDevicePixelRatio: function() {
		if(window.devicePixelRatio == null) {
			return 1.0;
		} else {
			return window.devicePixelRatio;
		}
	}
	,windowWidth: function() {
		return Math.round(this.windowW * this.windowDevicePixelRatio());
	}
	,windowHeight: function() {
		return Math.round(this.windowH * this.windowDevicePixelRatio());
	}
	,setWindowFullscreen: function(fullscreen) {
		if(fullscreen) {
			this.window.requestFullscreen();
		} else {
			window.document.exitFullscreen();
		}
		return true;
	}
	,setWindowTitle: function(title) {
		this.app.config.window.title = title;
		window.document.title = title;
	}
});
var clay_web__$WebRuntime_DOMKeys = function() { };
clay_web__$WebRuntime_DOMKeys.__name__ = true;
clay_web__$WebRuntime_DOMKeys.domKeyToKeyCode = function(keyCode) {
	switch(keyCode) {
	case 16:
		return 1073742049;
	case 17:
		return 1073742048;
	case 18:
		return 1073742050;
	case 20:
		return 1073741881;
	case 33:
		return 1073741899;
	case 34:
		return 1073741902;
	case 35:
		return 1073741901;
	case 36:
		return 1073741898;
	case 37:
		return 1073741904;
	case 38:
		return 1073741906;
	case 39:
		return 1073741903;
	case 40:
		return 1073741905;
	case 44:
		return 1073741894;
	case 45:
		return 1073741897;
	case 46:
		return 127;
	case 91:
		return 1073742051;
	case 93:
		return 1073742055;
	case 96:
		return 1073741922;
	case 97:
		return 1073741913;
	case 98:
		return 1073741914;
	case 99:
		return 1073741915;
	case 100:
		return 1073741916;
	case 101:
		return 1073741917;
	case 102:
		return 1073741918;
	case 103:
		return 1073741919;
	case 104:
		return 1073741920;
	case 105:
		return 1073741921;
	case 106:
		return 1073741909;
	case 107:
		return 1073741911;
	case 109:
		return 1073741910;
	case 110:
		return 1073742044;
	case 111:
		return 1073741908;
	case 112:
		return 1073741882;
	case 113:
		return 1073741883;
	case 114:
		return 1073741884;
	case 115:
		return 1073741885;
	case 116:
		return 1073741886;
	case 117:
		return 1073741887;
	case 118:
		return 1073741888;
	case 119:
		return 1073741889;
	case 120:
		return 1073741890;
	case 121:
		return 1073741891;
	case 122:
		return 1073741892;
	case 123:
		return 1073741893;
	case 124:
		return 1073741928;
	case 125:
		return 1073741929;
	case 126:
		return 1073741930;
	case 127:
		return 1073741931;
	case 128:
		return 1073741932;
	case 129:
		return 1073741933;
	case 130:
		return 1073741934;
	case 131:
		return 1073741935;
	case 132:
		return 1073741936;
	case 133:
		return 1073741937;
	case 134:
		return 1073741938;
	case 135:
		return 1073741939;
	case 144:
		return 1073741907;
	case 160:
		return 94;
	case 161:
		return 33;
	case 162:
		return 34;
	case 163:
		return 35;
	case 164:
		return 36;
	case 165:
		return 37;
	case 166:
		return 38;
	case 167:
		return 95;
	case 168:
		return 40;
	case 169:
		return 41;
	case 170:
		return 42;
	case 171:
		return 43;
	case 172:
		return 92;
	case 173:
		return 45;
	case 174:
		return 91;
	case 175:
		return 93;
	case 176:
		return 96;
	case 181:
		return 1073742086;
	case 182:
		return 1073741953;
	case 183:
		return 1073741952;
	case 188:
		return 44;
	case 190:
		return 46;
	case 191:
		return 47;
	case 192:
		return 96;
	case 219:
		return 91;
	case 220:
		return 92;
	case 221:
		return 93;
	case 222:
		return 39;
	case 224:
		return 1073742051;
	}
	return keyCode;
};
var cornerContour_Contour = function(pen_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.counter = 0;
	this.count = 0;
	this.endCapFactor = 0.5;
	this.pointsAnti = [];
	this.pointsClock = [];
	this.debugCol12 = -893376;
	this.debugCol11 = -3986796;
	this.debugCol10 = -9230154;
	this.debugCol9 = -13354819;
	this.debugCol8 = -12617788;
	this.debugCol7 = -11686193;
	this.debugCol6 = -11288539;
	this.debugCol5 = -5778134;
	this.debugCol4 = -211;
	this.debugCol3 = -338891;
	this.debugCol2 = -742865;
	this.debugCol1 = -884166;
	this.debugCol0 = -1098686;
	this.pen = pen_;
	this.endLine = endLine_;
};
cornerContour_Contour.__name__ = true;
cornerContour_Contour.thetaCompute = function(px,py,qx,qy) {
	return Math.atan2(py - qy,px - qx);
};
cornerContour_Contour.dist = function(px,py,qx,qy) {
	var x = px - qx;
	var y = py - qy;
	return x * x + y * y;
};
cornerContour_Contour.prototype = {
	reset: function() {
		this.angleA = 0;
		this.count = 0;
		this.kax = 0;
		this.kay = 0;
		this.kbx = 0;
		this.kby = 0;
		this.kcx = 0;
		this.kcy = 0;
		this.ncx = 0;
		this.ncy = 0;
		this.ax = 0;
		this.ay = 0;
		this.bx = 0;
		this.by = 0;
		this.cx = 0;
		this.cy = 0;
		this.dx = null;
		this.dy = null;
		this.ex = null;
		this.ey = null;
		this.pointsClock.length = 0;
		this.pointsAnti.length = 0;
	}
	,computeDE: function() {
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
	}
	,anglesCompute: function() {
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
	}
	,thetaComputeAdj: function(qx,qy) {
		return -Math.atan2(this.ay - qy,this.ax - qx) - Math.PI / 2;
	}
	,triangleJoin: function(ax_,ay_,bx_,by_,width_,curveEnds,overlap) {
		if(overlap == null) {
			overlap = false;
		}
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = this.dx != null ? this.angle1 : null;
		this.halfA = Math.PI / 2;
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var x = this.dxOld - bx_;
		var y = this.dyOld - by_;
		var x1 = this.exOld - bx_;
		var y1 = this.eyOld - by_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(this.ay - this.dyOld,this.ax - this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.eyPrev,this.ax - this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(this.ay - this.eyOld,this.ax - this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.dyPrev,this.ax - this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = theta0;
			var fb = theta1;
			var theta = Math.abs(theta0 - theta1);
			var smallest = theta <= Math.PI;
			var clockwise = theta0 < theta1;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(!overlap && this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			this.jx = this.ax + h * Math.sin(delta);
			this.jy = this.ay + h * Math.cos(delta);
		}
		if(this.count == 0 && (this.endLine == 1 || this.endLine == 3 || this.endLine == 6 || this.endLine == 8 || this.endLine == 11 || this.endLine == 9 || this.endLine == 15 || this.endLine == 17 || this.endLine == 12 || this.endLine == 14 || this.endLine == 18 || this.endLine == 20)) {
			var ax = this.ax;
			var ay = this.ay;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			this.startShape(ax,ay,width_ / 2,beta,gamma,fracs_DifferencePreference.SMALL_OLD,temp,-1,36);
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[i * 2 + len + 1];
				this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(this.count == 0 && (this.endLine == 4 || this.endLine == 5)) {
			var ax = this.ax;
			var ay = this.ay;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI / 2;
			var temp = [];
			this.startShape(ax,ay,width_ / 2,beta,gamma,fracs_DifferencePreference.SMALL_OLD,temp,-1,36);
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[i * 2 + len + 1];
				this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(overlap) {
			this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
			this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
		} else {
			if(this.count != 0) {
				this.addQuads(clockWise,width_);
			}
			this.quadIndex = this.pen.get_pos();
			if(this.count == 0) {
				this.penultimateAX = this.dxPrev;
				this.penultimateAY = this.dyPrev;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.exPrev;
				this.lastClockY = this.eyPrev;
				this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
				this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
			} else {
				if(clockWise && !this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
				}
				if(clockWise && this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
				}
				if(!clockWise && !this.lastClock) {
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.jx;
					this.lastClockY = this.jy;
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.jx,this.jy,-1);
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
				}
				if(!clockWise && this.lastClock) {
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.jx;
					this.penultimateCY = this.jy;
					this.lastClockX = this.dx;
					this.lastClockY = this.dy;
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.jx,this.jy,this.ex,this.ey,-1);
				}
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var radius = width_ / 2;
				var edgePoly = this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx = 0.;
				var cy = 0.;
				var bx = 0.;
				var by = 0.;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color_ = -1;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
					}
					angle += step;
					bx = cx;
					by = cy;
				}
			} else {
				var radius = width_ / 2;
				var edgePoly = this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx = 0.;
				var cy = 0.;
				var bx = 0.;
				var by = 0.;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color_ = -1;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
					}
					angle += step;
					bx = cx;
					by = cy;
				}
			}
		} else if(this.count != 0) {
			if(overlap) {
				if(clockWise) {
					this.pen.triangle2DFill(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.ax,this.ay,-1);
				} else {
					this.pen.triangle2DFill(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.ax,this.ay,-1);
				}
			} else if(clockWise) {
				this.pen.triangle2DFill(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.jx,this.jy,-1);
			} else {
				this.pen.triangle2DFill(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.jx,this.jy,-1);
			}
		}
		this.kax = this.dxPrev;
		this.kay = this.dyPrev;
		this.kbx = this.dx;
		this.kby = this.dy;
		this.ncx = this.exPrev;
		this.ncy = this.eyPrev;
		this.kcx = this.ex;
		this.kcy = this.ey;
		if(curveEnds && !overlap && this.count != 0) {
			if(clockWise) {
				this.pen.triangle2DFill(this.ax,this.ay,this.dxOld,this.dyOld,this.jx,this.jy,-1);
				this.pen.triangle2DFill(this.ax,this.ay,this.exPrev,this.eyPrev,this.jx,this.jy,-1);
			} else {
				this.pen.triangle2DFill(this.ax,this.ay,this.exOld,this.eyOld,this.jx,this.jy,-1);
				this.pen.triangle2DFill(this.ax,this.ay,this.dxPrev,this.dyPrev,this.jx,this.jy,-1);
			}
		}
		this.jxOld = this.jx;
		this.jyOld = this.jy;
		this.lastClock = clockWise;
		this.count++;
	}
	,overlapQuad: function() {
		this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
		this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
	}
	,end: function(width_) {
		this.endEdges();
		if(this.count != 0 && (this.endLine == 2 || this.endLine == 3 || this.endLine == 7 || this.endLine == 8 || this.endLine == 11 || this.endLine == 10 || this.endLine == 16 || this.endLine == 17 || this.endLine == 13 || this.endLine == 14 || this.endLine == 19 || this.endLine == 20)) {
			var ax = this.bx;
			var ay = this.by;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var temp = [];
			var ax1 = ax;
			var ay1 = ay;
			var radius = width_ / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL_OLD._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var beta2 = 0.;
			var this1 = this.endLine;
			if(this1 == 19 || this1 == 20) {
				angle = Math.PI / 2;
				beta2 = 2 * Math.PI - beta + Math.PI / 2;
			}
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var p2 = temp.length;
			var ex = 0.;
			var ey = 0.;
			var fx = 0.;
			var fy = 0.;
			var gx = 0.;
			var gy = 0.;
			var delta = 0.;
			var this1 = this.endLine;
			if(this1 == 13 || this1 == 14) {
				var angle2 = beta - step * totalSteps / 2;
				fx = ax1 - 0.75 * this.endCapFactor * radius * Math.sin(angle2);
				fy = ay1 - 0.75 * this.endCapFactor * radius * Math.cos(angle2);
				radius *= 2;
				delta = Math.pow(radius / 2,2);
			}
			var ddx = ax1 + radius * Math.sin(angle);
			var ddy = ay1 + radius * Math.cos(angle);
			var this1 = this.endLine;
			if(!(this1 == 7 || this1 == 8 || (this1 == 10 || this1 == 11) || (this1 == 16 || this1 == 17))) {
				if(this.endLine == 5) {
					var angle2 = beta - 2 * step * totalSteps;
					ax1 += radius * Math.sin(angle2);
					ay1 += radius * Math.cos(angle2);
					radius *= 2;
				}
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					var this1 = this.endLine;
					if(this1 == 13 || this1 == 14) {
						cx = fx + 0.5 * this.endCapFactor * radius * Math.sin(angle);
						cy = fy + 0.5 * this.endCapFactor * radius * Math.cos(angle);
						ex = fx - 0.5 * this.endCapFactor * radius * Math.sin(angle);
						ey = fy - 0.5 * this.endCapFactor * radius * Math.cos(angle);
					} else {
						var this2 = this.endLine;
						if(this2 == 19 || this2 == 20) {
							var ry = this.endCapFactor * radius;
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + ry * Math.cos(angle);
							var cos = Math.cos(beta2);
							var sin = Math.sin(beta2);
							cx -= ax1;
							cy -= ay1;
							var ccx = cx;
							var ccy = cy;
							cx = ccx * cos - ccy * sin;
							cy = ccx * sin + ccy * cos;
							cx += ax1;
							cy += ay1;
						} else {
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + radius * Math.cos(angle);
						}
					}
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
						var this3 = this.endLine;
						if(this3 == 13 || this3 == 14) {
							var deltaG = Math.pow(ay1 - gy,2) + Math.pow(ax1 - gx,2);
							var deltaE = Math.pow(ay1 - ey,2) + Math.pow(ax1 - ex,2);
							if(deltaE > delta || deltaG > delta) {
								var color_1 = color;
								if(color_1 == null) {
									color_1 = -1;
								}
								this.pen.triangle2DFill(ax1,ay1,gx,gy,ex,ey,color_1);
							}
						}
					}
					angle += step;
					bx = cx;
					by = cy;
					var this4 = this.endLine;
					if(this4 == 13 || this4 == 14) {
						gx = ex;
						gy = ey;
					}
				}
				if(this.endLine == 4) {
					angle = angle + step * totalSteps / 2 - step;
					cx = ax1 + radius * Math.sin(angle) * Math.sqrt(2);
					cy = ay1 + radius * Math.cos(angle) * Math.sqrt(2);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					bx = cx;
					by = cy;
					angle += step * (totalSteps / 2);
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					totalSteps += 2;
				}
			} else {
				if(this.endLine == 11 || this.endLine == 10) {
					angle = beta;
					var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ddx,ddy,cx,cy,ax1,ay1,color_);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 + radius * this.endCapFactor * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
				} else {
					var this1 = this.endLine;
					if(this1 == 7 || this1 == 8) {
						angle = beta;
						var dx = ax1 - radius * Math.sin(angle);
						var dy = ay1 - radius * Math.cos(angle);
						angle = beta - step * totalSteps / 2;
						cx = ax1 - radius * Math.sin(angle);
						cy = ay1 - radius * Math.cos(angle);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ddx,ddy,cx,cy,ax1,ay1,color_);
						bx = cx;
						by = cy;
						angle += step * totalSteps / 2;
						cx = ax1 + radius * Math.sin(angle);
						cy = ay1 + radius * Math.cos(angle);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					} else {
						var this1 = this.endLine;
						if(this1 == 16 || this1 == 17) {
							angle = beta;
							var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
							var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
							angle = beta - step * totalSteps / 2;
							cx = dx - 2 * radius * this.endCapFactor * Math.sin(angle);
							cy = dy - 2 * radius * this.endCapFactor * Math.cos(angle);
							var lastAngle = angle;
							angle += step * totalSteps / 2;
							ex = ax1 + radius * this.endCapFactor * Math.sin(angle);
							ey = ay1 + radius * this.endCapFactor * Math.cos(angle);
							fx = ex - 2 * radius * this.endCapFactor * Math.sin(lastAngle);
							fy = ey - 2 * radius * this.endCapFactor * Math.cos(lastAngle);
							var color_ = color;
							if(color_ == null) {
								color_ = -1;
							}
							this.pen.triangle2DFill(fx,fy,cx,cy,ddx,ddy,color_);
							var color_ = color;
							if(color_ == null) {
								color_ = -1;
							}
							this.pen.triangle2DFill(fx,fy,ddx,ddy,ex,ey,color_);
						}
					}
				}
				totalSteps += 2;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var _g = 0;
			var _g1 = len + 2;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[i];
			}
			var pC = this.pointsClock.length;
			var _g = 1;
			var _g1 = len / 2 + 1 | 0;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[temp.length - 2 * i];
				this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
			}
		}
		if(this.count != 0 && (this.endLine == 4 || this.endLine == 5)) {
			var ax = this.bx;
			var ay = this.by;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI / 2;
			var temp = [];
			var ax1 = ax;
			var ay1 = ay;
			var radius = width_ / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL_OLD._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var beta2 = 0.;
			var this1 = this.endLine;
			if(this1 == 19 || this1 == 20) {
				angle = Math.PI / 2;
				beta2 = 2 * Math.PI - beta + Math.PI / 2;
			}
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var p2 = temp.length;
			var ex = 0.;
			var ey = 0.;
			var fx = 0.;
			var fy = 0.;
			var gx = 0.;
			var gy = 0.;
			var delta = 0.;
			var this1 = this.endLine;
			if(this1 == 13 || this1 == 14) {
				var angle2 = beta - step * totalSteps / 2;
				fx = ax1 - 0.75 * this.endCapFactor * radius * Math.sin(angle2);
				fy = ay1 - 0.75 * this.endCapFactor * radius * Math.cos(angle2);
				radius *= 2;
				delta = Math.pow(radius / 2,2);
			}
			var ddx = ax1 + radius * Math.sin(angle);
			var ddy = ay1 + radius * Math.cos(angle);
			var this1 = this.endLine;
			if(!(this1 == 7 || this1 == 8 || (this1 == 10 || this1 == 11) || (this1 == 16 || this1 == 17))) {
				if(this.endLine == 5) {
					var angle2 = beta - 2 * step * totalSteps;
					ax1 += radius * Math.sin(angle2);
					ay1 += radius * Math.cos(angle2);
					radius *= 2;
				}
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					var this1 = this.endLine;
					if(this1 == 13 || this1 == 14) {
						cx = fx + 0.5 * this.endCapFactor * radius * Math.sin(angle);
						cy = fy + 0.5 * this.endCapFactor * radius * Math.cos(angle);
						ex = fx - 0.5 * this.endCapFactor * radius * Math.sin(angle);
						ey = fy - 0.5 * this.endCapFactor * radius * Math.cos(angle);
					} else {
						var this2 = this.endLine;
						if(this2 == 19 || this2 == 20) {
							var ry = this.endCapFactor * radius;
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + ry * Math.cos(angle);
							var cos = Math.cos(beta2);
							var sin = Math.sin(beta2);
							cx -= ax1;
							cy -= ay1;
							var ccx = cx;
							var ccy = cy;
							cx = ccx * cos - ccy * sin;
							cy = ccx * sin + ccy * cos;
							cx += ax1;
							cy += ay1;
						} else {
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + radius * Math.cos(angle);
						}
					}
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
						var this3 = this.endLine;
						if(this3 == 13 || this3 == 14) {
							var deltaG = Math.pow(ay1 - gy,2) + Math.pow(ax1 - gx,2);
							var deltaE = Math.pow(ay1 - ey,2) + Math.pow(ax1 - ex,2);
							if(deltaE > delta || deltaG > delta) {
								var color_1 = color;
								if(color_1 == null) {
									color_1 = -1;
								}
								this.pen.triangle2DFill(ax1,ay1,gx,gy,ex,ey,color_1);
							}
						}
					}
					angle += step;
					bx = cx;
					by = cy;
					var this4 = this.endLine;
					if(this4 == 13 || this4 == 14) {
						gx = ex;
						gy = ey;
					}
				}
				if(this.endLine == 4) {
					angle = angle + step * totalSteps / 2 - step;
					cx = ax1 + radius * Math.sin(angle) * Math.sqrt(2);
					cy = ay1 + radius * Math.cos(angle) * Math.sqrt(2);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					bx = cx;
					by = cy;
					angle += step * (totalSteps / 2);
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					totalSteps += 2;
				}
			} else {
				if(this.endLine == 11 || this.endLine == 10) {
					angle = beta;
					var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ddx,ddy,cx,cy,ax1,ay1,color_);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 + radius * this.endCapFactor * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
				} else {
					var this1 = this.endLine;
					if(this1 == 7 || this1 == 8) {
						angle = beta;
						var dx = ax1 - radius * Math.sin(angle);
						var dy = ay1 - radius * Math.cos(angle);
						angle = beta - step * totalSteps / 2;
						cx = ax1 - radius * Math.sin(angle);
						cy = ay1 - radius * Math.cos(angle);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ddx,ddy,cx,cy,ax1,ay1,color_);
						bx = cx;
						by = cy;
						angle += step * totalSteps / 2;
						cx = ax1 + radius * Math.sin(angle);
						cy = ay1 + radius * Math.cos(angle);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					} else {
						var this1 = this.endLine;
						if(this1 == 16 || this1 == 17) {
							angle = beta;
							var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
							var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
							angle = beta - step * totalSteps / 2;
							cx = dx - 2 * radius * this.endCapFactor * Math.sin(angle);
							cy = dy - 2 * radius * this.endCapFactor * Math.cos(angle);
							var lastAngle = angle;
							angle += step * totalSteps / 2;
							ex = ax1 + radius * this.endCapFactor * Math.sin(angle);
							ey = ay1 + radius * this.endCapFactor * Math.cos(angle);
							fx = ex - 2 * radius * this.endCapFactor * Math.sin(lastAngle);
							fy = ey - 2 * radius * this.endCapFactor * Math.cos(lastAngle);
							var color_ = color;
							if(color_ == null) {
								color_ = -1;
							}
							this.pen.triangle2DFill(fx,fy,cx,cy,ddx,ddy,color_);
							var color_ = color;
							if(color_ == null) {
								color_ = -1;
							}
							this.pen.triangle2DFill(fx,fy,ddx,ddy,ex,ey,color_);
						}
					}
				}
				totalSteps += 2;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var _g = 0;
			var _g1 = len + 2;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[i];
			}
			var pC = this.pointsClock.length;
			var _g = 1;
			var _g1 = len / 2 + 1 | 0;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[temp.length - 2 * i];
				this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
			}
		}
	}
	,triangle2DFill: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		this.pen.triangle2DFill(ax_,ay_,bx_,by_,cx_,cy_,color_);
	}
	,addStartShape: function(ax,ay,radius,beta,gamma,prefer,mark,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(mark == null) {
			mark = -1;
		}
		var temp = [];
		this.startShape(ax,ay,radius,beta,gamma,prefer,temp,mark,sides);
		var pA = this.pointsAnti.length;
		var len = temp.length / 2 | 0;
		var p4 = temp.length / 4 | 0;
		var _g = 0;
		var _g1 = p4;
		while(_g < _g1) {
			var i = _g++;
			this.pointsAnti[pA++] = temp[len - 2 * i + 1];
			this.pointsAnti[pA++] = temp[len - 2 * i];
		}
		var pC = this.pointsClock.length;
		var _g = 0;
		var _g1 = p4;
		while(_g < _g1) {
			var i = _g++;
			this.pointsClock[pC++] = temp[i * 2 + len + 1];
			this.pointsClock[pC++] = temp[i * 2 + len];
		}
	}
	,addEndShape: function(ax,ay,radius,beta,gamma,prefer,mark,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(mark == null) {
			mark = -1;
		}
		var temp = [];
		var ax1 = ax;
		var ay1 = ay;
		var radius1 = radius;
		var color = mark;
		var sides1 = sides;
		if(sides1 == null) {
			sides1 = 36;
		}
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var step = pi * 2 / sides1;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var smallest = theta <= Math.PI;
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step = dif / totalSteps;
		var angle = beta;
		var beta2 = 0.;
		var this1 = this.endLine;
		if(this1 == 19 || this1 == 20) {
			angle = Math.PI / 2;
			beta2 = 2 * Math.PI - beta + Math.PI / 2;
		}
		var cx = 0.;
		var cy = 0.;
		var bx = 0.;
		var by = 0.;
		var p2 = temp.length;
		var ex = 0.;
		var ey = 0.;
		var fx = 0.;
		var fy = 0.;
		var gx = 0.;
		var gy = 0.;
		var delta = 0.;
		var this1 = this.endLine;
		if(this1 == 13 || this1 == 14) {
			var angle2 = beta - step * totalSteps / 2;
			fx = ax1 - 0.75 * this.endCapFactor * radius1 * Math.sin(angle2);
			fy = ay1 - 0.75 * this.endCapFactor * radius1 * Math.cos(angle2);
			radius1 *= 2;
			delta = Math.pow(radius1 / 2,2);
		}
		var ddx = ax1 + radius1 * Math.sin(angle);
		var ddy = ay1 + radius1 * Math.cos(angle);
		var this1 = this.endLine;
		if(!(this1 == 7 || this1 == 8 || (this1 == 10 || this1 == 11) || (this1 == 16 || this1 == 17))) {
			if(this.endLine == 5) {
				var angle2 = beta - 2 * step * totalSteps;
				ax1 += radius1 * Math.sin(angle2);
				ay1 += radius1 * Math.cos(angle2);
				radius1 *= 2;
			}
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				var this1 = this.endLine;
				if(this1 == 13 || this1 == 14) {
					cx = fx + 0.5 * this.endCapFactor * radius1 * Math.sin(angle);
					cy = fy + 0.5 * this.endCapFactor * radius1 * Math.cos(angle);
					ex = fx - 0.5 * this.endCapFactor * radius1 * Math.sin(angle);
					ey = fy - 0.5 * this.endCapFactor * radius1 * Math.cos(angle);
				} else {
					var this2 = this.endLine;
					if(this2 == 19 || this2 == 20) {
						var ry = this.endCapFactor * radius1;
						cx = ax1 + radius1 * Math.sin(angle);
						cy = ay1 + ry * Math.cos(angle);
						var cos = Math.cos(beta2);
						var sin = Math.sin(beta2);
						cx -= ax1;
						cy -= ay1;
						var ccx = cx;
						var ccy = cy;
						cx = ccx * cos - ccy * sin;
						cy = ccx * sin + ccy * cos;
						cx += ax1;
						cy += ay1;
					} else {
						cx = ax1 + radius1 * Math.sin(angle);
						cy = ay1 + radius1 * Math.cos(angle);
					}
				}
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					var this3 = this.endLine;
					if(this3 == 13 || this3 == 14) {
						var deltaG = Math.pow(ay1 - gy,2) + Math.pow(ax1 - gx,2);
						var deltaE = Math.pow(ay1 - ey,2) + Math.pow(ax1 - ex,2);
						if(deltaE > delta || deltaG > delta) {
							var color_1 = color;
							if(color_1 == null) {
								color_1 = -1;
							}
							this.pen.triangle2DFill(ax1,ay1,gx,gy,ex,ey,color_1);
						}
					}
				}
				angle += step;
				bx = cx;
				by = cy;
				var this4 = this.endLine;
				if(this4 == 13 || this4 == 14) {
					gx = ex;
					gy = ey;
				}
			}
			if(this.endLine == 4) {
				angle = angle + step * totalSteps / 2 - step;
				cx = ax1 + radius1 * Math.sin(angle) * Math.sqrt(2);
				cy = ay1 + radius1 * Math.cos(angle) * Math.sqrt(2);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
				bx = cx;
				by = cy;
				angle += step * (totalSteps / 2);
				cx = ax1 + radius1 * Math.sin(angle);
				cy = ay1 + radius1 * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
				totalSteps += 2;
			}
		} else {
			if(this.endLine == 11 || this.endLine == 10) {
				angle = beta;
				var dx = ax1 - radius1 * this.endCapFactor * Math.sin(angle);
				var dy = ay1 - radius1 * this.endCapFactor * Math.cos(angle);
				angle = beta - step * totalSteps / 2;
				cx = ax1 - radius1 * this.endCapFactor * Math.sin(angle);
				cy = ay1 - radius1 * this.endCapFactor * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ddx,ddy,cx,cy,ax1,ay1,color_);
				bx = cx;
				by = cy;
				angle += step * totalSteps / 2;
				cx = ax1 + radius1 * this.endCapFactor * Math.sin(angle);
				cy = ay1 + radius1 * this.endCapFactor * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
			} else {
				var this1 = this.endLine;
				if(this1 == 7 || this1 == 8) {
					angle = beta;
					var dx = ax1 - radius1 * Math.sin(angle);
					var dy = ay1 - radius1 * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius1 * Math.sin(angle);
					cy = ay1 - radius1 * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ddx,ddy,cx,cy,ax1,ay1,color_);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius1 * Math.sin(angle);
					cy = ay1 + radius1 * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
				} else {
					var this1 = this.endLine;
					if(this1 == 16 || this1 == 17) {
						angle = beta;
						var dx = ax1 - radius1 * this.endCapFactor * Math.sin(angle);
						var dy = ay1 - radius1 * this.endCapFactor * Math.cos(angle);
						angle = beta - step * totalSteps / 2;
						cx = dx - 2 * radius1 * this.endCapFactor * Math.sin(angle);
						cy = dy - 2 * radius1 * this.endCapFactor * Math.cos(angle);
						var lastAngle = angle;
						angle += step * totalSteps / 2;
						ex = ax1 + radius1 * this.endCapFactor * Math.sin(angle);
						ey = ay1 + radius1 * this.endCapFactor * Math.cos(angle);
						fx = ex - 2 * radius1 * this.endCapFactor * Math.sin(lastAngle);
						fy = ey - 2 * radius1 * this.endCapFactor * Math.cos(lastAngle);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(fx,fy,cx,cy,ddx,ddy,color_);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(fx,fy,ddx,ddy,ex,ey,color_);
					}
				}
			}
			totalSteps += 2;
		}
		var pA = this.pointsAnti.length;
		var len = temp.length / 2 | 0;
		var _g = 0;
		var _g1 = len + 2;
		while(_g < _g1) {
			var i = _g++;
			this.pointsAnti[pA++] = temp[i];
		}
		var pC = this.pointsClock.length;
		var _g = 1;
		var _g1 = len / 2 + 1 | 0;
		while(_g < _g1) {
			var i = _g++;
			this.pointsClock[pC++] = temp[temp.length - 2 * i];
			this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
		}
	}
	,addPie: function(ax,ay,radius,beta,gamma,prefer,mark,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(mark == null) {
			mark = -1;
		}
		var color = mark;
		var sides1 = sides;
		if(sides1 == null) {
			sides1 = 36;
		}
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var step = pi * 2 / sides1;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var smallest = theta <= Math.PI;
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step = dif / totalSteps;
		var angle = beta;
		var cx = 0.;
		var cy = 0.;
		var bx = 0.;
		var by = 0.;
		var dx = ax + radius * Math.sin(angle);
		var dy = ay + radius * Math.cos(angle);
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx = ax + radius * Math.sin(angle);
			cy = ay + radius * Math.cos(angle);
			if(i != 0) {
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
			}
			angle += step;
			bx = cx;
			by = cy;
		}
	}
	,computeJ: function(width_,theta0,dif) {
		var gamma = Math.abs(dif) / 2;
		var h = width_ / 2 / Math.cos(gamma);
		var f;
		if(theta0 <= Math.PI && theta0 > -Math.PI) {
			f = theta0;
		} else {
			var a = (theta0 + Math.PI) % (2 * Math.PI);
			f = a >= 0 ? a - Math.PI : a + Math.PI;
		}
		var this1 = f;
		var start = this1;
		var start2 = start;
		var delta = start2 + dif / 2 + Math.PI;
		this.jx = this.ax + h * Math.sin(delta);
		this.jy = this.ay + h * Math.cos(delta);
	}
	,addDot: function(x,y,color,width_) {
		var w = width_ * 0.07;
		var color1 = color;
		if(color1 == null) {
			color1 = -1;
		}
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = x + w * Math.sin(theta);
			by = y + w * Math.cos(theta);
			theta += step;
			cx = x + w * Math.sin(theta);
			cy = y + w * Math.cos(theta);
			var color_ = color1;
			if(color_ == null) {
				color_ = -1;
			}
			this.pen.triangle2DFill(x,y,bx,by,cx,cy,color_);
		}
	}
	,addSmallTriangles: function(clockWise,width_) {
		if(clockWise) {
			this.pen.triangle2DFill(this.ax,this.ay,this.dxOld,this.dyOld,this.jx,this.jy,-1);
			this.pen.triangle2DFill(this.ax,this.ay,this.exPrev,this.eyPrev,this.jx,this.jy,-1);
		} else {
			this.pen.triangle2DFill(this.ax,this.ay,this.exOld,this.eyOld,this.jx,this.jy,-1);
			this.pen.triangle2DFill(this.ax,this.ay,this.dxPrev,this.dyPrev,this.jx,this.jy,-1);
		}
	}
	,triangle2DFillangleCorners: function(oldx_,oldy_,prevx_,prevy_,width_) {
		var w = width_ * 0.07;
		var color = this.debugCol4;
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = oldx_ + w * Math.sin(theta);
			by = oldy_ + w * Math.cos(theta);
			theta += step;
			cx = oldx_ + w * Math.sin(theta);
			cy = oldy_ + w * Math.cos(theta);
			var color_ = color;
			if(color_ == null) {
				color_ = -1;
			}
			this.pen.triangle2DFill(oldx_,oldy_,bx,by,cx,cy,color_);
		}
		var color = this.debugCol3;
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = prevx_ + w * Math.sin(theta);
			by = prevy_ + w * Math.cos(theta);
			theta += step;
			cx = prevx_ + w * Math.sin(theta);
			cy = prevy_ + w * Math.cos(theta);
			var color_ = color;
			if(color_ == null) {
				color_ = -1;
			}
			this.pen.triangle2DFill(prevx_,prevy_,bx,by,cx,cy,color_);
		}
		var ax = this.ax;
		var ay = this.ay;
		var color = this.debugCol10;
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = ax + w * Math.sin(theta);
			by = ay + w * Math.cos(theta);
			theta += step;
			cx = ax + w * Math.sin(theta);
			cy = ay + w * Math.cos(theta);
			var color_ = color;
			if(color_ == null) {
				color_ = -1;
			}
			this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
		}
		var ax = this.jx;
		var ay = this.jy;
		var color = this.debugCol5;
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = ax + w * Math.sin(theta);
			by = ay + w * Math.cos(theta);
			theta += step;
			cx = ax + w * Math.sin(theta);
			cy = ay + w * Math.cos(theta);
			var color_ = color;
			if(color_ == null) {
				color_ = -1;
			}
			this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
		}
	}
	,triangle2DFillangleCornersLess: function(oldx_,oldy_,prevx_,prevy_,width_) {
		var w = width_ * 0.07;
		var color = this.debugCol4;
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = oldx_ + w * Math.sin(theta);
			by = oldy_ + w * Math.cos(theta);
			theta += step;
			cx = oldx_ + w * Math.sin(theta);
			cy = oldy_ + w * Math.cos(theta);
			var color_ = color;
			if(color_ == null) {
				color_ = -1;
			}
			this.pen.triangle2DFill(oldx_,oldy_,bx,by,cx,cy,color_);
		}
		var color = this.debugCol3;
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = prevx_ + w * Math.sin(theta);
			by = prevy_ + w * Math.cos(theta);
			theta += step;
			cx = prevx_ + w * Math.sin(theta);
			cy = prevy_ + w * Math.cos(theta);
			var color_ = color;
			if(color_ == null) {
				color_ = -1;
			}
			this.pen.triangle2DFill(prevx_,prevy_,bx,by,cx,cy,color_);
		}
		var ax = this.jx;
		var ay = this.jy;
		var color = this.debugCol5;
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = ax + w * Math.sin(theta);
			by = ay + w * Math.cos(theta);
			theta += step;
			cx = ax + w * Math.sin(theta);
			cy = ay + w * Math.cos(theta);
			var color_ = color;
			if(color_ == null) {
				color_ = -1;
			}
			this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
		}
	}
	,connectQuadsWhenQuadsOverlay: function(clockWise,width_) {
		if(clockWise) {
			this.pen.triangle2DFill(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.ax,this.ay,-1);
		} else {
			this.pen.triangle2DFill(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.ax,this.ay,-1);
		}
	}
	,connectQuads: function(clockWise,width_) {
		if(clockWise) {
			this.pen.triangle2DFill(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.jx,this.jy,-1);
		} else {
			this.pen.triangle2DFill(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.jx,this.jy,-1);
		}
	}
	,addInitialQuads: function(clockWise,width_) {
		this.quadIndex = this.pen.get_pos();
		if(this.count == 0) {
			this.penultimateAX = this.dxPrev;
			this.penultimateAY = this.dyPrev;
			this.lastAntiX = this.ex;
			this.lastAntiY = this.ey;
			this.penultimateCX = this.dx;
			this.penultimateCY = this.dy;
			this.lastClockX = this.exPrev;
			this.lastClockY = this.eyPrev;
			this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
			this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
		} else {
			if(clockWise && !this.lastClock) {
				this.penultimateAX = this.jx;
				this.penultimateAY = this.jy;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.exPrev;
				this.lastClockY = this.eyPrev;
				this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
				this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
			}
			if(clockWise && this.lastClock) {
				this.penultimateAX = this.jx;
				this.penultimateAY = this.jy;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.exPrev;
				this.lastClockY = this.eyPrev;
				this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
				this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
			}
			if(!clockWise && !this.lastClock) {
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.jx;
				this.lastClockY = this.jy;
				this.penultimateAX = this.dxPrev;
				this.penultimateAY = this.dyPrev;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.jx,this.jy,-1);
				this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
			}
			if(!clockWise && this.lastClock) {
				this.penultimateAX = this.dxPrev;
				this.penultimateAY = this.dyPrev;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.jx;
				this.penultimateCY = this.jy;
				this.lastClockX = this.dx;
				this.lastClockY = this.dy;
				this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
				this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.jx,this.jy,this.ex,this.ey,-1);
			}
		}
	}
	,endEdges: function() {
		var pC = this.pointsClock.length;
		var pA = this.pointsAnti.length;
		this.pointsClock[pC++] = this.penultimateCX;
		this.pointsClock[pC++] = this.penultimateCY;
		this.pointsClock[pC++] = this.lastClockX;
		this.pointsClock[pC++] = this.lastClockY;
		this.pointsAnti[pA++] = this.penultimateAX;
		this.pointsAnti[pA++] = this.penultimateAY;
		this.pointsAnti[pA++] = this.lastAntiX;
		this.pointsAnti[pA++] = this.lastAntiY;
	}
	,addQuads: function(clockWise,width_) {
		var currQuadIndex = this.pen.get_pos();
		var pC = 0;
		var pA = 0;
		if(clockWise && !this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jxOld,this.jyOld,-1);
			}
			this.pen.set_pos(this.quadIndex);
			this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy,-1);
		}
		if(clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				this.pointsAnti[pA++] = this.kbx;
				this.pointsAnti[pA++] = this.kby;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kax;
				this.pointsClock[pC++] = this.kay;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.kbx,this.kby,this.jx,this.jy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.kbx,this.kby,this.ncx,this.ncy,-1);
			}
		}
		if(!clockWise && !this.lastClock) {
			this.pen.set_pos(this.quadIndex);
			this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy,-1);
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.jxOld,this.jyOld,-1);
			}
		}
		if(!clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.jx,this.jy,this.kcx,this.kcy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.jx,this.jy,this.ncx,this.ncy,-1);
			}
		}
		this.pen.set_pos(currQuadIndex);
	}
	,storeLastQuads: function() {
		this.kax = this.dxPrev;
		this.kay = this.dyPrev;
		this.kbx = this.dx;
		this.kby = this.dy;
		this.ncx = this.exPrev;
		this.ncy = this.eyPrev;
		this.kcx = this.ex;
		this.kcy = this.ey;
	}
	,isClockwise: function(x,y) {
		var x1 = this.dxOld - x;
		var y1 = this.dyOld - y;
		var x2 = this.exOld - x;
		var y2 = this.eyOld - y;
		return x1 * x1 + y1 * y1 > x2 * x2 + y2 * y2;
	}
	,line: function(ax_,ay_,bx_,by_,width_,endLineCurve) {
		if(endLineCurve == null) {
			endLineCurve = 0;
		}
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.halfA = Math.PI / 2;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var dxPrev_ = this.dx;
		var dyPrev_ = this.dy;
		var exPrev_ = this.ex;
		var eyPrev_ = this.ey;
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		switch(endLineCurve) {
		case 0:
			break;
		case 1:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 2:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 3:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 4:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 5:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 6:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 7:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 8:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 9:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 10:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 11:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 12:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 13:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 14:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 15:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 16:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 17:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 18:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 19:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 20:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		}
		this.pen.triangle2DFill(dxPrev_,dyPrev_,this.dx,this.dy,exPrev_,eyPrev_,-1);
		this.pen.triangle2DFill(dxPrev_,dyPrev_,this.dx,this.dy,this.ex,this.ey,-1);
	}
	,circle: function(ax,ay,radius,color,sides,omega) {
		if(omega == null) {
			omega = 0.;
		}
		if(sides == null) {
			sides = 36;
		}
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var theta = pi / 2 + omega;
		var step = pi * 2 / sides;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var _g = 0;
		var _g1 = sides;
		while(_g < _g1) {
			var i = _g++;
			bx = ax + radius * Math.sin(theta);
			by = ay + radius * Math.cos(theta);
			theta += step;
			cx = ax + radius * Math.sin(theta);
			cy = ay + radius * Math.cos(theta);
			var color_ = color;
			if(color_ == null) {
				color_ = -1;
			}
			this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
		}
		return sides;
	}
	,pie: function(ax,ay,radius,beta,gamma,prefer,color,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var step = pi * 2 / sides;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var smallest = theta <= Math.PI;
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step = dif / totalSteps;
		var angle = beta;
		var cx = 0.;
		var cy = 0.;
		var bx = 0.;
		var by = 0.;
		var dx = ax + radius * Math.sin(angle);
		var dy = ay + radius * Math.cos(angle);
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx = ax + radius * Math.sin(angle);
			cy = ay + radius * Math.cos(angle);
			if(i != 0) {
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
			}
			angle += step;
			bx = cx;
			by = cy;
		}
		return totalSteps;
	}
	,startShape: function(ax,ay,radius,beta,gamma,prefer,edgePoly,color,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var step = pi * 2 / sides;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var smallest = theta <= Math.PI;
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step = dif / totalSteps;
		var angle = beta;
		var beta2 = 0.;
		var this1 = this.endLine;
		if(this1 == 18 || this1 == 20) {
			angle = Math.PI / 2;
			beta2 = 2 * Math.PI - beta + Math.PI / 2;
		}
		var cx = 0.;
		var cy = 0.;
		var bx = 0.;
		var by = 0.;
		var p2 = edgePoly.length;
		var ex = 0.;
		var ey = 0.;
		var fx = 0.;
		var fy = 0.;
		var gx = 0.;
		var gy = 0.;
		var delta = 0.;
		var this1 = this.endLine;
		if(this1 == 12 || this1 == 14) {
			var angle2 = beta - step * totalSteps / 2;
			fx = ax - 0.75 * this.endCapFactor * radius * Math.sin(angle2);
			fy = ay - 0.75 * this.endCapFactor * radius * Math.cos(angle2);
			radius *= 2;
			delta = Math.pow(radius / 2,2);
		}
		var this1 = this.endLine;
		if(!(this1 == 6 || this1 == 8 || (this1 == 9 || this1 == 11) || (this1 == 15 || this1 == 17))) {
			if(this.endLine == 5) {
				var angle2 = beta - 2 * step * totalSteps;
				ax += radius * Math.sin(angle2);
				ay += radius * Math.cos(angle2);
				radius *= 2;
			}
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				var this1 = this.endLine;
				if(this1 == 12 || this1 == 14) {
					cx = fx + 0.5 * this.endCapFactor * radius * Math.sin(angle);
					cy = fy + 0.5 * this.endCapFactor * radius * Math.cos(angle);
					ex = fx - 0.5 * this.endCapFactor * radius * Math.sin(angle);
					ey = fy - 0.5 * this.endCapFactor * radius * Math.cos(angle);
				} else {
					var this2 = this.endLine;
					if(this2 == 18 || this2 == 20) {
						var ry = this.endCapFactor * radius;
						cx = ax + radius * Math.sin(angle);
						cy = ay + ry * Math.cos(angle);
						var cos = Math.cos(beta2);
						var sin = Math.sin(beta2);
						cx -= ax;
						cy -= ay;
						var ccx = cx;
						var ccy = cy;
						cx = ccx * cos - ccy * sin;
						cy = ccx * sin + ccy * cos;
						cx += ax;
						cy += ay;
					} else {
						cx = ax + radius * Math.sin(angle);
						cy = ay + radius * Math.cos(angle);
					}
				}
				edgePoly[p2++] = cx;
				edgePoly[p2++] = cy;
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
					var this3 = this.endLine;
					if(this3 == 12 || this3 == 14) {
						var deltaG = Math.pow(ay - gy,2) + Math.pow(ax - gx,2);
						var deltaE = Math.pow(ay - ey,2) + Math.pow(ax - ex,2);
						if(deltaE > delta || deltaG > delta) {
							var color_1 = color;
							if(color_1 == null) {
								color_1 = -1;
							}
							this.pen.triangle2DFill(ax,ay,gx,gy,ex,ey,color_1);
						}
					}
				}
				angle += step;
				bx = cx;
				by = cy;
				var this4 = this.endLine;
				if(this4 == 12 || this4 == 14) {
					gx = ex;
					gy = ey;
				}
			}
			if(this.endLine == 4) {
				angle = angle + step * totalSteps / 2 - step;
				cx = ax + radius * Math.sin(angle) * Math.sqrt(2);
				cy = ay + radius * Math.cos(angle) * Math.sqrt(2);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				bx = cx;
				by = cy;
				angle += step * (totalSteps / 2);
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				totalSteps += 2;
			}
		} else {
			var this1 = this.endLine;
			if(this1 == 9 || this1 == 11) {
				angle = beta;
				var ddx = ax - radius * this.endCapFactor * Math.sin(angle);
				var ddy = ay - radius * this.endCapFactor * Math.cos(angle);
				angle = beta - step * totalSteps / 2;
				cx = ax - radius * this.endCapFactor * Math.sin(angle);
				cy = ay - radius * this.endCapFactor * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ddx,ddy,cx,cy,ax,ay,color_);
				bx = cx;
				by = cy;
				angle += step * totalSteps / 2;
				cx = ax + radius * this.endCapFactor * Math.sin(angle);
				cy = ay + radius * this.endCapFactor * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
			} else {
				var this1 = this.endLine;
				if(this1 == 6 || this1 == 8) {
					angle = beta;
					var ddx = ax - radius * Math.sin(angle);
					var ddy = ay - radius * Math.cos(angle);
					angle = beta + step * totalSteps / 2;
					cx = ax + radius * Math.sin(angle);
					cy = ay + radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ddx,ddy,cx,cy,ax,ay,color_);
					bx = cx;
					by = cy;
					angle -= step * totalSteps / 2;
					cx = ax + radius * Math.sin(angle);
					cy = ay + radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				} else {
					var this1 = this.endLine;
					if(this1 == 15 || this1 == 17) {
						angle = beta;
						var ddx = ax - radius * this.endCapFactor * Math.sin(angle);
						var ddy = ay - radius * this.endCapFactor * Math.cos(angle);
						angle = beta - step * totalSteps / 2;
						cx = ddx - 2 * radius * this.endCapFactor * Math.sin(angle);
						cy = ddy - 2 * radius * this.endCapFactor * Math.cos(angle);
						var lastAngle = angle;
						angle += step * totalSteps / 2;
						ex = ax + radius * this.endCapFactor * Math.sin(angle);
						ey = ay + radius * this.endCapFactor * Math.cos(angle);
						fx = ex - 2 * radius * this.endCapFactor * Math.sin(lastAngle);
						fy = ey - 2 * radius * this.endCapFactor * Math.cos(lastAngle);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(fx,fy,cx,cy,ddx,ddy,color_);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(fx,fy,ddx,ddy,ex,ey,color_);
					}
				}
			}
			totalSteps += 2;
		}
		return totalSteps;
	}
	,endShape: function(ax,ay,radius,beta,gamma,prefer,edgePoly,color,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var step = pi * 2 / sides;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var smallest = theta <= Math.PI;
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step = dif / totalSteps;
		var angle = beta;
		var beta2 = 0.;
		var this1 = this.endLine;
		if(this1 == 19 || this1 == 20) {
			angle = Math.PI / 2;
			beta2 = 2 * Math.PI - beta + Math.PI / 2;
		}
		var cx = 0.;
		var cy = 0.;
		var bx = 0.;
		var by = 0.;
		var p2 = edgePoly.length;
		var ex = 0.;
		var ey = 0.;
		var fx = 0.;
		var fy = 0.;
		var gx = 0.;
		var gy = 0.;
		var delta = 0.;
		var this1 = this.endLine;
		if(this1 == 13 || this1 == 14) {
			var angle2 = beta - step * totalSteps / 2;
			fx = ax - 0.75 * this.endCapFactor * radius * Math.sin(angle2);
			fy = ay - 0.75 * this.endCapFactor * radius * Math.cos(angle2);
			radius *= 2;
			delta = Math.pow(radius / 2,2);
		}
		var ddx = ax + radius * Math.sin(angle);
		var ddy = ay + radius * Math.cos(angle);
		var this1 = this.endLine;
		if(!(this1 == 7 || this1 == 8 || (this1 == 10 || this1 == 11) || (this1 == 16 || this1 == 17))) {
			if(this.endLine == 5) {
				var angle2 = beta - 2 * step * totalSteps;
				ax += radius * Math.sin(angle2);
				ay += radius * Math.cos(angle2);
				radius *= 2;
			}
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				var this1 = this.endLine;
				if(this1 == 13 || this1 == 14) {
					cx = fx + 0.5 * this.endCapFactor * radius * Math.sin(angle);
					cy = fy + 0.5 * this.endCapFactor * radius * Math.cos(angle);
					ex = fx - 0.5 * this.endCapFactor * radius * Math.sin(angle);
					ey = fy - 0.5 * this.endCapFactor * radius * Math.cos(angle);
				} else {
					var this2 = this.endLine;
					if(this2 == 19 || this2 == 20) {
						var ry = this.endCapFactor * radius;
						cx = ax + radius * Math.sin(angle);
						cy = ay + ry * Math.cos(angle);
						var cos = Math.cos(beta2);
						var sin = Math.sin(beta2);
						cx -= ax;
						cy -= ay;
						var ccx = cx;
						var ccy = cy;
						cx = ccx * cos - ccy * sin;
						cy = ccx * sin + ccy * cos;
						cx += ax;
						cy += ay;
					} else {
						cx = ax + radius * Math.sin(angle);
						cy = ay + radius * Math.cos(angle);
					}
				}
				edgePoly[p2++] = cx;
				edgePoly[p2++] = cy;
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
					var this3 = this.endLine;
					if(this3 == 13 || this3 == 14) {
						var deltaG = Math.pow(ay - gy,2) + Math.pow(ax - gx,2);
						var deltaE = Math.pow(ay - ey,2) + Math.pow(ax - ex,2);
						if(deltaE > delta || deltaG > delta) {
							var color_1 = color;
							if(color_1 == null) {
								color_1 = -1;
							}
							this.pen.triangle2DFill(ax,ay,gx,gy,ex,ey,color_1);
						}
					}
				}
				angle += step;
				bx = cx;
				by = cy;
				var this4 = this.endLine;
				if(this4 == 13 || this4 == 14) {
					gx = ex;
					gy = ey;
				}
			}
			if(this.endLine == 4) {
				angle = angle + step * totalSteps / 2 - step;
				cx = ax + radius * Math.sin(angle) * Math.sqrt(2);
				cy = ay + radius * Math.cos(angle) * Math.sqrt(2);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				bx = cx;
				by = cy;
				angle += step * (totalSteps / 2);
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				totalSteps += 2;
			}
		} else {
			if(this.endLine == 11 || this.endLine == 10) {
				angle = beta;
				var dx = ax - radius * this.endCapFactor * Math.sin(angle);
				var dy = ay - radius * this.endCapFactor * Math.cos(angle);
				angle = beta - step * totalSteps / 2;
				cx = ax - radius * this.endCapFactor * Math.sin(angle);
				cy = ay - radius * this.endCapFactor * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ddx,ddy,cx,cy,ax,ay,color_);
				bx = cx;
				by = cy;
				angle += step * totalSteps / 2;
				cx = ax + radius * this.endCapFactor * Math.sin(angle);
				cy = ay + radius * this.endCapFactor * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
			} else {
				var this1 = this.endLine;
				if(this1 == 7 || this1 == 8) {
					angle = beta;
					var dx = ax - radius * Math.sin(angle);
					var dy = ay - radius * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax - radius * Math.sin(angle);
					cy = ay - radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ddx,ddy,cx,cy,ax,ay,color_);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax + radius * Math.sin(angle);
					cy = ay + radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				} else {
					var this1 = this.endLine;
					if(this1 == 16 || this1 == 17) {
						angle = beta;
						var dx = ax - radius * this.endCapFactor * Math.sin(angle);
						var dy = ay - radius * this.endCapFactor * Math.cos(angle);
						angle = beta - step * totalSteps / 2;
						cx = dx - 2 * radius * this.endCapFactor * Math.sin(angle);
						cy = dy - 2 * radius * this.endCapFactor * Math.cos(angle);
						var lastAngle = angle;
						angle += step * totalSteps / 2;
						ex = ax + radius * this.endCapFactor * Math.sin(angle);
						ey = ay + radius * this.endCapFactor * Math.cos(angle);
						fx = ex - 2 * radius * this.endCapFactor * Math.sin(lastAngle);
						fy = ey - 2 * radius * this.endCapFactor * Math.cos(lastAngle);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(fx,fy,cx,cy,ddx,ddy,color_);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(fx,fy,ddx,ddy,ex,ey,color_);
					}
				}
			}
			totalSteps += 2;
		}
		return totalSteps;
	}
	,pieDifX: function(ax,ay,radius,beta,dif,edgePoly,color,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var step = pi * 2 / sides;
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step = dif / totalSteps;
		var angle = beta;
		var cx = 0.;
		var cy = 0.;
		var bx = 0.;
		var by = 0.;
		var p2 = edgePoly.length;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx = ax + radius * Math.sin(angle);
			cy = ay + radius * Math.cos(angle);
			edgePoly[p2++] = cx;
			edgePoly[p2++] = cy;
			if(i != 0) {
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
			}
			angle += step;
			bx = cx;
			by = cy;
		}
		return totalSteps;
	}
};
var cornerContour_ContourGrad = function(pen_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.counter = 0;
	this.count = 0;
	this.endCapFactor = 1.45;
	this.pointsAnti = [];
	this.pointsClock = [];
	this.debugCol12 = -893376;
	this.debugCol11 = -3986796;
	this.debugCol10 = -9230154;
	this.debugCol9 = -13354819;
	this.debugCol8 = -12617788;
	this.debugCol7 = -11686193;
	this.debugCol6 = -11288539;
	this.debugCol5 = -5778134;
	this.debugCol4 = -211;
	this.debugCol3 = -338891;
	this.debugCol2 = -742865;
	this.debugCol1 = -884166;
	this.debugCol0 = -1098686;
	this.colorGradChoice = "colorAB";
	this.pen = pen_;
	this.endLine = endLine_;
};
cornerContour_ContourGrad.__name__ = true;
cornerContour_ContourGrad.thetaCompute = function(px,py,qx,qy) {
	return Math.atan2(py - qy,px - qx);
};
cornerContour_ContourGrad.dist = function(px,py,qx,qy) {
	var x = px - qx;
	var y = py - qy;
	return x * x + y * y;
};
cornerContour_ContourGrad.prototype = {
	setGradChoice: function(colorGradChoice_) {
		this.colorGradChoice = colorGradChoice_;
	}
	,getGradColors: function() {
		switch(this.colorGradChoice) {
		case "colorAB":
			return new cornerContour_color_TwoGrad_$(this.pen.currentColor,this.pen.colorB);
		case "colorAC":
			return new cornerContour_color_TwoGrad_$(this.pen.currentColor,this.pen.colorC);
		case "colorBA":
			return new cornerContour_color_TwoGrad_$(this.pen.colorB,this.pen.currentColor);
		case "colorBC":
			return new cornerContour_color_TwoGrad_$(this.pen.colorB,this.pen.colorC);
		case "colorCA":
			return new cornerContour_color_TwoGrad_$(this.pen.colorC,this.pen.currentColor);
		case "colorCB":
			return new cornerContour_color_TwoGrad_$(this.pen.colorC,this.pen.colorB);
		}
	}
	,reset: function() {
		this.angleA = 0;
		this.count = 0;
		this.kax = 0;
		this.kay = 0;
		this.kbx = 0;
		this.kby = 0;
		this.kcx = 0;
		this.kcy = 0;
		this.ncx = 0;
		this.ncy = 0;
		this.ax = 0;
		this.ay = 0;
		this.bx = 0;
		this.by = 0;
		this.cx = 0;
		this.cy = 0;
		this.dx = null;
		this.dy = null;
		this.ex = null;
		this.ey = null;
		this.pointsClock.length = 0;
		this.pointsAnti.length = 0;
	}
	,computeDE: function() {
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
	}
	,anglesCompute: function() {
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
	}
	,thetaComputeAdj: function(qx,qy) {
		return -Math.atan2(this.ay - qy,this.ax - qx) - Math.PI / 2;
	}
	,triangleJoin: function(ax_,ay_,bx_,by_,width_,curveEnds,overlap) {
		if(overlap == null) {
			overlap = false;
		}
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = this.dx != null ? this.angle1 : null;
		this.halfA = Math.PI / 2;
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var x = this.dxOld - bx_;
		var y = this.dyOld - by_;
		var x1 = this.exOld - bx_;
		var y1 = this.eyOld - by_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(this.ay - this.dyOld,this.ax - this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.eyPrev,this.ax - this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(this.ay - this.eyOld,this.ax - this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.dyPrev,this.ax - this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = theta0;
			var fb = theta1;
			var theta = Math.abs(theta0 - theta1);
			var smallest = theta <= Math.PI;
			var clockwise = theta0 < theta1;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(!overlap && this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			this.jx = this.ax + h * Math.sin(delta);
			this.jy = this.ay + h * Math.cos(delta);
		}
		if(this.count == 0 && (this.endLine == 1 || this.endLine == 3 || this.endLine == 6 || this.endLine == 8 || this.endLine == 11 || this.endLine == 9 || this.endLine == 15 || this.endLine == 17 || this.endLine == 12 || this.endLine == 14 || this.endLine == 18 || this.endLine == 20)) {
			var ax = this.ax;
			var ay = this.ay;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var clockwiseTemp = false;
			var ax1 = ax;
			var ay1 = ay;
			var radius = width_ / 2;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif1;
			switch(fracs_DifferencePreference.SMALL_OLD._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 > 0 ? dif2 : 2 * Math.PI + dif2;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = largest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif1 >= 0;
			var totalSteps = this.endLine == 5 ? Math.ceil(Math.abs(dif1) / (step / 2)) : Math.ceil(Math.abs(dif1) / step);
			var step = dif1 / totalSteps;
			var angle = beta;
			var beta2 = 0.;
			var this1 = this.endLine;
			if(this1 == 18 || this1 == 20) {
				angle = Math.PI / 2;
				beta2 = 2 * Math.PI - beta + Math.PI / 2;
			}
			var cx = 0;
			var cy = 0;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var col = this.getGradColors();
			var c0 = col.colorAnti;
			var c1 = col.colorClock;
			var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
			var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
			var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
			var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
			var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
			var dx = ax1 + radius * Math.sin(angle);
			var dy = ay1 + radius * Math.cos(angle);
			var ex = 0.;
			var ey = 0.;
			var fx = 0.;
			var fy = 0.;
			var gx = 0.;
			var gy = 0.;
			var delta = 0.;
			var this1 = this.endLine;
			if(this1 == 12 || this1 == 14) {
				var angle2 = beta - step * totalSteps / 2;
				fx = ax1 - 0.75 * this.endCapFactor * radius * Math.sin(angle2);
				fy = ay1 - 0.75 * this.endCapFactor * radius * Math.cos(angle2);
				radius *= 2;
				delta = Math.pow(radius / 2,2);
			}
			var this1 = this.endLine;
			if(!(this1 == 6 || this1 == 8 || (this1 == 9 || this1 == 11) || (this1 == 15 || this1 == 17))) {
				if(this.endLine == 5) {
					var angle2 = beta - 2 * step * totalSteps;
					ax1 += radius * Math.sin(angle2);
					ay1 += radius * Math.cos(angle2);
					radius *= 2;
				}
				if(this.endLine == 5) {
					half = col.colorAnti;
				}
				var beta2 = 2 * Math.PI - beta + Math.PI / 2;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					var this1 = this.endLine;
					if(this1 == 12 || this1 == 14) {
						cx = fx + 0.5 * this.endCapFactor * radius * Math.sin(angle);
						cy = fy + 0.5 * this.endCapFactor * radius * Math.cos(angle);
						ex = fx - 0.5 * this.endCapFactor * radius * Math.sin(angle);
						ey = fy - 0.5 * this.endCapFactor * radius * Math.cos(angle);
					} else {
						var this2 = this.endLine;
						if(this2 == 18 || this2 == 20) {
							var ry = this.endCapFactor * radius;
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + ry * Math.cos(angle);
							var cos = Math.cos(beta2);
							var sin = Math.sin(beta2);
							cx -= ax1;
							cy -= ay1;
							var ccx = cx;
							var ccy = cy;
							cx = ccx * cos - ccy * sin;
							cy = ccx * sin + ccy * cos;
							cx += ax1;
							cy += ay1;
						} else {
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + radius * Math.cos(angle);
						}
					}
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						if(!clockwiseTemp) {
							var second;
							if(this.endLine == 4) {
								var c0 = col.colorAnti;
								var c1 = col.colorClock;
								var t = 0.5 * i / totalSteps;
								if(t == null) {
									t = 0.5;
								}
								var t0 = t;
								if(t0 == null) {
									t0 = 0.5;
								}
								var t1 = 1. - t0;
								var a = t0 * ((c0 >> 24 & 255) / 255) + t1 * ((c1 >> 24 & 255) / 255);
								var t01 = t;
								if(t01 == null) {
									t01 = 0.5;
								}
								var t11 = 1. - t01;
								var r = t01 * ((c0 >> 16 & 255) / 255) + t11 * ((c1 >> 16 & 255) / 255);
								var t02 = t;
								if(t02 == null) {
									t02 = 0.5;
								}
								var t12 = 1. - t02;
								var g = t02 * ((c0 >> 8 & 255) / 255) + t12 * ((c1 >> 8 & 255) / 255);
								var t03 = t;
								if(t03 == null) {
									t03 = 0.5;
								}
								var t13 = 1. - t03;
								var b = t03 * ((c0 & 255) / 255) + t13 * ((c1 & 255) / 255);
								second = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
							} else {
								var c01 = col.colorAnti;
								var c11 = col.colorClock;
								var t2 = i / totalSteps;
								if(t2 == null) {
									t2 = 0.5;
								}
								var t04 = t2;
								if(t04 == null) {
									t04 = 0.5;
								}
								var t14 = 1. - t04;
								var a1 = t04 * ((c01 >> 24 & 255) / 255) + t14 * ((c11 >> 24 & 255) / 255);
								var t05 = t2;
								if(t05 == null) {
									t05 = 0.5;
								}
								var t15 = 1. - t05;
								var r1 = t05 * ((c01 >> 16 & 255) / 255) + t15 * ((c11 >> 16 & 255) / 255);
								var t06 = t2;
								if(t06 == null) {
									t06 = 0.5;
								}
								var t16 = 1. - t06;
								var g1 = t06 * ((c01 >> 8 & 255) / 255) + t16 * ((c11 >> 8 & 255) / 255);
								var t07 = t2;
								if(t07 == null) {
									t07 = 0.5;
								}
								var t17 = 1. - t07;
								var b1 = t07 * ((c01 & 255) / 255) + t17 * ((c11 & 255) / 255);
								second = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
							}
							var this3 = this.endLine;
							if(this3 == 12 || this3 == 14) {
								var deltaG = Math.pow(ay1 - gy,2) + Math.pow(ax1 - gx,2);
								var deltaE = Math.pow(ay1 - ey,2) + Math.pow(ax1 - ex,2);
								if(deltaE > delta || deltaG > delta) {
									var second2 = i / totalSteps > 0.5 ? col.colorClock : col.colorAnti;
									this.pen.triangle2DGrad(ax1,ay1,gx,gy,ex,ey,half,second2,second2);
								}
							}
							this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second,second);
						} else {
							var c02 = col.colorAnti;
							var c12 = col.colorClock;
							var t3 = 1 - i / totalSteps;
							if(t3 == null) {
								t3 = 0.5;
							}
							var t08 = t3;
							if(t08 == null) {
								t08 = 0.5;
							}
							var t18 = 1. - t08;
							var a2 = t08 * ((c02 >> 24 & 255) / 255) + t18 * ((c12 >> 24 & 255) / 255);
							var t09 = t3;
							if(t09 == null) {
								t09 = 0.5;
							}
							var t19 = 1. - t09;
							var r2 = t09 * ((c02 >> 16 & 255) / 255) + t19 * ((c12 >> 16 & 255) / 255);
							var t010 = t3;
							if(t010 == null) {
								t010 = 0.5;
							}
							var t110 = 1. - t010;
							var g2 = t010 * ((c02 >> 8 & 255) / 255) + t110 * ((c12 >> 8 & 255) / 255);
							var t011 = t3;
							if(t011 == null) {
								t011 = 0.5;
							}
							var t111 = 1. - t011;
							var b2 = t011 * ((c02 & 255) / 255) + t111 * ((c12 & 255) / 255);
							var second1 = Math.round(a2 * 255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
							var this4 = this.endLine;
							if(this4 == 12 || this4 == 14) {
								var deltaG1 = Math.pow(ay1 - gy,2) + Math.pow(ax1 - gx,2);
								var deltaE1 = Math.pow(ay1 - ey,2) + Math.pow(ax1 - ex,2);
								if(deltaE1 > delta || deltaG1 > delta) {
									var second21 = 1 - i / totalSteps > 0.5 ? col.colorClock : col.colorAnti;
									this.pen.triangle2DGrad(ax1,ay1,gx,gy,ex,ey,half,second21,second21);
								}
							}
							this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second1,second1);
						}
					}
					angle += step;
					bx = cx;
					by = cy;
					var this5 = this.endLine;
					if(this5 == 12 || this5 == 14) {
						gx = ex;
						gy = ey;
					}
				}
				if(this.endLine == 4) {
					angle = angle + step * totalSteps / 2 - step;
					cx = ax1 + radius * Math.sin(angle) * Math.sqrt(2);
					cy = ay1 + radius * Math.cos(angle) * Math.sqrt(2);
					this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,half,col.colorAnti);
					bx = cx;
					by = cy;
					angle += step * (totalSteps / 2);
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,col.colorAnti,col.colorAnti);
					totalSteps += 2;
				}
			} else {
				var this1 = this.endLine;
				if(this1 == 9 || this1 == 11) {
					angle = beta;
					var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 + radius * this.endCapFactor * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,col.colorClock,half);
				} else {
					var this1 = this.endLine;
					if(this1 == 6 || this1 == 8) {
						angle = beta;
						var dx = ax1 - radius * Math.sin(angle);
						var dy = ay1 - radius * Math.cos(angle);
						angle = beta + step * totalSteps / 2;
						cx = ax1 + radius * Math.sin(angle);
						cy = ay1 + radius * Math.cos(angle);
						this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
						bx = cx;
						by = cy;
						angle -= step * totalSteps / 2;
						cx = ax1 + radius * Math.sin(angle);
						cy = ay1 + radius * Math.cos(angle);
						this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,col.colorClock,half);
					} else {
						var this1 = this.endLine;
						if(this1 == 15 || this1 == 17) {
							angle = beta;
							var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
							var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
							angle = beta - step * totalSteps / 2;
							cx = dx - 2 * radius * this.endCapFactor * Math.sin(angle);
							cy = dy - 2 * radius * this.endCapFactor * Math.cos(angle);
							var lastAngle = angle;
							angle += step * totalSteps / 2;
							ex = ax1 + radius * this.endCapFactor * Math.sin(angle);
							ey = ay1 + radius * this.endCapFactor * Math.cos(angle);
							fx = ex - 2 * radius * this.endCapFactor * Math.sin(lastAngle);
							fy = ey - 2 * radius * this.endCapFactor * Math.cos(lastAngle);
							this.pen.triangle2DGrad(fx,fy,cx,cy,dx,dy,col.colorClock,col.colorAnti,col.colorAnti);
							this.pen.triangle2DGrad(fx,fy,dx,dy,ex,ey,col.colorClock,col.colorAnti,col.colorClock);
						}
					}
				}
				totalSteps += 2;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[i * 2 + len + 1];
				this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(this.count == 0 && (this.endLine == 4 || this.endLine == 5)) {
			var ax = this.ax;
			var ay = this.ay;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI / 2;
			var temp = [];
			var clockwiseTemp = false;
			var ax1 = ax;
			var ay1 = ay;
			var radius = width_ / 2;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif1;
			switch(fracs_DifferencePreference.SMALL_OLD._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 > 0 ? dif2 : 2 * Math.PI + dif2;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = largest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif1 >= 0;
			var totalSteps = this.endLine == 5 ? Math.ceil(Math.abs(dif1) / (step / 2)) : Math.ceil(Math.abs(dif1) / step);
			var step = dif1 / totalSteps;
			var angle = beta;
			var beta2 = 0.;
			var this1 = this.endLine;
			if(this1 == 18 || this1 == 20) {
				angle = Math.PI / 2;
				beta2 = 2 * Math.PI - beta + Math.PI / 2;
			}
			var cx = 0;
			var cy = 0;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var col = this.getGradColors();
			var c0 = col.colorAnti;
			var c1 = col.colorClock;
			var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
			var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
			var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
			var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
			var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
			var dx = ax1 + radius * Math.sin(angle);
			var dy = ay1 + radius * Math.cos(angle);
			var ex = 0.;
			var ey = 0.;
			var fx = 0.;
			var fy = 0.;
			var gx = 0.;
			var gy = 0.;
			var delta = 0.;
			var this1 = this.endLine;
			if(this1 == 12 || this1 == 14) {
				var angle2 = beta - step * totalSteps / 2;
				fx = ax1 - 0.75 * this.endCapFactor * radius * Math.sin(angle2);
				fy = ay1 - 0.75 * this.endCapFactor * radius * Math.cos(angle2);
				radius *= 2;
				delta = Math.pow(radius / 2,2);
			}
			var this1 = this.endLine;
			if(!(this1 == 6 || this1 == 8 || (this1 == 9 || this1 == 11) || (this1 == 15 || this1 == 17))) {
				if(this.endLine == 5) {
					var angle2 = beta - 2 * step * totalSteps;
					ax1 += radius * Math.sin(angle2);
					ay1 += radius * Math.cos(angle2);
					radius *= 2;
				}
				if(this.endLine == 5) {
					half = col.colorAnti;
				}
				var beta2 = 2 * Math.PI - beta + Math.PI / 2;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					var this1 = this.endLine;
					if(this1 == 12 || this1 == 14) {
						cx = fx + 0.5 * this.endCapFactor * radius * Math.sin(angle);
						cy = fy + 0.5 * this.endCapFactor * radius * Math.cos(angle);
						ex = fx - 0.5 * this.endCapFactor * radius * Math.sin(angle);
						ey = fy - 0.5 * this.endCapFactor * radius * Math.cos(angle);
					} else {
						var this2 = this.endLine;
						if(this2 == 18 || this2 == 20) {
							var ry = this.endCapFactor * radius;
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + ry * Math.cos(angle);
							var cos = Math.cos(beta2);
							var sin = Math.sin(beta2);
							cx -= ax1;
							cy -= ay1;
							var ccx = cx;
							var ccy = cy;
							cx = ccx * cos - ccy * sin;
							cy = ccx * sin + ccy * cos;
							cx += ax1;
							cy += ay1;
						} else {
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + radius * Math.cos(angle);
						}
					}
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						if(!clockwiseTemp) {
							var second;
							if(this.endLine == 4) {
								var c0 = col.colorAnti;
								var c1 = col.colorClock;
								var t = 0.5 * i / totalSteps;
								if(t == null) {
									t = 0.5;
								}
								var t0 = t;
								if(t0 == null) {
									t0 = 0.5;
								}
								var t1 = 1. - t0;
								var a = t0 * ((c0 >> 24 & 255) / 255) + t1 * ((c1 >> 24 & 255) / 255);
								var t01 = t;
								if(t01 == null) {
									t01 = 0.5;
								}
								var t11 = 1. - t01;
								var r = t01 * ((c0 >> 16 & 255) / 255) + t11 * ((c1 >> 16 & 255) / 255);
								var t02 = t;
								if(t02 == null) {
									t02 = 0.5;
								}
								var t12 = 1. - t02;
								var g = t02 * ((c0 >> 8 & 255) / 255) + t12 * ((c1 >> 8 & 255) / 255);
								var t03 = t;
								if(t03 == null) {
									t03 = 0.5;
								}
								var t13 = 1. - t03;
								var b = t03 * ((c0 & 255) / 255) + t13 * ((c1 & 255) / 255);
								second = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
							} else {
								var c01 = col.colorAnti;
								var c11 = col.colorClock;
								var t2 = i / totalSteps;
								if(t2 == null) {
									t2 = 0.5;
								}
								var t04 = t2;
								if(t04 == null) {
									t04 = 0.5;
								}
								var t14 = 1. - t04;
								var a1 = t04 * ((c01 >> 24 & 255) / 255) + t14 * ((c11 >> 24 & 255) / 255);
								var t05 = t2;
								if(t05 == null) {
									t05 = 0.5;
								}
								var t15 = 1. - t05;
								var r1 = t05 * ((c01 >> 16 & 255) / 255) + t15 * ((c11 >> 16 & 255) / 255);
								var t06 = t2;
								if(t06 == null) {
									t06 = 0.5;
								}
								var t16 = 1. - t06;
								var g1 = t06 * ((c01 >> 8 & 255) / 255) + t16 * ((c11 >> 8 & 255) / 255);
								var t07 = t2;
								if(t07 == null) {
									t07 = 0.5;
								}
								var t17 = 1. - t07;
								var b1 = t07 * ((c01 & 255) / 255) + t17 * ((c11 & 255) / 255);
								second = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
							}
							var this3 = this.endLine;
							if(this3 == 12 || this3 == 14) {
								var deltaG = Math.pow(ay1 - gy,2) + Math.pow(ax1 - gx,2);
								var deltaE = Math.pow(ay1 - ey,2) + Math.pow(ax1 - ex,2);
								if(deltaE > delta || deltaG > delta) {
									var second2 = i / totalSteps > 0.5 ? col.colorClock : col.colorAnti;
									this.pen.triangle2DGrad(ax1,ay1,gx,gy,ex,ey,half,second2,second2);
								}
							}
							this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second,second);
						} else {
							var c02 = col.colorAnti;
							var c12 = col.colorClock;
							var t3 = 1 - i / totalSteps;
							if(t3 == null) {
								t3 = 0.5;
							}
							var t08 = t3;
							if(t08 == null) {
								t08 = 0.5;
							}
							var t18 = 1. - t08;
							var a2 = t08 * ((c02 >> 24 & 255) / 255) + t18 * ((c12 >> 24 & 255) / 255);
							var t09 = t3;
							if(t09 == null) {
								t09 = 0.5;
							}
							var t19 = 1. - t09;
							var r2 = t09 * ((c02 >> 16 & 255) / 255) + t19 * ((c12 >> 16 & 255) / 255);
							var t010 = t3;
							if(t010 == null) {
								t010 = 0.5;
							}
							var t110 = 1. - t010;
							var g2 = t010 * ((c02 >> 8 & 255) / 255) + t110 * ((c12 >> 8 & 255) / 255);
							var t011 = t3;
							if(t011 == null) {
								t011 = 0.5;
							}
							var t111 = 1. - t011;
							var b2 = t011 * ((c02 & 255) / 255) + t111 * ((c12 & 255) / 255);
							var second1 = Math.round(a2 * 255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
							var this4 = this.endLine;
							if(this4 == 12 || this4 == 14) {
								var deltaG1 = Math.pow(ay1 - gy,2) + Math.pow(ax1 - gx,2);
								var deltaE1 = Math.pow(ay1 - ey,2) + Math.pow(ax1 - ex,2);
								if(deltaE1 > delta || deltaG1 > delta) {
									var second21 = 1 - i / totalSteps > 0.5 ? col.colorClock : col.colorAnti;
									this.pen.triangle2DGrad(ax1,ay1,gx,gy,ex,ey,half,second21,second21);
								}
							}
							this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second1,second1);
						}
					}
					angle += step;
					bx = cx;
					by = cy;
					var this5 = this.endLine;
					if(this5 == 12 || this5 == 14) {
						gx = ex;
						gy = ey;
					}
				}
				if(this.endLine == 4) {
					angle = angle + step * totalSteps / 2 - step;
					cx = ax1 + radius * Math.sin(angle) * Math.sqrt(2);
					cy = ay1 + radius * Math.cos(angle) * Math.sqrt(2);
					this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,half,col.colorAnti);
					bx = cx;
					by = cy;
					angle += step * (totalSteps / 2);
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,col.colorAnti,col.colorAnti);
					totalSteps += 2;
				}
			} else {
				var this1 = this.endLine;
				if(this1 == 9 || this1 == 11) {
					angle = beta;
					var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 + radius * this.endCapFactor * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,col.colorClock,half);
				} else {
					var this1 = this.endLine;
					if(this1 == 6 || this1 == 8) {
						angle = beta;
						var dx = ax1 - radius * Math.sin(angle);
						var dy = ay1 - radius * Math.cos(angle);
						angle = beta + step * totalSteps / 2;
						cx = ax1 + radius * Math.sin(angle);
						cy = ay1 + radius * Math.cos(angle);
						this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
						bx = cx;
						by = cy;
						angle -= step * totalSteps / 2;
						cx = ax1 + radius * Math.sin(angle);
						cy = ay1 + radius * Math.cos(angle);
						this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,col.colorClock,half);
					} else {
						var this1 = this.endLine;
						if(this1 == 15 || this1 == 17) {
							angle = beta;
							var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
							var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
							angle = beta - step * totalSteps / 2;
							cx = dx - 2 * radius * this.endCapFactor * Math.sin(angle);
							cy = dy - 2 * radius * this.endCapFactor * Math.cos(angle);
							var lastAngle = angle;
							angle += step * totalSteps / 2;
							ex = ax1 + radius * this.endCapFactor * Math.sin(angle);
							ey = ay1 + radius * this.endCapFactor * Math.cos(angle);
							fx = ex - 2 * radius * this.endCapFactor * Math.sin(lastAngle);
							fy = ey - 2 * radius * this.endCapFactor * Math.cos(lastAngle);
							this.pen.triangle2DGrad(fx,fy,cx,cy,dx,dy,col.colorClock,col.colorAnti,col.colorAnti);
							this.pen.triangle2DGrad(fx,fy,dx,dy,ex,ey,col.colorClock,col.colorAnti,col.colorClock);
						}
					}
				}
				totalSteps += 2;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[i * 2 + len + 1];
				this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(overlap) {
			var ax_1 = this.dxPrev;
			var ay_1 = this.dyPrev;
			var bx_ = this.dx;
			var by_ = this.dy;
			var cx_ = this.ex;
			var cy_ = this.ey;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,C);
			var ax_1 = this.dxPrev;
			var ay_1 = this.dyPrev;
			var bx_ = this.dx;
			var by_ = this.dy;
			var cx_ = this.exPrev;
			var cy_ = this.eyPrev;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,C);
		} else {
			if(this.count != 0) {
				this.addQuads(clockWise,width_);
			}
			this.quadIndex = this.pen.get_pos();
			if(this.count == 0) {
				this.penultimateAX = this.dxPrev;
				this.penultimateAY = this.dyPrev;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.exPrev;
				this.lastClockY = this.eyPrev;
				var ax_1 = this.dxPrev;
				var ay_1 = this.dyPrev;
				var bx_ = this.dx;
				var by_ = this.dy;
				var cx_ = this.ex;
				var cy_ = this.ey;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,C);
				var ax_1 = this.jx;
				var ay_1 = this.jy;
				var bx_ = this.dx;
				var by_ = this.dy;
				var cx_ = this.exPrev;
				var cy_ = this.eyPrev;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,A);
			} else {
				if(clockWise && !this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					var ax_1 = this.jx;
					var ay_1 = this.jy;
					var bx_ = this.dx;
					var by_ = this.dy;
					var cx_ = this.ex;
					var cy_ = this.ey;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,C);
					var ax_1 = this.jx;
					var ay_1 = this.jy;
					var bx_ = this.dx;
					var by_ = this.dy;
					var cx_ = this.exPrev;
					var cy_ = this.eyPrev;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,A);
				}
				if(clockWise && this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					var ax_1 = this.jx;
					var ay_1 = this.jy;
					var bx_ = this.dx;
					var by_ = this.dy;
					var cx_ = this.ex;
					var cy_ = this.ey;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,C);
					var ax_1 = this.jx;
					var ay_1 = this.jy;
					var bx_ = this.dx;
					var by_ = this.dy;
					var cx_ = this.exPrev;
					var cy_ = this.eyPrev;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,A);
				}
				if(!clockWise && !this.lastClock) {
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.jx;
					this.lastClockY = this.jy;
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					var ax_1 = this.dxPrev;
					var ay_1 = this.dyPrev;
					var bx_ = this.dx;
					var by_ = this.dy;
					var cx_ = this.jx;
					var cy_ = this.jy;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,A);
					var ax_1 = this.dxPrev;
					var ay_1 = this.dyPrev;
					var bx_ = this.dx;
					var by_ = this.dy;
					var cx_ = this.ex;
					var cy_ = this.ey;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,C);
				}
				if(!clockWise && this.lastClock) {
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.jx;
					this.penultimateCY = this.jy;
					this.lastClockX = this.dx;
					this.lastClockY = this.dy;
					var ax_1 = this.jx;
					var ay_1 = this.jy;
					var bx_ = this.dx;
					var by_ = this.dy;
					var cx_ = this.ex;
					var cy_ = this.ey;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,A,A,C);
					var ax_1 = this.dxPrev;
					var ay_1 = this.dyPrev;
					var bx_ = this.jx;
					var by_ = this.jy;
					var cx_ = this.ex;
					var cy_ = this.ey;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,C);
				}
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var radius = width_ / 2;
				var edgePoly = this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx = 0.;
				var cy = 0.;
				var bx = 0.;
				var by = 0.;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						if(!clockWise) {
							var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
							var c0 = col.colorAnti;
							var c1 = col.colorClock;
							var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
							var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
							var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
							var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
							var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
							this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,half,col.colorClock,col.colorClock);
						} else {
							var col1 = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
							var c01 = col1.colorAnti;
							var c11 = col1.colorClock;
							var a1 = ((c01 >> 24 & 255) / 255 + (c11 >> 24 & 255) / 255) / 2;
							var r1 = ((c01 >> 16 & 255) / 255 + (c11 >> 16 & 255) / 255) / 2;
							var g1 = ((c01 >> 8 & 255) / 255 + (c11 >> 8 & 255) / 255) / 2;
							var b1 = ((c01 & 255) / 255 + (c11 & 255) / 255) / 2;
							var half1 = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
							this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,half1,col1.colorAnti,col1.colorAnti);
						}
					}
					angle += step;
					bx = cx;
					by = cy;
				}
			} else {
				var radius = width_ / 2;
				var edgePoly = this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx = 0.;
				var cy = 0.;
				var bx = 0.;
				var by = 0.;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						if(!clockWise) {
							var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
							var c0 = col.colorAnti;
							var c1 = col.colorClock;
							var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
							var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
							var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
							var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
							var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
							this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,half,col.colorClock,col.colorClock);
						} else {
							var col1 = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
							var c01 = col1.colorAnti;
							var c11 = col1.colorClock;
							var a1 = ((c01 >> 24 & 255) / 255 + (c11 >> 24 & 255) / 255) / 2;
							var r1 = ((c01 >> 16 & 255) / 255 + (c11 >> 16 & 255) / 255) / 2;
							var g1 = ((c01 >> 8 & 255) / 255 + (c11 >> 8 & 255) / 255) / 2;
							var b1 = ((c01 & 255) / 255 + (c11 & 255) / 255) / 2;
							var half1 = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
							this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,half1,col1.colorAnti,col1.colorAnti);
						}
					}
					angle += step;
					bx = cx;
					by = cy;
				}
			}
		} else if(this.count != 0) {
			if(overlap) {
				if(clockWise) {
					var ax_ = this.dxOld;
					var ay_ = this.dyOld;
					var bx_ = this.exPrev;
					var by_ = this.eyPrev;
					var cx_ = this.ax;
					var cy_ = this.ay;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,A,A,C);
				} else {
					var ax_ = this.exOld;
					var ay_ = this.eyOld;
					var bx_ = this.dxPrev;
					var by_ = this.dyPrev;
					var cx_ = this.ax;
					var cy_ = this.ay;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
				}
			} else if(clockWise) {
				var ax_ = this.dxOld;
				var ay_ = this.dyOld;
				var bx_ = this.exPrev;
				var by_ = this.eyPrev;
				var cx_ = this.jx;
				var cy_ = this.jy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,A,A,C);
			} else {
				var ax_ = this.exOld;
				var ay_ = this.eyOld;
				var bx_ = this.dxPrev;
				var by_ = this.dyPrev;
				var cx_ = this.jx;
				var cy_ = this.jy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
			}
		}
		this.kax = this.dxPrev;
		this.kay = this.dyPrev;
		this.kbx = this.dx;
		this.kby = this.dy;
		this.ncx = this.exPrev;
		this.ncy = this.eyPrev;
		this.kcx = this.ex;
		this.kcy = this.ey;
		if(curveEnds && !overlap && this.count != 0) {
			if(clockWise) {
				var ax_ = this.ax;
				var ay_ = this.ay;
				var bx_ = this.dxOld;
				var by_ = this.dyOld;
				var cx_ = this.jx;
				var cy_ = this.jy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var c0 = col.colorAnti;
				var c1 = col.colorClock;
				var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
				var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
				var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
				var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
				var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,half,col.colorClock,col.colorAnti);
				var ax_ = this.ax;
				var ay_ = this.ay;
				var bx_ = this.exPrev;
				var by_ = this.eyPrev;
				var cx_ = this.jx;
				var cy_ = this.jy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var c0 = col.colorAnti;
				var c1 = col.colorClock;
				var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
				var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
				var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
				var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
				var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,half,col.colorAnti,col.colorClock);
			} else {
				var ax_ = this.ax;
				var ay_ = this.ay;
				var bx_ = this.exOld;
				var by_ = this.eyOld;
				var cx_ = this.jx;
				var cy_ = this.jy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var c0 = col.colorAnti;
				var c1 = col.colorClock;
				var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
				var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
				var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
				var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
				var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,half,col.colorClock,col.colorAnti);
				var ax_ = this.ax;
				var ay_ = this.ay;
				var bx_ = this.dxPrev;
				var by_ = this.dyPrev;
				var cx_ = this.jx;
				var cy_ = this.jy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var c0 = col.colorAnti;
				var c1 = col.colorClock;
				var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
				var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
				var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
				var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
				var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,half,col.colorAnti,col.colorClock);
			}
		}
		this.jxOld = this.jx;
		this.jyOld = this.jy;
		this.lastClock = clockWise;
		this.count++;
	}
	,overlapQuad: function() {
		var ax_ = this.dxPrev;
		var ay_ = this.dyPrev;
		var bx_ = this.dx;
		var by_ = this.dy;
		var cx_ = this.ex;
		var cy_ = this.ey;
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var C = col.colorClock;
		var A = col.colorAnti;
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
		var ax_ = this.dxPrev;
		var ay_ = this.dyPrev;
		var bx_ = this.dx;
		var by_ = this.dy;
		var cx_ = this.exPrev;
		var cy_ = this.eyPrev;
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var C = col.colorClock;
		var A = col.colorAnti;
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
	}
	,end: function(width_) {
		this.endEdges();
		if(this.count != 0 && (this.endLine == 2 || this.endLine == 3 || this.endLine == 7 || this.endLine == 8 || this.endLine == 11 || this.endLine == 10 || this.endLine == 16 || this.endLine == 17 || this.endLine == 13 || this.endLine == 14 || this.endLine == 19 || this.endLine == 20)) {
			var ax = this.bx;
			var ay = this.by;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var temp = [];
			var clockwiseTemp = false;
			var ax1 = ax;
			var ay1 = ay;
			var radius = width_ / 2;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL_OLD._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = this.endLine == 5 ? Math.ceil(Math.abs(dif) / (step / 2)) : Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var beta2 = 0.;
			var this1 = this.endLine;
			if(this1 == 19 || this1 == 20) {
				angle = Math.PI / 2;
				beta2 = 2 * Math.PI - beta + Math.PI / 2;
			}
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var p2 = temp.length;
			var col = this.getGradColors();
			var c0 = col.colorAnti;
			var c1 = col.colorClock;
			var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
			var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
			var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
			var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
			var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
			var dx = ax1 + radius * Math.sin(angle);
			var dy = ay1 + radius * Math.cos(angle);
			var ex = 0.;
			var ey = 0.;
			var fx = 0.;
			var fy = 0.;
			var gx = 0.;
			var gy = 0.;
			var delta = 0.;
			var this1 = this.endLine;
			if(this1 == 13 || this1 == 14) {
				var angle2 = beta - step * totalSteps / 2;
				fx = ax1 - 0.75 * this.endCapFactor * radius * Math.sin(angle2);
				fy = ay1 - 0.75 * this.endCapFactor * radius * Math.cos(angle2);
				radius *= 2;
				delta = Math.pow(radius / 2,2);
			}
			var this1 = this.endLine;
			if(!(this1 == 7 || this1 == 8 || (this1 == 10 || this1 == 11) || (this1 == 16 || this1 == 17))) {
				if(this.endLine == 5) {
					var angle2 = beta - 2 * step * totalSteps;
					ax1 += radius * Math.sin(angle2);
					ay1 += radius * Math.cos(angle2);
					radius *= 2;
				}
				if(this.endLine == 5) {
					half = col.colorAnti;
				}
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					var this1 = this.endLine;
					if(this1 == 13 || this1 == 14) {
						cx = fx + 0.5 * this.endCapFactor * radius * Math.sin(angle);
						cy = fy + 0.5 * this.endCapFactor * radius * Math.cos(angle);
						ex = fx - 0.5 * this.endCapFactor * radius * Math.sin(angle);
						ey = fy - 0.5 * this.endCapFactor * radius * Math.cos(angle);
					} else {
						var this2 = this.endLine;
						if(this2 == 19 || this2 == 20) {
							var ry = this.endCapFactor * radius;
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + ry * Math.cos(angle);
							var cos = Math.cos(beta2);
							var sin = Math.sin(beta2);
							cx -= ax1;
							cy -= ay1;
							var ccx = cx;
							var ccy = cy;
							cx = ccx * cos - ccy * sin;
							cy = ccx * sin + ccy * cos;
							cx += ax1;
							cy += ay1;
						} else {
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + radius * Math.cos(angle);
						}
					}
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						if(!clockwiseTemp) {
							var second;
							if(this.endLine == 4) {
								var c0 = col.colorAnti;
								var c1 = col.colorClock;
								var t = 0.5 * i / totalSteps;
								if(t == null) {
									t = 0.5;
								}
								var t0 = t;
								if(t0 == null) {
									t0 = 0.5;
								}
								var t1 = 1. - t0;
								var a = t0 * ((c0 >> 24 & 255) / 255) + t1 * ((c1 >> 24 & 255) / 255);
								var t01 = t;
								if(t01 == null) {
									t01 = 0.5;
								}
								var t11 = 1. - t01;
								var r = t01 * ((c0 >> 16 & 255) / 255) + t11 * ((c1 >> 16 & 255) / 255);
								var t02 = t;
								if(t02 == null) {
									t02 = 0.5;
								}
								var t12 = 1. - t02;
								var g = t02 * ((c0 >> 8 & 255) / 255) + t12 * ((c1 >> 8 & 255) / 255);
								var t03 = t;
								if(t03 == null) {
									t03 = 0.5;
								}
								var t13 = 1. - t03;
								var b = t03 * ((c0 & 255) / 255) + t13 * ((c1 & 255) / 255);
								second = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
							} else {
								var c01 = col.colorAnti;
								var c11 = col.colorClock;
								var t2 = i / totalSteps;
								if(t2 == null) {
									t2 = 0.5;
								}
								var t04 = t2;
								if(t04 == null) {
									t04 = 0.5;
								}
								var t14 = 1. - t04;
								var a1 = t04 * ((c01 >> 24 & 255) / 255) + t14 * ((c11 >> 24 & 255) / 255);
								var t05 = t2;
								if(t05 == null) {
									t05 = 0.5;
								}
								var t15 = 1. - t05;
								var r1 = t05 * ((c01 >> 16 & 255) / 255) + t15 * ((c11 >> 16 & 255) / 255);
								var t06 = t2;
								if(t06 == null) {
									t06 = 0.5;
								}
								var t16 = 1. - t06;
								var g1 = t06 * ((c01 >> 8 & 255) / 255) + t16 * ((c11 >> 8 & 255) / 255);
								var t07 = t2;
								if(t07 == null) {
									t07 = 0.5;
								}
								var t17 = 1. - t07;
								var b1 = t07 * ((c01 & 255) / 255) + t17 * ((c11 & 255) / 255);
								second = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
							}
							var this3 = this.endLine;
							if(this3 == 13 || this3 == 14) {
								var deltaG = Math.pow(ay1 - gy,2) + Math.pow(ax1 - gx,2);
								var deltaE = Math.pow(ay1 - ey,2) + Math.pow(ax1 - ex,2);
								if(deltaE > delta || deltaG > delta) {
									var second2 = i / totalSteps > 0.5 ? col.colorClock : col.colorAnti;
									this.pen.triangle2DGrad(ax1,ay1,gx,gy,ex,ey,half,second2,second2);
								}
							}
							this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second,second);
						} else {
							var c02 = col.colorAnti;
							var c12 = col.colorClock;
							var t3 = 1 - i / totalSteps;
							if(t3 == null) {
								t3 = 0.5;
							}
							var t08 = t3;
							if(t08 == null) {
								t08 = 0.5;
							}
							var t18 = 1. - t08;
							var a2 = t08 * ((c02 >> 24 & 255) / 255) + t18 * ((c12 >> 24 & 255) / 255);
							var t09 = t3;
							if(t09 == null) {
								t09 = 0.5;
							}
							var t19 = 1. - t09;
							var r2 = t09 * ((c02 >> 16 & 255) / 255) + t19 * ((c12 >> 16 & 255) / 255);
							var t010 = t3;
							if(t010 == null) {
								t010 = 0.5;
							}
							var t110 = 1. - t010;
							var g2 = t010 * ((c02 >> 8 & 255) / 255) + t110 * ((c12 >> 8 & 255) / 255);
							var t011 = t3;
							if(t011 == null) {
								t011 = 0.5;
							}
							var t111 = 1. - t011;
							var b2 = t011 * ((c02 & 255) / 255) + t111 * ((c12 & 255) / 255);
							var second1 = Math.round(a2 * 255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
							var this4 = this.endLine;
							if(this4 == 13 || this4 == 14) {
								var deltaG1 = Math.pow(ay1 - gy,2) + Math.pow(ax1 - gx,2);
								var deltaE1 = Math.pow(ay1 - ey,2) + Math.pow(ax1 - ex,2);
								if(deltaE1 > delta || deltaG1 > delta) {
									var second21 = 1 - i / totalSteps > 0.5 ? col.colorClock : col.colorAnti;
									this.pen.triangle2DGrad(ax1,ay1,gx,gy,ex,ey,half,second21,second21);
								}
							}
							this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second1,second1);
						}
					}
					angle += step;
					bx = cx;
					by = cy;
					var this5 = this.endLine;
					if(this5 == 13 || this5 == 14) {
						gx = ex;
						gy = ey;
					}
				}
				if(this.endLine == 4) {
					angle = angle + step * totalSteps / 2 - step;
					cx = ax1 + radius * Math.sin(angle) * Math.sqrt(2);
					cy = ay1 + radius * Math.cos(angle) * Math.sqrt(2);
					this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,col.colorAnti,half);
					bx = cx;
					by = cy;
					angle += step * (totalSteps / 2);
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,col.colorAnti,col.colorAnti);
					totalSteps += 2;
				}
			} else {
				var this1 = this.endLine;
				if(this1 == 10 || this1 == 11) {
					angle = beta;
					var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 + radius * this.endCapFactor * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,half,col.colorClock);
				} else {
					var this1 = this.endLine;
					if(this1 == 7 || this1 == 8) {
						angle = beta;
						var dx = ax1 - radius * Math.sin(angle);
						var dy = ay1 - radius * Math.cos(angle);
						angle = beta - step * totalSteps / 2;
						cx = ax1 - radius * Math.sin(angle);
						cy = ay1 - radius * Math.cos(angle);
						this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
						bx = cx;
						by = cy;
						angle += step * totalSteps / 2;
						cx = ax1 + radius * Math.sin(angle);
						cy = ay1 + radius * Math.cos(angle);
						this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,half,col.colorClock);
					} else {
						var this1 = this.endLine;
						if(this1 == 16 || this1 == 17) {
							angle = beta;
							var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
							var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
							angle = beta - step * totalSteps / 2;
							cx = dx - 2 * radius * this.endCapFactor * Math.sin(angle);
							cy = dy - 2 * radius * this.endCapFactor * Math.cos(angle);
							var lastAngle = angle;
							angle += step * totalSteps / 2;
							ex = ax1 + radius * this.endCapFactor * Math.sin(angle);
							ey = ay1 + radius * this.endCapFactor * Math.cos(angle);
							fx = ex - 2 * radius * this.endCapFactor * Math.sin(lastAngle);
							fy = ey - 2 * radius * this.endCapFactor * Math.cos(lastAngle);
							this.pen.triangle2DGrad(fx,fy,cx,cy,dx,dy,col.colorClock,col.colorAnti,col.colorAnti);
							this.pen.triangle2DGrad(fx,fy,dx,dy,ex,ey,col.colorClock,col.colorClock,col.colorAnti);
						}
					}
				}
				totalSteps += 2;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var _g = 0;
			var _g1 = len + 2;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[i];
			}
			var pC = this.pointsClock.length;
			var _g = 1;
			var _g1 = len / 2 + 1 | 0;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[temp.length - 2 * i];
				this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
			}
		}
		if(this.count != 0 && (this.endLine == 4 || this.endLine == 5)) {
			var ax = this.bx;
			var ay = this.by;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI / 2;
			var temp = [];
			var clockwiseTemp = false;
			var ax1 = ax;
			var ay1 = ay;
			var radius = width_ / 2;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL_OLD._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = this.endLine == 5 ? Math.ceil(Math.abs(dif) / (step / 2)) : Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var beta2 = 0.;
			var this1 = this.endLine;
			if(this1 == 19 || this1 == 20) {
				angle = Math.PI / 2;
				beta2 = 2 * Math.PI - beta + Math.PI / 2;
			}
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var p2 = temp.length;
			var col = this.getGradColors();
			var c0 = col.colorAnti;
			var c1 = col.colorClock;
			var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
			var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
			var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
			var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
			var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
			var dx = ax1 + radius * Math.sin(angle);
			var dy = ay1 + radius * Math.cos(angle);
			var ex = 0.;
			var ey = 0.;
			var fx = 0.;
			var fy = 0.;
			var gx = 0.;
			var gy = 0.;
			var delta = 0.;
			var this1 = this.endLine;
			if(this1 == 13 || this1 == 14) {
				var angle2 = beta - step * totalSteps / 2;
				fx = ax1 - 0.75 * this.endCapFactor * radius * Math.sin(angle2);
				fy = ay1 - 0.75 * this.endCapFactor * radius * Math.cos(angle2);
				radius *= 2;
				delta = Math.pow(radius / 2,2);
			}
			var this1 = this.endLine;
			if(!(this1 == 7 || this1 == 8 || (this1 == 10 || this1 == 11) || (this1 == 16 || this1 == 17))) {
				if(this.endLine == 5) {
					var angle2 = beta - 2 * step * totalSteps;
					ax1 += radius * Math.sin(angle2);
					ay1 += radius * Math.cos(angle2);
					radius *= 2;
				}
				if(this.endLine == 5) {
					half = col.colorAnti;
				}
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					var this1 = this.endLine;
					if(this1 == 13 || this1 == 14) {
						cx = fx + 0.5 * this.endCapFactor * radius * Math.sin(angle);
						cy = fy + 0.5 * this.endCapFactor * radius * Math.cos(angle);
						ex = fx - 0.5 * this.endCapFactor * radius * Math.sin(angle);
						ey = fy - 0.5 * this.endCapFactor * radius * Math.cos(angle);
					} else {
						var this2 = this.endLine;
						if(this2 == 19 || this2 == 20) {
							var ry = this.endCapFactor * radius;
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + ry * Math.cos(angle);
							var cos = Math.cos(beta2);
							var sin = Math.sin(beta2);
							cx -= ax1;
							cy -= ay1;
							var ccx = cx;
							var ccy = cy;
							cx = ccx * cos - ccy * sin;
							cy = ccx * sin + ccy * cos;
							cx += ax1;
							cy += ay1;
						} else {
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + radius * Math.cos(angle);
						}
					}
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						if(!clockwiseTemp) {
							var second;
							if(this.endLine == 4) {
								var c0 = col.colorAnti;
								var c1 = col.colorClock;
								var t = 0.5 * i / totalSteps;
								if(t == null) {
									t = 0.5;
								}
								var t0 = t;
								if(t0 == null) {
									t0 = 0.5;
								}
								var t1 = 1. - t0;
								var a = t0 * ((c0 >> 24 & 255) / 255) + t1 * ((c1 >> 24 & 255) / 255);
								var t01 = t;
								if(t01 == null) {
									t01 = 0.5;
								}
								var t11 = 1. - t01;
								var r = t01 * ((c0 >> 16 & 255) / 255) + t11 * ((c1 >> 16 & 255) / 255);
								var t02 = t;
								if(t02 == null) {
									t02 = 0.5;
								}
								var t12 = 1. - t02;
								var g = t02 * ((c0 >> 8 & 255) / 255) + t12 * ((c1 >> 8 & 255) / 255);
								var t03 = t;
								if(t03 == null) {
									t03 = 0.5;
								}
								var t13 = 1. - t03;
								var b = t03 * ((c0 & 255) / 255) + t13 * ((c1 & 255) / 255);
								second = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
							} else {
								var c01 = col.colorAnti;
								var c11 = col.colorClock;
								var t2 = i / totalSteps;
								if(t2 == null) {
									t2 = 0.5;
								}
								var t04 = t2;
								if(t04 == null) {
									t04 = 0.5;
								}
								var t14 = 1. - t04;
								var a1 = t04 * ((c01 >> 24 & 255) / 255) + t14 * ((c11 >> 24 & 255) / 255);
								var t05 = t2;
								if(t05 == null) {
									t05 = 0.5;
								}
								var t15 = 1. - t05;
								var r1 = t05 * ((c01 >> 16 & 255) / 255) + t15 * ((c11 >> 16 & 255) / 255);
								var t06 = t2;
								if(t06 == null) {
									t06 = 0.5;
								}
								var t16 = 1. - t06;
								var g1 = t06 * ((c01 >> 8 & 255) / 255) + t16 * ((c11 >> 8 & 255) / 255);
								var t07 = t2;
								if(t07 == null) {
									t07 = 0.5;
								}
								var t17 = 1. - t07;
								var b1 = t07 * ((c01 & 255) / 255) + t17 * ((c11 & 255) / 255);
								second = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
							}
							var this3 = this.endLine;
							if(this3 == 13 || this3 == 14) {
								var deltaG = Math.pow(ay1 - gy,2) + Math.pow(ax1 - gx,2);
								var deltaE = Math.pow(ay1 - ey,2) + Math.pow(ax1 - ex,2);
								if(deltaE > delta || deltaG > delta) {
									var second2 = i / totalSteps > 0.5 ? col.colorClock : col.colorAnti;
									this.pen.triangle2DGrad(ax1,ay1,gx,gy,ex,ey,half,second2,second2);
								}
							}
							this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second,second);
						} else {
							var c02 = col.colorAnti;
							var c12 = col.colorClock;
							var t3 = 1 - i / totalSteps;
							if(t3 == null) {
								t3 = 0.5;
							}
							var t08 = t3;
							if(t08 == null) {
								t08 = 0.5;
							}
							var t18 = 1. - t08;
							var a2 = t08 * ((c02 >> 24 & 255) / 255) + t18 * ((c12 >> 24 & 255) / 255);
							var t09 = t3;
							if(t09 == null) {
								t09 = 0.5;
							}
							var t19 = 1. - t09;
							var r2 = t09 * ((c02 >> 16 & 255) / 255) + t19 * ((c12 >> 16 & 255) / 255);
							var t010 = t3;
							if(t010 == null) {
								t010 = 0.5;
							}
							var t110 = 1. - t010;
							var g2 = t010 * ((c02 >> 8 & 255) / 255) + t110 * ((c12 >> 8 & 255) / 255);
							var t011 = t3;
							if(t011 == null) {
								t011 = 0.5;
							}
							var t111 = 1. - t011;
							var b2 = t011 * ((c02 & 255) / 255) + t111 * ((c12 & 255) / 255);
							var second1 = Math.round(a2 * 255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
							var this4 = this.endLine;
							if(this4 == 13 || this4 == 14) {
								var deltaG1 = Math.pow(ay1 - gy,2) + Math.pow(ax1 - gx,2);
								var deltaE1 = Math.pow(ay1 - ey,2) + Math.pow(ax1 - ex,2);
								if(deltaE1 > delta || deltaG1 > delta) {
									var second21 = 1 - i / totalSteps > 0.5 ? col.colorClock : col.colorAnti;
									this.pen.triangle2DGrad(ax1,ay1,gx,gy,ex,ey,half,second21,second21);
								}
							}
							this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second1,second1);
						}
					}
					angle += step;
					bx = cx;
					by = cy;
					var this5 = this.endLine;
					if(this5 == 13 || this5 == 14) {
						gx = ex;
						gy = ey;
					}
				}
				if(this.endLine == 4) {
					angle = angle + step * totalSteps / 2 - step;
					cx = ax1 + radius * Math.sin(angle) * Math.sqrt(2);
					cy = ay1 + radius * Math.cos(angle) * Math.sqrt(2);
					this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,col.colorAnti,half);
					bx = cx;
					by = cy;
					angle += step * (totalSteps / 2);
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,col.colorAnti,col.colorAnti);
					totalSteps += 2;
				}
			} else {
				var this1 = this.endLine;
				if(this1 == 10 || this1 == 11) {
					angle = beta;
					var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 + radius * this.endCapFactor * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,half,col.colorClock);
				} else {
					var this1 = this.endLine;
					if(this1 == 7 || this1 == 8) {
						angle = beta;
						var dx = ax1 - radius * Math.sin(angle);
						var dy = ay1 - radius * Math.cos(angle);
						angle = beta - step * totalSteps / 2;
						cx = ax1 - radius * Math.sin(angle);
						cy = ay1 - radius * Math.cos(angle);
						this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
						bx = cx;
						by = cy;
						angle += step * totalSteps / 2;
						cx = ax1 + radius * Math.sin(angle);
						cy = ay1 + radius * Math.cos(angle);
						this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,half,col.colorClock);
					} else {
						var this1 = this.endLine;
						if(this1 == 16 || this1 == 17) {
							angle = beta;
							var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
							var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
							angle = beta - step * totalSteps / 2;
							cx = dx - 2 * radius * this.endCapFactor * Math.sin(angle);
							cy = dy - 2 * radius * this.endCapFactor * Math.cos(angle);
							var lastAngle = angle;
							angle += step * totalSteps / 2;
							ex = ax1 + radius * this.endCapFactor * Math.sin(angle);
							ey = ay1 + radius * this.endCapFactor * Math.cos(angle);
							fx = ex - 2 * radius * this.endCapFactor * Math.sin(lastAngle);
							fy = ey - 2 * radius * this.endCapFactor * Math.cos(lastAngle);
							this.pen.triangle2DGrad(fx,fy,cx,cy,dx,dy,col.colorClock,col.colorAnti,col.colorAnti);
							this.pen.triangle2DGrad(fx,fy,dx,dy,ex,ey,col.colorClock,col.colorClock,col.colorAnti);
						}
					}
				}
				totalSteps += 2;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var _g = 0;
			var _g1 = len + 2;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[i];
			}
			var pC = this.pointsClock.length;
			var _g = 1;
			var _g1 = len / 2 + 1 | 0;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[temp.length - 2 * i];
				this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
			}
		}
	}
	,triangle2DFill: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var C = col.colorClock;
		var A = col.colorAnti;
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
	}
	,tri2DFill_A_C_C: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var C = col.colorClock;
		var A = col.colorAnti;
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,A,C,C);
	}
	,tri2DFill_C_A_C: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var C = col.colorClock;
		var A = col.colorAnti;
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
	}
	,tri2DFill_C_C_A: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var C = col.colorClock;
		var A = col.colorAnti;
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,C,A);
	}
	,tri2DFill_A_A_C: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var C = col.colorClock;
		var A = col.colorAnti;
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,A,A,C);
	}
	,tri2DFill_C_A_A: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var C = col.colorClock;
		var A = col.colorAnti;
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
	}
	,tri2DFill_A_C_A: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var C = col.colorClock;
		var A = col.colorAnti;
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,A,C,A);
	}
	,tri2DFill_A_h_C: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var c0 = col.colorAnti;
		var c1 = col.colorClock;
		var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
		var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
		var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
		var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
		var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,col.colorAnti,half,col.colorClock);
	}
	,tri2DFill_A_C_h: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var c0 = col.colorAnti;
		var c1 = col.colorClock;
		var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
		var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
		var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
		var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
		var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,col.colorAnti,col.colorClock,half);
	}
	,tri2DFill_C_A_h: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var c0 = col.colorAnti;
		var c1 = col.colorClock;
		var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
		var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
		var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
		var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
		var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,col.colorClock,col.colorAnti,half);
	}
	,tri2DFill_C_h_A: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var c0 = col.colorAnti;
		var c1 = col.colorClock;
		var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
		var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
		var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
		var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
		var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,col.colorClock,half,col.colorAnti);
	}
	,tri2DFill_h_C_A: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var c0 = col.colorAnti;
		var c1 = col.colorClock;
		var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
		var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
		var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
		var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
		var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,half,col.colorClock,col.colorAnti);
	}
	,tri2DFill_h_A_C: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var c0 = col.colorAnti;
		var c1 = col.colorClock;
		var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
		var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
		var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
		var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
		var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,half,col.colorAnti,col.colorClock);
	}
	,tri2DFill_h_A_A: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var c0 = col.colorAnti;
		var c1 = col.colorClock;
		var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
		var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
		var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
		var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
		var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,half,col.colorAnti,col.colorAnti);
	}
	,tri2DFill_h_C_C: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var c0 = col.colorAnti;
		var c1 = col.colorClock;
		var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
		var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
		var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
		var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
		var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,half,col.colorClock,col.colorClock);
	}
	,tri2DFill_A_h_A: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var c0 = col.colorAnti;
		var c1 = col.colorClock;
		var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
		var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
		var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
		var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
		var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,col.colorAnti,half,col.colorAnti);
	}
	,tri2DFill_C_h_C: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var c0 = col.colorAnti;
		var c1 = col.colorClock;
		var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
		var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
		var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
		var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
		var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,col.colorClock,half,col.colorClock);
	}
	,tri2DFill_A_A_h: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var c0 = col.colorAnti;
		var c1 = col.colorClock;
		var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
		var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
		var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
		var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
		var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,col.colorAnti,col.colorAnti,half);
	}
	,tri2DFill_C_C_h: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var c0 = col.colorAnti;
		var c1 = col.colorClock;
		var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
		var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
		var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
		var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
		var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,col.colorClock,col.colorClock,half);
	}
	,triangle2DFillRGB: function(ax_,ay_,bx_,by_,cx_,cy_,color_) {
		if(color_ == null) {
			color_ = -1;
		}
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var red = -65536;
		var blue = -16711936;
		var green = -16776961;
		this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,red,green,blue);
	}
	,addStartShape: function(ax,ay,radius,beta,gamma,prefer,mark,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(mark == null) {
			mark = -1;
		}
		var temp = [];
		var clockwiseTemp = false;
		var ax1 = ax;
		var ay1 = ay;
		var radius1 = radius;
		var color = mark;
		var sides1 = sides;
		if(sides1 == null) {
			sides1 = 36;
		}
		var pi = Math.PI;
		var step = pi * 2 / sides1;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var smallest = theta <= Math.PI;
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = this.endLine == 5 ? Math.ceil(Math.abs(dif) / (step / 2)) : Math.ceil(Math.abs(dif) / step);
		var step = dif / totalSteps;
		var angle = beta;
		var beta2 = 0.;
		var this1 = this.endLine;
		if(this1 == 18 || this1 == 20) {
			angle = Math.PI / 2;
			beta2 = 2 * Math.PI - beta + Math.PI / 2;
		}
		var cx = 0;
		var cy = 0;
		var bx = 0;
		var by = 0;
		var p2 = temp.length;
		var col = this.getGradColors();
		var c0 = col.colorAnti;
		var c1 = col.colorClock;
		var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
		var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
		var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
		var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
		var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		var dx = ax1 + radius1 * Math.sin(angle);
		var dy = ay1 + radius1 * Math.cos(angle);
		var ex = 0.;
		var ey = 0.;
		var fx = 0.;
		var fy = 0.;
		var gx = 0.;
		var gy = 0.;
		var delta = 0.;
		var this1 = this.endLine;
		if(this1 == 12 || this1 == 14) {
			var angle2 = beta - step * totalSteps / 2;
			fx = ax1 - 0.75 * this.endCapFactor * radius1 * Math.sin(angle2);
			fy = ay1 - 0.75 * this.endCapFactor * radius1 * Math.cos(angle2);
			radius1 *= 2;
			delta = Math.pow(radius1 / 2,2);
		}
		var this1 = this.endLine;
		if(!(this1 == 6 || this1 == 8 || (this1 == 9 || this1 == 11) || (this1 == 15 || this1 == 17))) {
			if(this.endLine == 5) {
				var angle2 = beta - 2 * step * totalSteps;
				ax1 += radius1 * Math.sin(angle2);
				ay1 += radius1 * Math.cos(angle2);
				radius1 *= 2;
			}
			if(this.endLine == 5) {
				half = col.colorAnti;
			}
			var beta2 = 2 * Math.PI - beta + Math.PI / 2;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				var this1 = this.endLine;
				if(this1 == 12 || this1 == 14) {
					cx = fx + 0.5 * this.endCapFactor * radius1 * Math.sin(angle);
					cy = fy + 0.5 * this.endCapFactor * radius1 * Math.cos(angle);
					ex = fx - 0.5 * this.endCapFactor * radius1 * Math.sin(angle);
					ey = fy - 0.5 * this.endCapFactor * radius1 * Math.cos(angle);
				} else {
					var this2 = this.endLine;
					if(this2 == 18 || this2 == 20) {
						var ry = this.endCapFactor * radius1;
						cx = ax1 + radius1 * Math.sin(angle);
						cy = ay1 + ry * Math.cos(angle);
						var cos = Math.cos(beta2);
						var sin = Math.sin(beta2);
						cx -= ax1;
						cy -= ay1;
						var ccx = cx;
						var ccy = cy;
						cx = ccx * cos - ccy * sin;
						cy = ccx * sin + ccy * cos;
						cx += ax1;
						cy += ay1;
					} else {
						cx = ax1 + radius1 * Math.sin(angle);
						cy = ay1 + radius1 * Math.cos(angle);
					}
				}
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					if(!clockwiseTemp) {
						var second;
						if(this.endLine == 4) {
							var c0 = col.colorAnti;
							var c1 = col.colorClock;
							var t = 0.5 * i / totalSteps;
							if(t == null) {
								t = 0.5;
							}
							var t0 = t;
							if(t0 == null) {
								t0 = 0.5;
							}
							var t1 = 1. - t0;
							var a = t0 * ((c0 >> 24 & 255) / 255) + t1 * ((c1 >> 24 & 255) / 255);
							var t01 = t;
							if(t01 == null) {
								t01 = 0.5;
							}
							var t11 = 1. - t01;
							var r = t01 * ((c0 >> 16 & 255) / 255) + t11 * ((c1 >> 16 & 255) / 255);
							var t02 = t;
							if(t02 == null) {
								t02 = 0.5;
							}
							var t12 = 1. - t02;
							var g = t02 * ((c0 >> 8 & 255) / 255) + t12 * ((c1 >> 8 & 255) / 255);
							var t03 = t;
							if(t03 == null) {
								t03 = 0.5;
							}
							var t13 = 1. - t03;
							var b = t03 * ((c0 & 255) / 255) + t13 * ((c1 & 255) / 255);
							second = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
						} else {
							var c01 = col.colorAnti;
							var c11 = col.colorClock;
							var t2 = i / totalSteps;
							if(t2 == null) {
								t2 = 0.5;
							}
							var t04 = t2;
							if(t04 == null) {
								t04 = 0.5;
							}
							var t14 = 1. - t04;
							var a1 = t04 * ((c01 >> 24 & 255) / 255) + t14 * ((c11 >> 24 & 255) / 255);
							var t05 = t2;
							if(t05 == null) {
								t05 = 0.5;
							}
							var t15 = 1. - t05;
							var r1 = t05 * ((c01 >> 16 & 255) / 255) + t15 * ((c11 >> 16 & 255) / 255);
							var t06 = t2;
							if(t06 == null) {
								t06 = 0.5;
							}
							var t16 = 1. - t06;
							var g1 = t06 * ((c01 >> 8 & 255) / 255) + t16 * ((c11 >> 8 & 255) / 255);
							var t07 = t2;
							if(t07 == null) {
								t07 = 0.5;
							}
							var t17 = 1. - t07;
							var b1 = t07 * ((c01 & 255) / 255) + t17 * ((c11 & 255) / 255);
							second = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
						}
						var this3 = this.endLine;
						if(this3 == 12 || this3 == 14) {
							var deltaG = Math.pow(ay1 - gy,2) + Math.pow(ax1 - gx,2);
							var deltaE = Math.pow(ay1 - ey,2) + Math.pow(ax1 - ex,2);
							if(deltaE > delta || deltaG > delta) {
								var second2 = i / totalSteps > 0.5 ? col.colorClock : col.colorAnti;
								this.pen.triangle2DGrad(ax1,ay1,gx,gy,ex,ey,half,second2,second2);
							}
						}
						this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second,second);
					} else {
						var c02 = col.colorAnti;
						var c12 = col.colorClock;
						var t3 = 1 - i / totalSteps;
						if(t3 == null) {
							t3 = 0.5;
						}
						var t08 = t3;
						if(t08 == null) {
							t08 = 0.5;
						}
						var t18 = 1. - t08;
						var a2 = t08 * ((c02 >> 24 & 255) / 255) + t18 * ((c12 >> 24 & 255) / 255);
						var t09 = t3;
						if(t09 == null) {
							t09 = 0.5;
						}
						var t19 = 1. - t09;
						var r2 = t09 * ((c02 >> 16 & 255) / 255) + t19 * ((c12 >> 16 & 255) / 255);
						var t010 = t3;
						if(t010 == null) {
							t010 = 0.5;
						}
						var t110 = 1. - t010;
						var g2 = t010 * ((c02 >> 8 & 255) / 255) + t110 * ((c12 >> 8 & 255) / 255);
						var t011 = t3;
						if(t011 == null) {
							t011 = 0.5;
						}
						var t111 = 1. - t011;
						var b2 = t011 * ((c02 & 255) / 255) + t111 * ((c12 & 255) / 255);
						var second1 = Math.round(a2 * 255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
						var this4 = this.endLine;
						if(this4 == 12 || this4 == 14) {
							var deltaG1 = Math.pow(ay1 - gy,2) + Math.pow(ax1 - gx,2);
							var deltaE1 = Math.pow(ay1 - ey,2) + Math.pow(ax1 - ex,2);
							if(deltaE1 > delta || deltaG1 > delta) {
								var second21 = 1 - i / totalSteps > 0.5 ? col.colorClock : col.colorAnti;
								this.pen.triangle2DGrad(ax1,ay1,gx,gy,ex,ey,half,second21,second21);
							}
						}
						this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second1,second1);
					}
				}
				angle += step;
				bx = cx;
				by = cy;
				var this5 = this.endLine;
				if(this5 == 12 || this5 == 14) {
					gx = ex;
					gy = ey;
				}
			}
			if(this.endLine == 4) {
				angle = angle + step * totalSteps / 2 - step;
				cx = ax1 + radius1 * Math.sin(angle) * Math.sqrt(2);
				cy = ay1 + radius1 * Math.cos(angle) * Math.sqrt(2);
				this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,half,col.colorAnti);
				bx = cx;
				by = cy;
				angle += step * (totalSteps / 2);
				cx = ax1 + radius1 * Math.sin(angle);
				cy = ay1 + radius1 * Math.cos(angle);
				this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,col.colorAnti,col.colorAnti);
				totalSteps += 2;
			}
		} else {
			var this1 = this.endLine;
			if(this1 == 9 || this1 == 11) {
				angle = beta;
				var dx = ax1 - radius1 * this.endCapFactor * Math.sin(angle);
				var dy = ay1 - radius1 * this.endCapFactor * Math.cos(angle);
				angle = beta - step * totalSteps / 2;
				cx = ax1 - radius1 * this.endCapFactor * Math.sin(angle);
				cy = ay1 - radius1 * this.endCapFactor * Math.cos(angle);
				this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
				bx = cx;
				by = cy;
				angle += step * totalSteps / 2;
				cx = ax1 + radius1 * this.endCapFactor * Math.sin(angle);
				cy = ay1 + radius1 * this.endCapFactor * Math.cos(angle);
				this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,col.colorClock,half);
			} else {
				var this1 = this.endLine;
				if(this1 == 6 || this1 == 8) {
					angle = beta;
					var dx = ax1 - radius1 * Math.sin(angle);
					var dy = ay1 - radius1 * Math.cos(angle);
					angle = beta + step * totalSteps / 2;
					cx = ax1 + radius1 * Math.sin(angle);
					cy = ay1 + radius1 * Math.cos(angle);
					this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
					bx = cx;
					by = cy;
					angle -= step * totalSteps / 2;
					cx = ax1 + radius1 * Math.sin(angle);
					cy = ay1 + radius1 * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,col.colorClock,half);
				} else {
					var this1 = this.endLine;
					if(this1 == 15 || this1 == 17) {
						angle = beta;
						var dx = ax1 - radius1 * this.endCapFactor * Math.sin(angle);
						var dy = ay1 - radius1 * this.endCapFactor * Math.cos(angle);
						angle = beta - step * totalSteps / 2;
						cx = dx - 2 * radius1 * this.endCapFactor * Math.sin(angle);
						cy = dy - 2 * radius1 * this.endCapFactor * Math.cos(angle);
						var lastAngle = angle;
						angle += step * totalSteps / 2;
						ex = ax1 + radius1 * this.endCapFactor * Math.sin(angle);
						ey = ay1 + radius1 * this.endCapFactor * Math.cos(angle);
						fx = ex - 2 * radius1 * this.endCapFactor * Math.sin(lastAngle);
						fy = ey - 2 * radius1 * this.endCapFactor * Math.cos(lastAngle);
						this.pen.triangle2DGrad(fx,fy,cx,cy,dx,dy,col.colorClock,col.colorAnti,col.colorAnti);
						this.pen.triangle2DGrad(fx,fy,dx,dy,ex,ey,col.colorClock,col.colorAnti,col.colorClock);
					}
				}
			}
			totalSteps += 2;
		}
		var pA = this.pointsAnti.length;
		var len = temp.length / 2 | 0;
		var p4 = temp.length / 4 | 0;
		var _g = 0;
		var _g1 = p4;
		while(_g < _g1) {
			var i = _g++;
			this.pointsAnti[pA++] = temp[len - 2 * i + 1];
			this.pointsAnti[pA++] = temp[len - 2 * i];
		}
		var pC = this.pointsClock.length;
		var _g = 0;
		var _g1 = p4;
		while(_g < _g1) {
			var i = _g++;
			this.pointsClock[pC++] = temp[i * 2 + len + 1];
			this.pointsClock[pC++] = temp[i * 2 + len];
		}
	}
	,addPieXstart: function(ax,ay,radius,beta,gamma,prefer,mark,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(mark == null) {
			mark = -1;
		}
		var temp = [];
		var clockwiseTemp = false;
		var color = mark;
		var sides1 = sides;
		if(sides1 == null) {
			sides1 = 36;
		}
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var step = pi * 2 / sides1;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var smallest = theta <= Math.PI;
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step = dif / totalSteps;
		var angle = beta;
		var cx = 0.;
		var cy = 0.;
		var bx = 0.;
		var by = 0.;
		var p2 = temp.length;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx = ax + radius * Math.sin(angle);
			cy = ay + radius * Math.cos(angle);
			temp[p2++] = cx;
			temp[p2++] = cy;
			if(i != 0) {
				if(!clockwiseTemp) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var c0 = col.colorAnti;
					var c1 = col.colorClock;
					var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
					var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
					var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
					var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
					var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
					this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,half,col.colorClock,col.colorClock);
				} else {
					var color_1 = color;
					var col1 = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var c01 = col1.colorAnti;
					var c11 = col1.colorClock;
					var a1 = ((c01 >> 24 & 255) / 255 + (c11 >> 24 & 255) / 255) / 2;
					var r1 = ((c01 >> 16 & 255) / 255 + (c11 >> 16 & 255) / 255) / 2;
					var g1 = ((c01 >> 8 & 255) / 255 + (c11 >> 8 & 255) / 255) / 2;
					var b1 = ((c01 & 255) / 255 + (c11 & 255) / 255) / 2;
					var half1 = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
					this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,half1,col1.colorAnti,col1.colorAnti);
				}
			}
			angle += step;
			bx = cx;
			by = cy;
		}
		var pA = this.pointsAnti.length;
		var len = temp.length / 2 | 0;
		var p4 = temp.length / 4 | 0;
		var _g = 0;
		var _g1 = p4;
		while(_g < _g1) {
			var i = _g++;
			this.pointsAnti[pA++] = temp[len - 2 * i + 1];
			this.pointsAnti[pA++] = temp[len - 2 * i];
		}
		var pC = this.pointsClock.length;
		var _g = 0;
		var _g1 = p4;
		while(_g < _g1) {
			var i = _g++;
			this.pointsClock[pC++] = temp[i * 2 + len + 1];
			this.pointsClock[pC++] = temp[i * 2 + len];
		}
	}
	,addEndShape: function(ax,ay,radius,beta,gamma,prefer,mark,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(mark == null) {
			mark = -1;
		}
		var temp = [];
		var clockwiseTemp = false;
		var ax1 = ax;
		var ay1 = ay;
		var radius1 = radius;
		var color = mark;
		var sides1 = sides;
		if(sides1 == null) {
			sides1 = 36;
		}
		var pi = Math.PI;
		var step = pi * 2 / sides1;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var smallest = theta <= Math.PI;
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = this.endLine == 5 ? Math.ceil(Math.abs(dif) / (step / 2)) : Math.ceil(Math.abs(dif) / step);
		var step = dif / totalSteps;
		var angle = beta;
		var beta2 = 0.;
		var this1 = this.endLine;
		if(this1 == 19 || this1 == 20) {
			angle = Math.PI / 2;
			beta2 = 2 * Math.PI - beta + Math.PI / 2;
		}
		var cx = 0.;
		var cy = 0.;
		var bx = 0.;
		var by = 0.;
		var p2 = temp.length;
		var col = this.getGradColors();
		var c0 = col.colorAnti;
		var c1 = col.colorClock;
		var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
		var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
		var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
		var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
		var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		var dx = ax1 + radius1 * Math.sin(angle);
		var dy = ay1 + radius1 * Math.cos(angle);
		var ex = 0.;
		var ey = 0.;
		var fx = 0.;
		var fy = 0.;
		var gx = 0.;
		var gy = 0.;
		var delta = 0.;
		var this1 = this.endLine;
		if(this1 == 13 || this1 == 14) {
			var angle2 = beta - step * totalSteps / 2;
			fx = ax1 - 0.75 * this.endCapFactor * radius1 * Math.sin(angle2);
			fy = ay1 - 0.75 * this.endCapFactor * radius1 * Math.cos(angle2);
			radius1 *= 2;
			delta = Math.pow(radius1 / 2,2);
		}
		var this1 = this.endLine;
		if(!(this1 == 7 || this1 == 8 || (this1 == 10 || this1 == 11) || (this1 == 16 || this1 == 17))) {
			if(this.endLine == 5) {
				var angle2 = beta - 2 * step * totalSteps;
				ax1 += radius1 * Math.sin(angle2);
				ay1 += radius1 * Math.cos(angle2);
				radius1 *= 2;
			}
			if(this.endLine == 5) {
				half = col.colorAnti;
			}
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				var this1 = this.endLine;
				if(this1 == 13 || this1 == 14) {
					cx = fx + 0.5 * this.endCapFactor * radius1 * Math.sin(angle);
					cy = fy + 0.5 * this.endCapFactor * radius1 * Math.cos(angle);
					ex = fx - 0.5 * this.endCapFactor * radius1 * Math.sin(angle);
					ey = fy - 0.5 * this.endCapFactor * radius1 * Math.cos(angle);
				} else {
					var this2 = this.endLine;
					if(this2 == 19 || this2 == 20) {
						var ry = this.endCapFactor * radius1;
						cx = ax1 + radius1 * Math.sin(angle);
						cy = ay1 + ry * Math.cos(angle);
						var cos = Math.cos(beta2);
						var sin = Math.sin(beta2);
						cx -= ax1;
						cy -= ay1;
						var ccx = cx;
						var ccy = cy;
						cx = ccx * cos - ccy * sin;
						cy = ccx * sin + ccy * cos;
						cx += ax1;
						cy += ay1;
					} else {
						cx = ax1 + radius1 * Math.sin(angle);
						cy = ay1 + radius1 * Math.cos(angle);
					}
				}
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					if(!clockwiseTemp) {
						var second;
						if(this.endLine == 4) {
							var c0 = col.colorAnti;
							var c1 = col.colorClock;
							var t = 0.5 * i / totalSteps;
							if(t == null) {
								t = 0.5;
							}
							var t0 = t;
							if(t0 == null) {
								t0 = 0.5;
							}
							var t1 = 1. - t0;
							var a = t0 * ((c0 >> 24 & 255) / 255) + t1 * ((c1 >> 24 & 255) / 255);
							var t01 = t;
							if(t01 == null) {
								t01 = 0.5;
							}
							var t11 = 1. - t01;
							var r = t01 * ((c0 >> 16 & 255) / 255) + t11 * ((c1 >> 16 & 255) / 255);
							var t02 = t;
							if(t02 == null) {
								t02 = 0.5;
							}
							var t12 = 1. - t02;
							var g = t02 * ((c0 >> 8 & 255) / 255) + t12 * ((c1 >> 8 & 255) / 255);
							var t03 = t;
							if(t03 == null) {
								t03 = 0.5;
							}
							var t13 = 1. - t03;
							var b = t03 * ((c0 & 255) / 255) + t13 * ((c1 & 255) / 255);
							second = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
						} else {
							var c01 = col.colorAnti;
							var c11 = col.colorClock;
							var t2 = i / totalSteps;
							if(t2 == null) {
								t2 = 0.5;
							}
							var t04 = t2;
							if(t04 == null) {
								t04 = 0.5;
							}
							var t14 = 1. - t04;
							var a1 = t04 * ((c01 >> 24 & 255) / 255) + t14 * ((c11 >> 24 & 255) / 255);
							var t05 = t2;
							if(t05 == null) {
								t05 = 0.5;
							}
							var t15 = 1. - t05;
							var r1 = t05 * ((c01 >> 16 & 255) / 255) + t15 * ((c11 >> 16 & 255) / 255);
							var t06 = t2;
							if(t06 == null) {
								t06 = 0.5;
							}
							var t16 = 1. - t06;
							var g1 = t06 * ((c01 >> 8 & 255) / 255) + t16 * ((c11 >> 8 & 255) / 255);
							var t07 = t2;
							if(t07 == null) {
								t07 = 0.5;
							}
							var t17 = 1. - t07;
							var b1 = t07 * ((c01 & 255) / 255) + t17 * ((c11 & 255) / 255);
							second = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
						}
						var this3 = this.endLine;
						if(this3 == 13 || this3 == 14) {
							var deltaG = Math.pow(ay1 - gy,2) + Math.pow(ax1 - gx,2);
							var deltaE = Math.pow(ay1 - ey,2) + Math.pow(ax1 - ex,2);
							if(deltaE > delta || deltaG > delta) {
								var second2 = i / totalSteps > 0.5 ? col.colorClock : col.colorAnti;
								this.pen.triangle2DGrad(ax1,ay1,gx,gy,ex,ey,half,second2,second2);
							}
						}
						this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second,second);
					} else {
						var c02 = col.colorAnti;
						var c12 = col.colorClock;
						var t3 = 1 - i / totalSteps;
						if(t3 == null) {
							t3 = 0.5;
						}
						var t08 = t3;
						if(t08 == null) {
							t08 = 0.5;
						}
						var t18 = 1. - t08;
						var a2 = t08 * ((c02 >> 24 & 255) / 255) + t18 * ((c12 >> 24 & 255) / 255);
						var t09 = t3;
						if(t09 == null) {
							t09 = 0.5;
						}
						var t19 = 1. - t09;
						var r2 = t09 * ((c02 >> 16 & 255) / 255) + t19 * ((c12 >> 16 & 255) / 255);
						var t010 = t3;
						if(t010 == null) {
							t010 = 0.5;
						}
						var t110 = 1. - t010;
						var g2 = t010 * ((c02 >> 8 & 255) / 255) + t110 * ((c12 >> 8 & 255) / 255);
						var t011 = t3;
						if(t011 == null) {
							t011 = 0.5;
						}
						var t111 = 1. - t011;
						var b2 = t011 * ((c02 & 255) / 255) + t111 * ((c12 & 255) / 255);
						var second1 = Math.round(a2 * 255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
						var this4 = this.endLine;
						if(this4 == 13 || this4 == 14) {
							var deltaG1 = Math.pow(ay1 - gy,2) + Math.pow(ax1 - gx,2);
							var deltaE1 = Math.pow(ay1 - ey,2) + Math.pow(ax1 - ex,2);
							if(deltaE1 > delta || deltaG1 > delta) {
								var second21 = 1 - i / totalSteps > 0.5 ? col.colorClock : col.colorAnti;
								this.pen.triangle2DGrad(ax1,ay1,gx,gy,ex,ey,half,second21,second21);
							}
						}
						this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second1,second1);
					}
				}
				angle += step;
				bx = cx;
				by = cy;
				var this5 = this.endLine;
				if(this5 == 13 || this5 == 14) {
					gx = ex;
					gy = ey;
				}
			}
			if(this.endLine == 4) {
				angle = angle + step * totalSteps / 2 - step;
				cx = ax1 + radius1 * Math.sin(angle) * Math.sqrt(2);
				cy = ay1 + radius1 * Math.cos(angle) * Math.sqrt(2);
				this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,col.colorAnti,half);
				bx = cx;
				by = cy;
				angle += step * (totalSteps / 2);
				cx = ax1 + radius1 * Math.sin(angle);
				cy = ay1 + radius1 * Math.cos(angle);
				this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,col.colorAnti,col.colorAnti);
				totalSteps += 2;
			}
		} else {
			var this1 = this.endLine;
			if(this1 == 10 || this1 == 11) {
				angle = beta;
				var dx = ax1 - radius1 * this.endCapFactor * Math.sin(angle);
				var dy = ay1 - radius1 * this.endCapFactor * Math.cos(angle);
				angle = beta - step * totalSteps / 2;
				cx = ax1 - radius1 * this.endCapFactor * Math.sin(angle);
				cy = ay1 - radius1 * this.endCapFactor * Math.cos(angle);
				this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
				bx = cx;
				by = cy;
				angle += step * totalSteps / 2;
				cx = ax1 + radius1 * this.endCapFactor * Math.sin(angle);
				cy = ay1 + radius1 * this.endCapFactor * Math.cos(angle);
				this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,half,col.colorClock);
			} else {
				var this1 = this.endLine;
				if(this1 == 7 || this1 == 8) {
					angle = beta;
					var dx = ax1 - radius1 * Math.sin(angle);
					var dy = ay1 - radius1 * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius1 * Math.sin(angle);
					cy = ay1 - radius1 * Math.cos(angle);
					this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius1 * Math.sin(angle);
					cy = ay1 + radius1 * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,half,col.colorClock);
				} else {
					var this1 = this.endLine;
					if(this1 == 16 || this1 == 17) {
						angle = beta;
						var dx = ax1 - radius1 * this.endCapFactor * Math.sin(angle);
						var dy = ay1 - radius1 * this.endCapFactor * Math.cos(angle);
						angle = beta - step * totalSteps / 2;
						cx = dx - 2 * radius1 * this.endCapFactor * Math.sin(angle);
						cy = dy - 2 * radius1 * this.endCapFactor * Math.cos(angle);
						var lastAngle = angle;
						angle += step * totalSteps / 2;
						ex = ax1 + radius1 * this.endCapFactor * Math.sin(angle);
						ey = ay1 + radius1 * this.endCapFactor * Math.cos(angle);
						fx = ex - 2 * radius1 * this.endCapFactor * Math.sin(lastAngle);
						fy = ey - 2 * radius1 * this.endCapFactor * Math.cos(lastAngle);
						this.pen.triangle2DGrad(fx,fy,cx,cy,dx,dy,col.colorClock,col.colorAnti,col.colorAnti);
						this.pen.triangle2DGrad(fx,fy,dx,dy,ex,ey,col.colorClock,col.colorClock,col.colorAnti);
					}
				}
			}
			totalSteps += 2;
		}
		var pA = this.pointsAnti.length;
		var len = temp.length / 2 | 0;
		var _g = 0;
		var _g1 = len + 2;
		while(_g < _g1) {
			var i = _g++;
			this.pointsAnti[pA++] = temp[i];
		}
		var pC = this.pointsClock.length;
		var _g = 1;
		var _g1 = len / 2 + 1 | 0;
		while(_g < _g1) {
			var i = _g++;
			this.pointsClock[pC++] = temp[temp.length - 2 * i];
			this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
		}
	}
	,addPieX: function(ax,ay,radius,beta,gamma,prefer,mark,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(mark == null) {
			mark = -1;
		}
		var temp = [];
		var clockwiseTemp = false;
		var color = mark;
		var sides1 = sides;
		if(sides1 == null) {
			sides1 = 36;
		}
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var step = pi * 2 / sides1;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var smallest = theta <= Math.PI;
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step = dif / totalSteps;
		var angle = beta;
		var cx = 0.;
		var cy = 0.;
		var bx = 0.;
		var by = 0.;
		var p2 = temp.length;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx = ax + radius * Math.sin(angle);
			cy = ay + radius * Math.cos(angle);
			temp[p2++] = cx;
			temp[p2++] = cy;
			if(i != 0) {
				if(!clockwiseTemp) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var c0 = col.colorAnti;
					var c1 = col.colorClock;
					var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
					var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
					var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
					var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
					var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
					this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,half,col.colorClock,col.colorClock);
				} else {
					var color_1 = color;
					var col1 = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var c01 = col1.colorAnti;
					var c11 = col1.colorClock;
					var a1 = ((c01 >> 24 & 255) / 255 + (c11 >> 24 & 255) / 255) / 2;
					var r1 = ((c01 >> 16 & 255) / 255 + (c11 >> 16 & 255) / 255) / 2;
					var g1 = ((c01 >> 8 & 255) / 255 + (c11 >> 8 & 255) / 255) / 2;
					var b1 = ((c01 & 255) / 255 + (c11 & 255) / 255) / 2;
					var half1 = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
					this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,half1,col1.colorAnti,col1.colorAnti);
				}
			}
			angle += step;
			bx = cx;
			by = cy;
		}
		var pA = this.pointsAnti.length;
		var len = temp.length / 2 | 0;
		var _g = 0;
		var _g1 = len + 2;
		while(_g < _g1) {
			var i = _g++;
			this.pointsAnti[pA++] = temp[i];
		}
		var pC = this.pointsClock.length;
		var _g = 1;
		var _g1 = len / 2 + 1 | 0;
		while(_g < _g1) {
			var i = _g++;
			this.pointsClock[pC++] = temp[temp.length - 2 * i];
			this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
		}
	}
	,addPie: function(ax,ay,radius,beta,gamma,prefer,mark,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(mark == null) {
			mark = -1;
		}
		var color = mark;
		var sides1 = sides;
		if(sides1 == null) {
			sides1 = 36;
		}
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var step = pi * 2 / sides1;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var smallest = theta <= Math.PI;
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step = dif / totalSteps;
		var angle = beta;
		var cx;
		var cy;
		var bx = 0;
		var by = 0;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx = ax + radius * Math.sin(angle);
			cy = ay + radius * Math.cos(angle);
			if(i != 0) {
				var color_ = color;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var red = -65536;
				var blue = -16711936;
				var green = -16776961;
				this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,red,green,blue);
			}
			angle += step;
			bx = cx;
			by = cy;
		}
	}
	,computeJ: function(width_,theta0,dif) {
		var gamma = Math.abs(dif) / 2;
		var h = width_ / 2 / Math.cos(gamma);
		var f;
		if(theta0 <= Math.PI && theta0 > -Math.PI) {
			f = theta0;
		} else {
			var a = (theta0 + Math.PI) % (2 * Math.PI);
			f = a >= 0 ? a - Math.PI : a + Math.PI;
		}
		var this1 = f;
		var start = this1;
		var start2 = start;
		var delta = start2 + dif / 2 + Math.PI;
		this.jx = this.ax + h * Math.sin(delta);
		this.jy = this.ay + h * Math.cos(delta);
	}
	,addDot: function(x,y,color,width_) {
		var w = width_ * 0.07;
		var color1 = color;
		if(color1 == null) {
			color1 = -1;
		}
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = x + w * Math.sin(theta);
			by = y + w * Math.cos(theta);
			theta += step;
			cx = x + w * Math.sin(theta);
			cy = y + w * Math.cos(theta);
			var color_ = color1;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(x,y,bx,by,cx,cy,C,A,C);
		}
	}
	,addSmallTriangles: function(clockWise,width_) {
		if(clockWise) {
			var ax_ = this.ax;
			var ay_ = this.ay;
			var bx_ = this.dxOld;
			var by_ = this.dyOld;
			var cx_ = this.jx;
			var cy_ = this.jy;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var c0 = col.colorAnti;
			var c1 = col.colorClock;
			var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
			var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
			var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
			var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
			var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
			this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,half,col.colorClock,col.colorAnti);
			var ax_ = this.ax;
			var ay_ = this.ay;
			var bx_ = this.exPrev;
			var by_ = this.eyPrev;
			var cx_ = this.jx;
			var cy_ = this.jy;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var c0 = col.colorAnti;
			var c1 = col.colorClock;
			var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
			var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
			var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
			var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
			var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
			this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,half,col.colorAnti,col.colorClock);
		} else {
			var ax_ = this.ax;
			var ay_ = this.ay;
			var bx_ = this.exOld;
			var by_ = this.eyOld;
			var cx_ = this.jx;
			var cy_ = this.jy;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var c0 = col.colorAnti;
			var c1 = col.colorClock;
			var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
			var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
			var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
			var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
			var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
			this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,half,col.colorClock,col.colorAnti);
			var ax_ = this.ax;
			var ay_ = this.ay;
			var bx_ = this.dxPrev;
			var by_ = this.dyPrev;
			var cx_ = this.jx;
			var cy_ = this.jy;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var c0 = col.colorAnti;
			var c1 = col.colorClock;
			var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
			var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
			var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
			var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
			var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
			this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,half,col.colorAnti,col.colorClock);
		}
	}
	,triangle2DFillangleCorners: function(oldx_,oldy_,prevx_,prevy_,width_) {
		var w = width_ * 0.07;
		var color = this.debugCol4;
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = oldx_ + w * Math.sin(theta);
			by = oldy_ + w * Math.cos(theta);
			theta += step;
			cx = oldx_ + w * Math.sin(theta);
			cy = oldy_ + w * Math.cos(theta);
			var color_ = color;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(oldx_,oldy_,bx,by,cx,cy,C,A,C);
		}
		var color = this.debugCol3;
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = prevx_ + w * Math.sin(theta);
			by = prevy_ + w * Math.cos(theta);
			theta += step;
			cx = prevx_ + w * Math.sin(theta);
			cy = prevy_ + w * Math.cos(theta);
			var color_ = color;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(prevx_,prevy_,bx,by,cx,cy,C,A,C);
		}
		var ax = this.ax;
		var ay = this.ay;
		var color = this.debugCol10;
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = ax + w * Math.sin(theta);
			by = ay + w * Math.cos(theta);
			theta += step;
			cx = ax + w * Math.sin(theta);
			cy = ay + w * Math.cos(theta);
			var color_ = color;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,C,A,C);
		}
		var ax = this.jx;
		var ay = this.jy;
		var color = this.debugCol5;
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = ax + w * Math.sin(theta);
			by = ay + w * Math.cos(theta);
			theta += step;
			cx = ax + w * Math.sin(theta);
			cy = ay + w * Math.cos(theta);
			var color_ = color;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,C,A,C);
		}
	}
	,triangle2DFillangleCornersLess: function(oldx_,oldy_,prevx_,prevy_,width_) {
		var w = width_ * 0.07;
		var color = this.debugCol4;
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = oldx_ + w * Math.sin(theta);
			by = oldy_ + w * Math.cos(theta);
			theta += step;
			cx = oldx_ + w * Math.sin(theta);
			cy = oldy_ + w * Math.cos(theta);
			var color_ = color;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(oldx_,oldy_,bx,by,cx,cy,C,A,C);
		}
		var color = this.debugCol3;
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = prevx_ + w * Math.sin(theta);
			by = prevy_ + w * Math.cos(theta);
			theta += step;
			cx = prevx_ + w * Math.sin(theta);
			cy = prevy_ + w * Math.cos(theta);
			var color_ = color;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(prevx_,prevy_,bx,by,cx,cy,C,A,C);
		}
		var ax = this.jx;
		var ay = this.jy;
		var color = this.debugCol5;
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = ax + w * Math.sin(theta);
			by = ay + w * Math.cos(theta);
			theta += step;
			cx = ax + w * Math.sin(theta);
			cy = ay + w * Math.cos(theta);
			var color_ = color;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,C,A,C);
		}
	}
	,connectQuadsWhenQuadsOverlay: function(clockWise,width_) {
		if(clockWise) {
			var ax_ = this.dxOld;
			var ay_ = this.dyOld;
			var bx_ = this.exPrev;
			var by_ = this.eyPrev;
			var cx_ = this.ax;
			var cy_ = this.ay;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,A,A,C);
		} else {
			var ax_ = this.exOld;
			var ay_ = this.eyOld;
			var bx_ = this.dxPrev;
			var by_ = this.dyPrev;
			var cx_ = this.ax;
			var cy_ = this.ay;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
		}
	}
	,connectQuads: function(clockWise,width_) {
		if(clockWise) {
			var ax_ = this.dxOld;
			var ay_ = this.dyOld;
			var bx_ = this.exPrev;
			var by_ = this.eyPrev;
			var cx_ = this.jx;
			var cy_ = this.jy;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,A,A,C);
		} else {
			var ax_ = this.exOld;
			var ay_ = this.eyOld;
			var bx_ = this.dxPrev;
			var by_ = this.dyPrev;
			var cx_ = this.jx;
			var cy_ = this.jy;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
		}
	}
	,addInitialQuads: function(clockWise,width_) {
		this.quadIndex = this.pen.get_pos();
		if(this.count == 0) {
			this.penultimateAX = this.dxPrev;
			this.penultimateAY = this.dyPrev;
			this.lastAntiX = this.ex;
			this.lastAntiY = this.ey;
			this.penultimateCX = this.dx;
			this.penultimateCY = this.dy;
			this.lastClockX = this.exPrev;
			this.lastClockY = this.eyPrev;
			var ax_ = this.dxPrev;
			var ay_ = this.dyPrev;
			var bx_ = this.dx;
			var by_ = this.dy;
			var cx_ = this.ex;
			var cy_ = this.ey;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
			var ax_ = this.jx;
			var ay_ = this.jy;
			var bx_ = this.dx;
			var by_ = this.dy;
			var cx_ = this.exPrev;
			var cy_ = this.eyPrev;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
		} else {
			if(clockWise && !this.lastClock) {
				this.penultimateAX = this.jx;
				this.penultimateAY = this.jy;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.exPrev;
				this.lastClockY = this.eyPrev;
				var ax_ = this.jx;
				var ay_ = this.jy;
				var bx_ = this.dx;
				var by_ = this.dy;
				var cx_ = this.ex;
				var cy_ = this.ey;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
				var ax_ = this.jx;
				var ay_ = this.jy;
				var bx_ = this.dx;
				var by_ = this.dy;
				var cx_ = this.exPrev;
				var cy_ = this.eyPrev;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
			}
			if(clockWise && this.lastClock) {
				this.penultimateAX = this.jx;
				this.penultimateAY = this.jy;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.exPrev;
				this.lastClockY = this.eyPrev;
				var ax_ = this.jx;
				var ay_ = this.jy;
				var bx_ = this.dx;
				var by_ = this.dy;
				var cx_ = this.ex;
				var cy_ = this.ey;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
				var ax_ = this.jx;
				var ay_ = this.jy;
				var bx_ = this.dx;
				var by_ = this.dy;
				var cx_ = this.exPrev;
				var cy_ = this.eyPrev;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
			}
			if(!clockWise && !this.lastClock) {
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.jx;
				this.lastClockY = this.jy;
				this.penultimateAX = this.dxPrev;
				this.penultimateAY = this.dyPrev;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				var ax_ = this.dxPrev;
				var ay_ = this.dyPrev;
				var bx_ = this.dx;
				var by_ = this.dy;
				var cx_ = this.jx;
				var cy_ = this.jy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
				var ax_ = this.dxPrev;
				var ay_ = this.dyPrev;
				var bx_ = this.dx;
				var by_ = this.dy;
				var cx_ = this.ex;
				var cy_ = this.ey;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
			}
			if(!clockWise && this.lastClock) {
				this.penultimateAX = this.dxPrev;
				this.penultimateAY = this.dyPrev;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.jx;
				this.penultimateCY = this.jy;
				this.lastClockX = this.dx;
				this.lastClockY = this.dy;
				var ax_ = this.jx;
				var ay_ = this.jy;
				var bx_ = this.dx;
				var by_ = this.dy;
				var cx_ = this.ex;
				var cy_ = this.ey;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,A,A,C);
				var ax_ = this.dxPrev;
				var ay_ = this.dyPrev;
				var bx_ = this.jx;
				var by_ = this.jy;
				var cx_ = this.ex;
				var cy_ = this.ey;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
			}
		}
	}
	,endEdges: function() {
		var pC = this.pointsClock.length;
		var pA = this.pointsAnti.length;
		this.pointsClock[pC++] = this.penultimateCX;
		this.pointsClock[pC++] = this.penultimateCY;
		this.pointsClock[pC++] = this.lastClockX;
		this.pointsClock[pC++] = this.lastClockY;
		this.pointsAnti[pA++] = this.penultimateAX;
		this.pointsAnti[pA++] = this.penultimateAY;
		this.pointsAnti[pA++] = this.lastAntiX;
		this.pointsAnti[pA++] = this.lastAntiY;
	}
	,addQuads: function(clockWise,width_) {
		var currQuadIndex = this.pen.get_pos();
		var pC = 0;
		var pA = 0;
		if(clockWise && !this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex + 1);
				var ax_ = this.kax;
				var ay_ = this.kay;
				var bx_ = this.kbx;
				var by_ = this.kby;
				var cx_ = this.ncx;
				var cy_ = this.ncy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex + 1);
				var ax_ = this.kax;
				var ay_ = this.kay;
				var bx_ = this.kbx;
				var by_ = this.kby;
				var cx_ = this.ncx;
				var cy_ = this.ncy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
			}
			this.pen.set_pos(this.quadIndex);
			var ax_ = this.kax;
			var ay_ = this.kay;
			var bx_ = this.kbx;
			var by_ = this.kby;
			var cx_ = this.jx;
			var cy_ = this.jy;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
		}
		if(clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				this.pointsAnti[pA++] = this.kbx;
				this.pointsAnti[pA++] = this.kby;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kax;
				this.pointsClock[pC++] = this.kay;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex);
				var ax_ = this.kax;
				var ay_ = this.kay;
				var bx_ = this.kbx;
				var by_ = this.kby;
				var cx_ = this.jx;
				var cy_ = this.jy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
				this.pen.set_pos(this.quadIndex + 1);
				var ax_ = this.kax;
				var ay_ = this.kay;
				var bx_ = this.kbx;
				var by_ = this.kby;
				var cx_ = this.ncx;
				var cy_ = this.ncy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex);
				var ax_ = this.jxOld;
				var ay_ = this.jyOld;
				var bx_ = this.kbx;
				var by_ = this.kby;
				var cx_ = this.jx;
				var cy_ = this.jy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
				this.pen.set_pos(this.quadIndex + 1);
				var ax_ = this.jxOld;
				var ay_ = this.jyOld;
				var bx_ = this.kbx;
				var by_ = this.kby;
				var cx_ = this.ncx;
				var cy_ = this.ncy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
			}
		}
		if(!clockWise && !this.lastClock) {
			this.pen.set_pos(this.quadIndex);
			var ax_ = this.kax;
			var ay_ = this.kay;
			var bx_ = this.jx;
			var by_ = this.jy;
			var cx_ = this.kcx;
			var cy_ = this.kcy;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pen.set_pos(this.quadIndex + 1);
				var ax_ = this.kax;
				var ay_ = this.kay;
				var bx_ = this.jx;
				var by_ = this.jy;
				var cx_ = this.ncx;
				var cy_ = this.ncy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pen.set_pos(this.quadIndex + 1);
				var ax_ = this.kax;
				var ay_ = this.kay;
				var bx_ = this.jx;
				var by_ = this.jy;
				var cx_ = this.jxOld;
				var cy_ = this.jyOld;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
			}
		}
		if(!clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex);
				var ax_ = this.kax;
				var ay_ = this.kay;
				var bx_ = this.jx;
				var by_ = this.jy;
				var cx_ = this.kcx;
				var cy_ = this.kcy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
				this.pen.set_pos(this.quadIndex + 1);
				var ax_ = this.kax;
				var ay_ = this.kay;
				var bx_ = this.jx;
				var by_ = this.jy;
				var cx_ = this.ncx;
				var cy_ = this.ncy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex);
				var ax_ = this.jxOld;
				var ay_ = this.jyOld;
				var bx_ = this.jx;
				var by_ = this.jy;
				var cx_ = this.kcx;
				var cy_ = this.kcy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
				this.pen.set_pos(this.quadIndex + 1);
				var ax_ = this.jxOld;
				var ay_ = this.jyOld;
				var bx_ = this.jx;
				var by_ = this.jy;
				var cx_ = this.ncx;
				var cy_ = this.ncy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
			}
		}
		this.pen.set_pos(currQuadIndex);
	}
	,storeLastQuads: function() {
		this.kax = this.dxPrev;
		this.kay = this.dyPrev;
		this.kbx = this.dx;
		this.kby = this.dy;
		this.ncx = this.exPrev;
		this.ncy = this.eyPrev;
		this.kcx = this.ex;
		this.kcy = this.ey;
	}
	,isClockwise: function(x,y) {
		var x1 = this.dxOld - x;
		var y1 = this.dyOld - y;
		var x2 = this.exOld - x;
		var y2 = this.eyOld - y;
		return x1 * x1 + y1 * y1 > x2 * x2 + y2 * y2;
	}
	,line: function(ax_,ay_,bx_,by_,width_,endLineCurve) {
		if(endLineCurve == null) {
			endLineCurve = 0;
		}
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.halfA = Math.PI / 2;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var dxPrev_ = this.dx;
		var dyPrev_ = this.dy;
		var exPrev_ = this.ex;
		var eyPrev_ = this.ey;
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		switch(endLineCurve) {
		case 0:
			break;
		case 1:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 2:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 3:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 4:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 5:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 6:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 7:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 8:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 9:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 10:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 11:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 12:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 13:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 14:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 15:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 16:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 17:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 18:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 19:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 20:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		}
		var bx_ = this.dx;
		var by_ = this.dy;
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var C = col.colorClock;
		var A = col.colorAnti;
		this.pen.triangle2DGrad(dxPrev_,dyPrev_,bx_,by_,exPrev_,eyPrev_,A,C,C);
		var bx_ = this.dx;
		var by_ = this.dy;
		var cx_ = this.ex;
		var cy_ = this.ey;
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var C = col.colorClock;
		var A = col.colorAnti;
		this.pen.triangle2DGrad(dxPrev_,dyPrev_,bx_,by_,cx_,cy_,A,C,A);
	}
	,circle: function(ax,ay,radius,color,sides,omega) {
		if(omega == null) {
			omega = 0.;
		}
		if(sides == null) {
			sides = 36;
		}
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var theta = pi / 2 + omega;
		var step = pi * 2 / sides;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = sides;
		while(_g < _g1) {
			var i = _g++;
			bx = ax + radius * Math.sin(theta);
			by = ay + radius * Math.cos(theta);
			theta += step;
			cx = ax + radius * Math.sin(theta);
			cy = ay + radius * Math.cos(theta);
			var color_ = color;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,C,A,C);
		}
		return sides;
	}
	,pie: function(ax,ay,radius,beta,gamma,prefer,color,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var step = pi * 2 / sides;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var smallest = theta <= Math.PI;
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step = dif / totalSteps;
		var angle = beta;
		var cx;
		var cy;
		var bx = 0;
		var by = 0;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx = ax + radius * Math.sin(angle);
			cy = ay + radius * Math.cos(angle);
			if(i != 0) {
				var color_ = color;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var red = -65536;
				var blue = -16711936;
				var green = -16776961;
				this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,red,green,blue);
			}
			angle += step;
			bx = cx;
			by = cy;
		}
		return totalSteps;
	}
	,startShape: function(ax,ay,radius,beta,gamma,prefer,edgePoly,clockWise,color,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var step = pi * 2 / sides;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var smallest = theta <= Math.PI;
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = this.endLine == 5 ? Math.ceil(Math.abs(dif) / (step / 2)) : Math.ceil(Math.abs(dif) / step);
		var step = dif / totalSteps;
		var angle = beta;
		var beta2 = 0.;
		var this1 = this.endLine;
		if(this1 == 18 || this1 == 20) {
			angle = Math.PI / 2;
			beta2 = 2 * Math.PI - beta + Math.PI / 2;
		}
		var cx = 0;
		var cy = 0;
		var bx = 0;
		var by = 0;
		var p2 = edgePoly.length;
		var col = this.getGradColors();
		var c0 = col.colorAnti;
		var c1 = col.colorClock;
		var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
		var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
		var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
		var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
		var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		var dx = ax + radius * Math.sin(angle);
		var dy = ay + radius * Math.cos(angle);
		var ex = 0.;
		var ey = 0.;
		var fx = 0.;
		var fy = 0.;
		var gx = 0.;
		var gy = 0.;
		var delta = 0.;
		var this1 = this.endLine;
		if(this1 == 12 || this1 == 14) {
			var angle2 = beta - step * totalSteps / 2;
			fx = ax - 0.75 * this.endCapFactor * radius * Math.sin(angle2);
			fy = ay - 0.75 * this.endCapFactor * radius * Math.cos(angle2);
			radius *= 2;
			delta = Math.pow(radius / 2,2);
		}
		var this1 = this.endLine;
		if(!(this1 == 6 || this1 == 8 || (this1 == 9 || this1 == 11) || (this1 == 15 || this1 == 17))) {
			if(this.endLine == 5) {
				var angle2 = beta - 2 * step * totalSteps;
				ax += radius * Math.sin(angle2);
				ay += radius * Math.cos(angle2);
				radius *= 2;
			}
			if(this.endLine == 5) {
				half = col.colorAnti;
			}
			var beta2 = 2 * Math.PI - beta + Math.PI / 2;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				var this1 = this.endLine;
				if(this1 == 12 || this1 == 14) {
					cx = fx + 0.5 * this.endCapFactor * radius * Math.sin(angle);
					cy = fy + 0.5 * this.endCapFactor * radius * Math.cos(angle);
					ex = fx - 0.5 * this.endCapFactor * radius * Math.sin(angle);
					ey = fy - 0.5 * this.endCapFactor * radius * Math.cos(angle);
				} else {
					var this2 = this.endLine;
					if(this2 == 18 || this2 == 20) {
						var ry = this.endCapFactor * radius;
						cx = ax + radius * Math.sin(angle);
						cy = ay + ry * Math.cos(angle);
						var cos = Math.cos(beta2);
						var sin = Math.sin(beta2);
						cx -= ax;
						cy -= ay;
						var ccx = cx;
						var ccy = cy;
						cx = ccx * cos - ccy * sin;
						cy = ccx * sin + ccy * cos;
						cx += ax;
						cy += ay;
					} else {
						cx = ax + radius * Math.sin(angle);
						cy = ay + radius * Math.cos(angle);
					}
				}
				edgePoly[p2++] = cx;
				edgePoly[p2++] = cy;
				if(i != 0) {
					if(!clockWise) {
						var second;
						if(this.endLine == 4) {
							var c0 = col.colorAnti;
							var c1 = col.colorClock;
							var t = 0.5 * i / totalSteps;
							if(t == null) {
								t = 0.5;
							}
							var t0 = t;
							if(t0 == null) {
								t0 = 0.5;
							}
							var t1 = 1. - t0;
							var a = t0 * ((c0 >> 24 & 255) / 255) + t1 * ((c1 >> 24 & 255) / 255);
							var t01 = t;
							if(t01 == null) {
								t01 = 0.5;
							}
							var t11 = 1. - t01;
							var r = t01 * ((c0 >> 16 & 255) / 255) + t11 * ((c1 >> 16 & 255) / 255);
							var t02 = t;
							if(t02 == null) {
								t02 = 0.5;
							}
							var t12 = 1. - t02;
							var g = t02 * ((c0 >> 8 & 255) / 255) + t12 * ((c1 >> 8 & 255) / 255);
							var t03 = t;
							if(t03 == null) {
								t03 = 0.5;
							}
							var t13 = 1. - t03;
							var b = t03 * ((c0 & 255) / 255) + t13 * ((c1 & 255) / 255);
							second = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
						} else {
							var c01 = col.colorAnti;
							var c11 = col.colorClock;
							var t2 = i / totalSteps;
							if(t2 == null) {
								t2 = 0.5;
							}
							var t04 = t2;
							if(t04 == null) {
								t04 = 0.5;
							}
							var t14 = 1. - t04;
							var a1 = t04 * ((c01 >> 24 & 255) / 255) + t14 * ((c11 >> 24 & 255) / 255);
							var t05 = t2;
							if(t05 == null) {
								t05 = 0.5;
							}
							var t15 = 1. - t05;
							var r1 = t05 * ((c01 >> 16 & 255) / 255) + t15 * ((c11 >> 16 & 255) / 255);
							var t06 = t2;
							if(t06 == null) {
								t06 = 0.5;
							}
							var t16 = 1. - t06;
							var g1 = t06 * ((c01 >> 8 & 255) / 255) + t16 * ((c11 >> 8 & 255) / 255);
							var t07 = t2;
							if(t07 == null) {
								t07 = 0.5;
							}
							var t17 = 1. - t07;
							var b1 = t07 * ((c01 & 255) / 255) + t17 * ((c11 & 255) / 255);
							second = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
						}
						var this3 = this.endLine;
						if(this3 == 12 || this3 == 14) {
							var deltaG = Math.pow(ay - gy,2) + Math.pow(ax - gx,2);
							var deltaE = Math.pow(ay - ey,2) + Math.pow(ax - ex,2);
							if(deltaE > delta || deltaG > delta) {
								var second2 = i / totalSteps > 0.5 ? col.colorClock : col.colorAnti;
								this.pen.triangle2DGrad(ax,ay,gx,gy,ex,ey,half,second2,second2);
							}
						}
						this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,half,second,second);
					} else {
						var c02 = col.colorAnti;
						var c12 = col.colorClock;
						var t3 = 1 - i / totalSteps;
						if(t3 == null) {
							t3 = 0.5;
						}
						var t08 = t3;
						if(t08 == null) {
							t08 = 0.5;
						}
						var t18 = 1. - t08;
						var a2 = t08 * ((c02 >> 24 & 255) / 255) + t18 * ((c12 >> 24 & 255) / 255);
						var t09 = t3;
						if(t09 == null) {
							t09 = 0.5;
						}
						var t19 = 1. - t09;
						var r2 = t09 * ((c02 >> 16 & 255) / 255) + t19 * ((c12 >> 16 & 255) / 255);
						var t010 = t3;
						if(t010 == null) {
							t010 = 0.5;
						}
						var t110 = 1. - t010;
						var g2 = t010 * ((c02 >> 8 & 255) / 255) + t110 * ((c12 >> 8 & 255) / 255);
						var t011 = t3;
						if(t011 == null) {
							t011 = 0.5;
						}
						var t111 = 1. - t011;
						var b2 = t011 * ((c02 & 255) / 255) + t111 * ((c12 & 255) / 255);
						var second1 = Math.round(a2 * 255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
						var this4 = this.endLine;
						if(this4 == 12 || this4 == 14) {
							var deltaG1 = Math.pow(ay - gy,2) + Math.pow(ax - gx,2);
							var deltaE1 = Math.pow(ay - ey,2) + Math.pow(ax - ex,2);
							if(deltaE1 > delta || deltaG1 > delta) {
								var second21 = 1 - i / totalSteps > 0.5 ? col.colorClock : col.colorAnti;
								this.pen.triangle2DGrad(ax,ay,gx,gy,ex,ey,half,second21,second21);
							}
						}
						this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,half,second1,second1);
					}
				}
				angle += step;
				bx = cx;
				by = cy;
				var this5 = this.endLine;
				if(this5 == 12 || this5 == 14) {
					gx = ex;
					gy = ey;
				}
			}
			if(this.endLine == 4) {
				angle = angle + step * totalSteps / 2 - step;
				cx = ax + radius * Math.sin(angle) * Math.sqrt(2);
				cy = ay + radius * Math.cos(angle) * Math.sqrt(2);
				this.pen.triangle2DGrad(ax,ay,cx,cy,bx,by,half,half,col.colorAnti);
				bx = cx;
				by = cy;
				angle += step * (totalSteps / 2);
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				this.pen.triangle2DGrad(ax,ay,cx,cy,bx,by,half,col.colorAnti,col.colorAnti);
				totalSteps += 2;
			}
		} else {
			var this1 = this.endLine;
			if(this1 == 9 || this1 == 11) {
				angle = beta;
				var dx = ax - radius * this.endCapFactor * Math.sin(angle);
				var dy = ay - radius * this.endCapFactor * Math.cos(angle);
				angle = beta - step * totalSteps / 2;
				cx = ax - radius * this.endCapFactor * Math.sin(angle);
				cy = ay - radius * this.endCapFactor * Math.cos(angle);
				this.pen.triangle2DGrad(dx,dy,cx,cy,ax,ay,col.colorAnti,half,half);
				bx = cx;
				by = cy;
				angle += step * totalSteps / 2;
				cx = ax + radius * this.endCapFactor * Math.sin(angle);
				cy = ay + radius * this.endCapFactor * Math.cos(angle);
				this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,half,col.colorClock,half);
			} else {
				var this1 = this.endLine;
				if(this1 == 6 || this1 == 8) {
					angle = beta;
					var dx = ax - radius * Math.sin(angle);
					var dy = ay - radius * Math.cos(angle);
					angle = beta + step * totalSteps / 2;
					cx = ax + radius * Math.sin(angle);
					cy = ay + radius * Math.cos(angle);
					this.pen.triangle2DGrad(dx,dy,cx,cy,ax,ay,col.colorAnti,half,half);
					bx = cx;
					by = cy;
					angle -= step * totalSteps / 2;
					cx = ax + radius * Math.sin(angle);
					cy = ay + radius * Math.cos(angle);
					this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,half,col.colorClock,half);
				} else {
					var this1 = this.endLine;
					if(this1 == 15 || this1 == 17) {
						angle = beta;
						var dx = ax - radius * this.endCapFactor * Math.sin(angle);
						var dy = ay - radius * this.endCapFactor * Math.cos(angle);
						angle = beta - step * totalSteps / 2;
						cx = dx - 2 * radius * this.endCapFactor * Math.sin(angle);
						cy = dy - 2 * radius * this.endCapFactor * Math.cos(angle);
						var lastAngle = angle;
						angle += step * totalSteps / 2;
						ex = ax + radius * this.endCapFactor * Math.sin(angle);
						ey = ay + radius * this.endCapFactor * Math.cos(angle);
						fx = ex - 2 * radius * this.endCapFactor * Math.sin(lastAngle);
						fy = ey - 2 * radius * this.endCapFactor * Math.cos(lastAngle);
						this.pen.triangle2DGrad(fx,fy,cx,cy,dx,dy,col.colorClock,col.colorAnti,col.colorAnti);
						this.pen.triangle2DGrad(fx,fy,dx,dy,ex,ey,col.colorClock,col.colorAnti,col.colorClock);
					}
				}
			}
			totalSteps += 2;
		}
		return totalSteps;
	}
	,endShape: function(ax,ay,radius,beta,gamma,prefer,edgePoly,clockWise,color,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var step = pi * 2 / sides;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var smallest = theta <= Math.PI;
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = this.endLine == 5 ? Math.ceil(Math.abs(dif) / (step / 2)) : Math.ceil(Math.abs(dif) / step);
		var step = dif / totalSteps;
		var angle = beta;
		var beta2 = 0.;
		var this1 = this.endLine;
		if(this1 == 19 || this1 == 20) {
			angle = Math.PI / 2;
			beta2 = 2 * Math.PI - beta + Math.PI / 2;
		}
		var cx = 0.;
		var cy = 0.;
		var bx = 0.;
		var by = 0.;
		var p2 = edgePoly.length;
		var col = this.getGradColors();
		var c0 = col.colorAnti;
		var c1 = col.colorClock;
		var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
		var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
		var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
		var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
		var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		var dx = ax + radius * Math.sin(angle);
		var dy = ay + radius * Math.cos(angle);
		var ex = 0.;
		var ey = 0.;
		var fx = 0.;
		var fy = 0.;
		var gx = 0.;
		var gy = 0.;
		var delta = 0.;
		var this1 = this.endLine;
		if(this1 == 13 || this1 == 14) {
			var angle2 = beta - step * totalSteps / 2;
			fx = ax - 0.75 * this.endCapFactor * radius * Math.sin(angle2);
			fy = ay - 0.75 * this.endCapFactor * radius * Math.cos(angle2);
			radius *= 2;
			delta = Math.pow(radius / 2,2);
		}
		var this1 = this.endLine;
		if(!(this1 == 7 || this1 == 8 || (this1 == 10 || this1 == 11) || (this1 == 16 || this1 == 17))) {
			if(this.endLine == 5) {
				var angle2 = beta - 2 * step * totalSteps;
				ax += radius * Math.sin(angle2);
				ay += radius * Math.cos(angle2);
				radius *= 2;
			}
			if(this.endLine == 5) {
				half = col.colorAnti;
			}
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				var this1 = this.endLine;
				if(this1 == 13 || this1 == 14) {
					cx = fx + 0.5 * this.endCapFactor * radius * Math.sin(angle);
					cy = fy + 0.5 * this.endCapFactor * radius * Math.cos(angle);
					ex = fx - 0.5 * this.endCapFactor * radius * Math.sin(angle);
					ey = fy - 0.5 * this.endCapFactor * radius * Math.cos(angle);
				} else {
					var this2 = this.endLine;
					if(this2 == 19 || this2 == 20) {
						var ry = this.endCapFactor * radius;
						cx = ax + radius * Math.sin(angle);
						cy = ay + ry * Math.cos(angle);
						var cos = Math.cos(beta2);
						var sin = Math.sin(beta2);
						cx -= ax;
						cy -= ay;
						var ccx = cx;
						var ccy = cy;
						cx = ccx * cos - ccy * sin;
						cy = ccx * sin + ccy * cos;
						cx += ax;
						cy += ay;
					} else {
						cx = ax + radius * Math.sin(angle);
						cy = ay + radius * Math.cos(angle);
					}
				}
				edgePoly[p2++] = cx;
				edgePoly[p2++] = cy;
				if(i != 0) {
					if(!clockWise) {
						var second;
						if(this.endLine == 4) {
							var c0 = col.colorAnti;
							var c1 = col.colorClock;
							var t = 0.5 * i / totalSteps;
							if(t == null) {
								t = 0.5;
							}
							var t0 = t;
							if(t0 == null) {
								t0 = 0.5;
							}
							var t1 = 1. - t0;
							var a = t0 * ((c0 >> 24 & 255) / 255) + t1 * ((c1 >> 24 & 255) / 255);
							var t01 = t;
							if(t01 == null) {
								t01 = 0.5;
							}
							var t11 = 1. - t01;
							var r = t01 * ((c0 >> 16 & 255) / 255) + t11 * ((c1 >> 16 & 255) / 255);
							var t02 = t;
							if(t02 == null) {
								t02 = 0.5;
							}
							var t12 = 1. - t02;
							var g = t02 * ((c0 >> 8 & 255) / 255) + t12 * ((c1 >> 8 & 255) / 255);
							var t03 = t;
							if(t03 == null) {
								t03 = 0.5;
							}
							var t13 = 1. - t03;
							var b = t03 * ((c0 & 255) / 255) + t13 * ((c1 & 255) / 255);
							second = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
						} else {
							var c01 = col.colorAnti;
							var c11 = col.colorClock;
							var t2 = i / totalSteps;
							if(t2 == null) {
								t2 = 0.5;
							}
							var t04 = t2;
							if(t04 == null) {
								t04 = 0.5;
							}
							var t14 = 1. - t04;
							var a1 = t04 * ((c01 >> 24 & 255) / 255) + t14 * ((c11 >> 24 & 255) / 255);
							var t05 = t2;
							if(t05 == null) {
								t05 = 0.5;
							}
							var t15 = 1. - t05;
							var r1 = t05 * ((c01 >> 16 & 255) / 255) + t15 * ((c11 >> 16 & 255) / 255);
							var t06 = t2;
							if(t06 == null) {
								t06 = 0.5;
							}
							var t16 = 1. - t06;
							var g1 = t06 * ((c01 >> 8 & 255) / 255) + t16 * ((c11 >> 8 & 255) / 255);
							var t07 = t2;
							if(t07 == null) {
								t07 = 0.5;
							}
							var t17 = 1. - t07;
							var b1 = t07 * ((c01 & 255) / 255) + t17 * ((c11 & 255) / 255);
							second = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
						}
						var this3 = this.endLine;
						if(this3 == 13 || this3 == 14) {
							var deltaG = Math.pow(ay - gy,2) + Math.pow(ax - gx,2);
							var deltaE = Math.pow(ay - ey,2) + Math.pow(ax - ex,2);
							if(deltaE > delta || deltaG > delta) {
								var second2 = i / totalSteps > 0.5 ? col.colorClock : col.colorAnti;
								this.pen.triangle2DGrad(ax,ay,gx,gy,ex,ey,half,second2,second2);
							}
						}
						this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,half,second,second);
					} else {
						var c02 = col.colorAnti;
						var c12 = col.colorClock;
						var t3 = 1 - i / totalSteps;
						if(t3 == null) {
							t3 = 0.5;
						}
						var t08 = t3;
						if(t08 == null) {
							t08 = 0.5;
						}
						var t18 = 1. - t08;
						var a2 = t08 * ((c02 >> 24 & 255) / 255) + t18 * ((c12 >> 24 & 255) / 255);
						var t09 = t3;
						if(t09 == null) {
							t09 = 0.5;
						}
						var t19 = 1. - t09;
						var r2 = t09 * ((c02 >> 16 & 255) / 255) + t19 * ((c12 >> 16 & 255) / 255);
						var t010 = t3;
						if(t010 == null) {
							t010 = 0.5;
						}
						var t110 = 1. - t010;
						var g2 = t010 * ((c02 >> 8 & 255) / 255) + t110 * ((c12 >> 8 & 255) / 255);
						var t011 = t3;
						if(t011 == null) {
							t011 = 0.5;
						}
						var t111 = 1. - t011;
						var b2 = t011 * ((c02 & 255) / 255) + t111 * ((c12 & 255) / 255);
						var second1 = Math.round(a2 * 255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
						var this4 = this.endLine;
						if(this4 == 13 || this4 == 14) {
							var deltaG1 = Math.pow(ay - gy,2) + Math.pow(ax - gx,2);
							var deltaE1 = Math.pow(ay - ey,2) + Math.pow(ax - ex,2);
							if(deltaE1 > delta || deltaG1 > delta) {
								var second21 = 1 - i / totalSteps > 0.5 ? col.colorClock : col.colorAnti;
								this.pen.triangle2DGrad(ax,ay,gx,gy,ex,ey,half,second21,second21);
							}
						}
						this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,half,second1,second1);
					}
				}
				angle += step;
				bx = cx;
				by = cy;
				var this5 = this.endLine;
				if(this5 == 13 || this5 == 14) {
					gx = ex;
					gy = ey;
				}
			}
			if(this.endLine == 4) {
				angle = angle + step * totalSteps / 2 - step;
				cx = ax + radius * Math.sin(angle) * Math.sqrt(2);
				cy = ay + radius * Math.cos(angle) * Math.sqrt(2);
				this.pen.triangle2DGrad(ax,ay,cx,cy,bx,by,half,col.colorAnti,half);
				bx = cx;
				by = cy;
				angle += step * (totalSteps / 2);
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				this.pen.triangle2DGrad(ax,ay,cx,cy,bx,by,half,col.colorAnti,col.colorAnti);
				totalSteps += 2;
			}
		} else {
			var this1 = this.endLine;
			if(this1 == 10 || this1 == 11) {
				angle = beta;
				var dx = ax - radius * this.endCapFactor * Math.sin(angle);
				var dy = ay - radius * this.endCapFactor * Math.cos(angle);
				angle = beta - step * totalSteps / 2;
				cx = ax - radius * this.endCapFactor * Math.sin(angle);
				cy = ay - radius * this.endCapFactor * Math.cos(angle);
				this.pen.triangle2DGrad(dx,dy,cx,cy,ax,ay,col.colorAnti,half,half);
				bx = cx;
				by = cy;
				angle += step * totalSteps / 2;
				cx = ax + radius * this.endCapFactor * Math.sin(angle);
				cy = ay + radius * this.endCapFactor * Math.cos(angle);
				this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,half,half,col.colorClock);
			} else {
				var this1 = this.endLine;
				if(this1 == 7 || this1 == 8) {
					angle = beta;
					var dx = ax - radius * Math.sin(angle);
					var dy = ay - radius * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax - radius * Math.sin(angle);
					cy = ay - radius * Math.cos(angle);
					this.pen.triangle2DGrad(dx,dy,cx,cy,ax,ay,col.colorAnti,half,half);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax + radius * Math.sin(angle);
					cy = ay + radius * Math.cos(angle);
					this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,half,half,col.colorClock);
				} else {
					var this1 = this.endLine;
					if(this1 == 16 || this1 == 17) {
						angle = beta;
						var dx = ax - radius * this.endCapFactor * Math.sin(angle);
						var dy = ay - radius * this.endCapFactor * Math.cos(angle);
						angle = beta - step * totalSteps / 2;
						cx = dx - 2 * radius * this.endCapFactor * Math.sin(angle);
						cy = dy - 2 * radius * this.endCapFactor * Math.cos(angle);
						var lastAngle = angle;
						angle += step * totalSteps / 2;
						ex = ax + radius * this.endCapFactor * Math.sin(angle);
						ey = ay + radius * this.endCapFactor * Math.cos(angle);
						fx = ex - 2 * radius * this.endCapFactor * Math.sin(lastAngle);
						fy = ey - 2 * radius * this.endCapFactor * Math.cos(lastAngle);
						this.pen.triangle2DGrad(fx,fy,cx,cy,dx,dy,col.colorClock,col.colorAnti,col.colorAnti);
						this.pen.triangle2DGrad(fx,fy,dx,dy,ex,ey,col.colorClock,col.colorClock,col.colorAnti);
					}
				}
			}
			totalSteps += 2;
		}
		return totalSteps;
	}
	,pieX: function(ax,ay,radius,beta,gamma,prefer,edgePoly,clockWise,color,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var step = pi * 2 / sides;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var smallest = theta <= Math.PI;
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step = dif / totalSteps;
		var angle = beta;
		var cx = 0.;
		var cy = 0.;
		var bx = 0.;
		var by = 0.;
		var p2 = edgePoly.length;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx = ax + radius * Math.sin(angle);
			cy = ay + radius * Math.cos(angle);
			edgePoly[p2++] = cx;
			edgePoly[p2++] = cy;
			if(i != 0) {
				if(!clockWise) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var c0 = col.colorAnti;
					var c1 = col.colorClock;
					var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
					var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
					var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
					var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
					var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
					this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,half,col.colorClock,col.colorClock);
				} else {
					var color_1 = color;
					var col1 = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var c01 = col1.colorAnti;
					var c11 = col1.colorClock;
					var a1 = ((c01 >> 24 & 255) / 255 + (c11 >> 24 & 255) / 255) / 2;
					var r1 = ((c01 >> 16 & 255) / 255 + (c11 >> 16 & 255) / 255) / 2;
					var g1 = ((c01 >> 8 & 255) / 255 + (c11 >> 8 & 255) / 255) / 2;
					var b1 = ((c01 & 255) / 255 + (c11 & 255) / 255) / 2;
					var half1 = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
					this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,half1,col1.colorAnti,col1.colorAnti);
				}
			}
			angle += step;
			bx = cx;
			by = cy;
		}
		return totalSteps;
	}
	,pieDifX: function(ax,ay,radius,beta,dif,edgePoly,clockWise,color,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var step = pi * 2 / sides;
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step = dif / totalSteps;
		var angle = beta;
		var cx = 0.;
		var cy = 0.;
		var bx = 0.;
		var by = 0.;
		var p2 = edgePoly.length;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx = ax + radius * Math.sin(angle);
			cy = ay + radius * Math.cos(angle);
			edgePoly[p2++] = cx;
			edgePoly[p2++] = cy;
			if(i != 0) {
				if(!clockWise) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var c0 = col.colorAnti;
					var c1 = col.colorClock;
					var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
					var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
					var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
					var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
					var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
					this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,half,col.colorClock,col.colorClock);
				} else {
					var color_1 = color;
					var col1 = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var c01 = col1.colorAnti;
					var c11 = col1.colorClock;
					var a1 = ((c01 >> 24 & 255) / 255 + (c11 >> 24 & 255) / 255) / 2;
					var r1 = ((c01 >> 16 & 255) / 255 + (c11 >> 16 & 255) / 255) / 2;
					var g1 = ((c01 >> 8 & 255) / 255 + (c11 >> 8 & 255) / 255) / 2;
					var b1 = ((c01 & 255) / 255 + (c11 & 255) / 255) / 2;
					var half1 = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
					this.pen.triangle2DGrad(ax,ay,bx,by,cx,cy,half1,col1.colorAnti,col1.colorAnti);
				}
			}
			angle += step;
			bx = cx;
			by = cy;
		}
		return totalSteps;
	}
};
function cornerContour_CurveMath_distance(px,py,qx,qy) {
	var x = px - qx;
	var y = py - qy;
	return Math.sqrt(x * x + y * y);
}
function cornerContour_CurveMath_quadCurve(p,ax,ay,bx,by,cx,cy) {
	var x = ax - bx;
	var y = ay - by;
	var x1 = bx - cx;
	var y1 = by - cy;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
	var l = p.length;
	p[l++] = ax;
	p[l++] = ay;
	var t = step;
	while(t < 1.) {
		var u = 1 - t;
		p[l++] = Math.pow(u,2) * ax + 2 * u * t * bx + Math.pow(t,2) * cx;
		var u1 = 1 - t;
		p[l++] = Math.pow(u1,2) * ay + 2 * u1 * t * by + Math.pow(t,2) * cy;
		t += step;
	}
	p[l++] = cx;
	p[l++] = cy;
	return p;
}
function cornerContour_CurveMath_cubicCurve(p,ax,ay,bx,by,cx,cy,dx,dy) {
	var x = ax - bx;
	var y = ay - by;
	var x1 = bx - cx;
	var y1 = by - cy;
	var x2 = cx - dx;
	var y2 = cy - dy;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2);
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	var step = Math.min(1 / (approxDistance * 0.707),0.03);
	var l = p.length;
	p[l++] = ax;
	p[l++] = ay;
	var t = step;
	while(t < 1.) {
		var u = 1 - t;
		p[l++] = Math.pow(u,3) * ax + 3 * Math.pow(u,2) * t * bx + 3 * u * Math.pow(t,2) * cx + Math.pow(t,3) * dx;
		var u1 = 1 - t;
		p[l++] = Math.pow(u1,3) * ay + 3 * Math.pow(u1,2) * t * by + 3 * u1 * Math.pow(t,2) * cy + Math.pow(t,3) * dy;
		t += step;
	}
	p[l++] = dx;
	p[l++] = dy;
	return p;
}
function cornerContour_CurveMath_calculateQuadStep(ax,ay,bx,by,cx,cy) {
	var x = ax - bx;
	var y = ay - by;
	var x1 = bx - cx;
	var y1 = by - cy;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	return Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
}
function cornerContour_CurveMath_calculateCubicStep(ax,ay,bx,by,cx,cy,dx,dy) {
	var x = ax - bx;
	var y = ay - by;
	var x1 = bx - cx;
	var y1 = by - cy;
	var x2 = cx - dx;
	var y2 = cy - dy;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2);
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	return Math.min(1 / (approxDistance * 0.707),0.03);
}
function cornerContour_CurveMath_quadraticThru(t,s,c,e) {
	c = 2 * c - 0.5 * (s + e);
	var u = 1 - t;
	return Math.pow(u,2) * s + 2 * u * t * c + Math.pow(t,2) * e;
}
function cornerContour_CurveMath_quadratic(t,s,c,e) {
	var u = 1 - t;
	return Math.pow(u,2) * s + 2 * u * t * c + Math.pow(t,2) * e;
}
function cornerContour_CurveMath_cubic(t,s,c1,c2,e) {
	var u = 1 - t;
	return Math.pow(u,3) * s + 3 * Math.pow(u,2) * t * c1 + 3 * u * Math.pow(t,2) * c2 + Math.pow(t,3) * e;
}
var cornerContour_Pen2D = function(col) {
	var this1 = [];
	this1[0] = 0.;
	this.arr = this1;
	this.currentColor = col;
};
cornerContour_Pen2D.__name__ = true;
cornerContour_Pen2D.prototype = {
	get_pos: function() {
		return this.arr[0];
	}
	,set_pos: function(val) {
		this.arr[0] = val;
		return val;
	}
	,get_size: function() {
		var v = this.arr.length - 1;
		return v;
	}
	,triangle2DFill: function(ax,ay,bx,by,cx,cy,color) {
		if(color == null || color == -1) {
			color = this.currentColor;
		}
		var this1 = this.arr;
		cornerContour_io_Array2DTriangles.triangle(this1,ax,ay,bx,by,cx,cy);
		if(color == null) {
			cornerContour_io_Array2DTriangles.set_colorInt(this1,16711680);
		} else {
			cornerContour_io_Array2DTriangles.set_colorInt(this1,color);
		}
		var pos_ = this.arr[0] + 1;
		this.arr[0] = pos_;
		return 1;
	}
	,triangle2DGrad: function(ax,ay,bx,by,cx,cy,colorA,colorB,colorC) {
		if(colorA == null || colorA == -1) {
			colorA = this.currentColor;
		}
		var this1 = this.arr;
		cornerContour_io_Array2DTriangles.triangle(this1,ax,ay,bx,by,cx,cy);
		if(colorA == null) {
			cornerContour_io_Array2DTriangles.set_colorInt(this1,16711680);
		} else {
			cornerContour_io_Array2DTriangles.set_colorInt(this1,colorA);
		}
		var pos_ = this.arr[0] + 1;
		this.arr[0] = pos_;
		return 1;
	}
};
var cornerContour_Pen2DGrad = function(col,colB,colC) {
	var this1 = [];
	this1[0] = 0.;
	this.arr = this1;
	this.currentColor = col;
	var hasB = colB == null;
	var hasC = colC == null;
	if(!hasB) {
		colB = col;
	}
	this.colorB = colB;
	if(!hasC) {
		colC = col;
	}
	this.colorC = colC;
};
cornerContour_Pen2DGrad.__name__ = true;
cornerContour_Pen2DGrad.prototype = {
	get_pos: function() {
		return this.arr[0];
	}
	,set_pos: function(val) {
		this.arr[0] = val;
		return val;
	}
	,get_size: function() {
		var v = this.arr.length - 1;
		return v;
	}
	,triangle2DFill: function(ax,ay,bx,by,cx,cy,color) {
		if(color == null || color == -1) {
			color = this.currentColor;
		}
		var this1 = this.arr;
		cornerContour_io_Array2DTriGrad.triangle(this1,ax,ay,bx,by,cx,cy);
		if(color == null) {
			cornerContour_io_Array2DTriGrad.set_colorIntA(this1,16711680);
		} else {
			cornerContour_io_Array2DTriGrad.set_colorIntA(this1,color);
		}
		if(color == null) {
			cornerContour_io_Array2DTriGrad.set_colorIntB(this1,16711680);
		} else {
			cornerContour_io_Array2DTriGrad.set_colorIntB(this1,color);
		}
		if(color == null) {
			cornerContour_io_Array2DTriGrad.set_colorIntC(this1,16711680);
		} else {
			cornerContour_io_Array2DTriGrad.set_colorIntC(this1,color);
		}
		var pos_ = this.arr[0] + 1;
		this.arr[0] = pos_;
		return 1;
	}
	,triangle2DGrad: function(ax,ay,bx,by,cx,cy,colorA,colorB,colorC) {
		if(colorA == null || colorA == -1) {
			colorA = this.currentColor;
		}
		if(colorB == null || colorB == -1) {
			colorB = this.colorB;
		}
		if(colorC == null || colorC == -1) {
			colorC = this.colorC;
		}
		var this1 = this.arr;
		cornerContour_io_Array2DTriGrad.triangle(this1,ax,ay,bx,by,cx,cy);
		if(colorA == null) {
			cornerContour_io_Array2DTriGrad.set_colorIntA(this1,16711680);
		} else {
			cornerContour_io_Array2DTriGrad.set_colorIntA(this1,colorA);
		}
		if(colorB == null) {
			cornerContour_io_Array2DTriGrad.set_colorIntB(this1,16711680);
		} else {
			cornerContour_io_Array2DTriGrad.set_colorIntB(this1,colorB);
		}
		if(colorC == null) {
			cornerContour_io_Array2DTriGrad.set_colorIntC(this1,16711680);
		} else {
			cornerContour_io_Array2DTriGrad.set_colorIntC(this1,colorC);
		}
		var pos_ = this.arr[0] + 1;
		this.arr[0] = pos_;
		return 1;
	}
};
var cornerContour_Sketcher = function(pen_,sketchForm_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.historyParameters = [];
	this.historyCommands = [];
	this.historyParamPos = [];
	this.turtleParameters = [];
	this.turtleCommands = [];
	this.repeatCommands = false;
	this.repeatCount = 0;
	this.fill = false;
	this.lastDistance = 0.;
	this.rotation = 0.;
	this.penIsDown = true;
	this.counter = 0;
	this.width = 0.01;
	this.y = 0.;
	this.x = 0.;
	this.rotation = -Math.PI / 2;
	this.pen = pen_;
	this.endLine = endLine_;
	this.contour = this.createContour();
	this.sketchForm = sketchForm_;
	switch(sketchForm_) {
	case 0:
		this.line = $bind(this,this.tracerLine);
		break;
	case 1:
		this.line = $bind(this,this.baseLine);
		break;
	case 2:
		this.line = $bind(this,this.crudeLine);
		break;
	case 3:
		this.line = $bind(this,this.fillOnlyLine);
		break;
	case 4:
		this.line = $bind(this,this.fineLine);
		break;
	case 5:
		this.line = $bind(this,this.fineOverlapLine);
		break;
	case 6:
		this.line = $bind(this,this.mediumLine);
		break;
	case 7:
		this.line = $bind(this,this.mediumOverlapLine);
		break;
	case 8:
		this.line = $bind(this,this.roundEndLine);
		break;
	}
	this.points = [];
	this.pointsClock = [];
	this.pointsAnti = [];
	this.points[0] = [];
	this.dim = [];
};
cornerContour_Sketcher.__name__ = true;
cornerContour_Sketcher.sidetaGram = function(sides) {
	return 4. * (90. - 360. / sides);
};
cornerContour_Sketcher.prototype = {
	tracerLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "cornerContour/Sketcher.hx", lineNumber : 30, className : "cornerContour.Sketcher", methodName : "tracerLine"});
	}
	,fillOnlyLine: function(x_,y_) {
	}
	,baseLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "cornerContour/Sketcher.hx", lineNumber : 30, className : "cornerContour.Sketcher", methodName : "tracerLine"});
		this.contour.line(this.x,this.y,x_,y_,this.width);
	}
	,crudeLine: function(x_,y_) {
		this.contour.line(this.x,this.y,x_,y_,this.width);
	}
	,roundEndLine: function(x_,y_) {
		this.contour.line(this.x,this.y,x_,y_,this.width,3);
	}
	,mediumLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,false);
	}
	,mediumOverlapLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,false,true);
	}
	,fineLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,true);
	}
	,fineOverlapLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,true,true);
	}
	,createContour: function() {
		return new cornerContour_Contour(this.pen,this.endLine);
	}
	,reset: function() {
		this.contour = this.createContour();
		this.points = [];
		this.pointsClock = [];
		this.pointsAnti = [];
		this.points[0] = [];
		this.dim = [];
	}
	,pointsNoEndOverlap: function() {
		var p;
		var l;
		var j = 0;
		var pointsClean = [];
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var i = _g++;
			p = this.points[i];
			if(p.length > 2) {
				pointsClean[j++] = p;
			}
		}
		this.points = pointsClean;
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var i = _g++;
			p = this.points[i];
			l = p.length;
			var repeat = p[0] == p[l - 2] && p[1] == p[l - 1];
			if(repeat) {
				this.points[i].pop();
				this.points[i].pop();
				l -= 2;
			}
		}
		return this.points;
	}
	,pointsRewound: function() {
		var p;
		var l;
		var j = 0;
		var pointsClean = [];
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var i = _g++;
			p = this.points[i];
			if(p.length > 2) {
				pointsClean[j++] = p;
			}
		}
		this.points = pointsClean;
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var i = _g++;
			p = this.points[i];
			l = p.length;
			var repeat = p[0] == p[l - 2] && p[1] == p[l - 1];
			if(repeat) {
				this.points[i].pop();
				this.points[i].pop();
				l -= 2;
			}
			var cc = 0.;
			var k = 0;
			var x1;
			var y1;
			var x2;
			var y2;
			var last = l - 2;
			while(k < l) {
				x1 = p[k];
				y1 = p[k + 1];
				if(k == last) {
					x2 = p[0];
					y2 = p[1];
				} else {
					x2 = p[k + 2];
					y2 = p[k + 3];
				}
				cc += (x2 - x1) * (y2 + y1);
				k += 2;
			}
			this.points[i] = p;
		}
		return this.points;
	}
	,initDim: function() {
		return { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
	}
	,updateDim: function(x,y) {
		var d = this.dim[this.dim.length - 1];
		if(x < d.minX) {
			d.minX = x;
		}
		if(x > d.maxX) {
			d.maxX = x;
		}
		if(y < d.minY) {
			d.minY = y;
		}
		if(y > d.maxY) {
			d.maxY = y;
		}
	}
	,lineStyle: function(thickness,color) {
		if(this.turtleHistoryOn) {
			this.historyAdd("LINE_STYLE");
			this.historyParameters.push(thickness);
			this.historyParameters.push(color);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("LINE_STYLE");
			this.historyParameters.push(thickness);
			this.historyParameters.push(color);
		} else {
			this.width = thickness;
			this.pen.currentColor = color | 0;
		}
		return this;
	}
	,moveTo: function(x_,y_) {
		var tmp;
		switch(this.endLine) {
		case 0:case 1:case 6:case 9:case 12:case 15:case 18:
			tmp = false;
			break;
		case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
			tmp = true;
			break;
		}
		if(tmp) {
			this.contour.end(this.width);
		}
		this.x = x_;
		this.y = y_;
		var l = this.points.length;
		this.points[l] = [];
		this.points[l][0] = x_;
		this.points[l][1] = y_;
		this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
		this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
		this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
		var d = this.dim[this.dim.length - 1];
		if(x_ < d.minX) {
			d.minX = x_;
		}
		if(x_ > d.maxX) {
			d.maxX = x_;
		}
		if(y_ < d.minY) {
			d.minY = y_;
		}
		if(y_ > d.maxY) {
			d.maxY = y_;
		}
		this.contour.reset();
	}
	,lastClock: function() {
		if(this.contour.pointsClock.length != 0) {
			this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
			this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
		}
	}
	,getEdges: function() {
		var edges = [];
		var no = this.pointsClock.length;
		if(no > this.pointsAnti.length) {
			no = this.pointsAnti.length;
		}
		var pClock;
		var pAnti;
		var shape;
		var _g = 0;
		var _g1 = no;
		while(_g < _g1) {
			var s = _g++;
			pClock = this.pointsClock[s];
			pAnti = this.pointsAnti[s];
			var lc = pClock.length;
			var la = pAnti.length;
			edges[s] = [];
			shape = edges[s];
			var _g2 = 0;
			var _g3 = lc;
			while(_g2 < _g3) {
				var i = _g2++;
				shape[i] = pClock[i];
			}
			var j = shape.length;
			var l5 = la / 2 | 0;
			var _g4 = 0;
			var _g5 = l5;
			while(_g4 < _g5) {
				var i1 = _g4++;
				shape[j + i1 * 2] = pAnti[la - i1 * 2 - 1];
				shape[j + i1 * 2 + 1] = pAnti[la - i1 * 2];
			}
			j = shape.length;
			shape[j++] = pClock[0];
			shape[j] = pClock[1];
		}
		return edges;
	}
	,lineTo: function(x_,y_) {
		var repeat = this.x == x_ && this.y == y_;
		if(!repeat) {
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.y,x_,y_);
			}
			if(this.colourFunction != null) {
				this.pen.currentColor = this.colourFunction(this.pen.currentColor,this.x,this.y,x_,y_);
			}
			this.line(x_,y_);
			var l = this.points.length;
			var p = this.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.x = x_;
			this.y = y_;
		}
	}
	,quadTo: function(x1,y1,x2,y2) {
		this.tempArr = [];
		var p = this.tempArr;
		var ax = this.x;
		var ay = this.y;
		var x = ax - x1;
		var y = ay - y1;
		var x3 = x1 - x2;
		var y3 = y1 - y2;
		var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x3 * x3 + y3 * y3);
		if(approxDistance == 0) {
			approxDistance = 0.000001;
		}
		var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
		var l = p.length;
		p[l++] = ax;
		p[l++] = ay;
		var t = step;
		while(t < 1.) {
			var u = 1 - t;
			p[l++] = Math.pow(u,2) * ax + 2 * u * t * x1 + Math.pow(t,2) * x2;
			var u1 = 1 - t;
			p[l++] = Math.pow(u1,2) * ay + 2 * u1 * t * y1 + Math.pow(t,2) * y2;
			t += step;
		}
		p[l++] = x2;
		p[l++] = y2;
		var arr = this.tempArr;
		var withMove = false;
		if(withMove == null) {
			withMove = true;
		}
		var l = arr.length;
		var i = 2;
		if(withMove) {
			var x_ = arr[0];
			var y_ = arr[1];
			var tmp;
			switch(this.endLine) {
			case 0:case 1:case 6:case 9:case 12:case 15:case 18:
				tmp = false;
				break;
			case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
				tmp = true;
				break;
			}
			if(tmp) {
				this.contour.end(this.width);
			}
			this.x = x_;
			this.y = y_;
			var l1 = this.points.length;
			this.points[l1] = [];
			this.points[l1][0] = x_;
			this.points[l1][1] = y_;
			this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
			this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
			this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.contour.reset();
		} else {
			this.lineTo(arr[0],arr[1]);
		}
		var cx = (arr[0] + arr[l - 2]) / 2;
		var cy = (arr[1] + arr[l - 1]) / 2;
		var ox = this.x;
		var oy = this.y;
		while(i < l) {
			if(this.fill && this.penIsDown) {
				if(i > 0 && i < l - 2) {
					this.pen.triangle2DFill(arr[i - 2],arr[i - 1],arr[i],arr[i + 1],cx,cy);
				}
			}
			this.lineTo(arr[i],arr[i + 1]);
			i += 2;
		}
		if(this.fill && this.penIsDown) {
			var tmp;
			switch(this.endLine) {
			case 0:case 1:case 6:case 9:case 12:case 15:case 18:
				tmp = false;
				break;
			case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
				tmp = true;
				break;
			}
			if(tmp) {
				this.contour.end(this.width);
			}
			this.x = ox;
			this.y = oy;
			var l1 = this.points.length;
			this.points[l1] = [];
			this.points[l1][0] = ox;
			this.points[l1][1] = oy;
			this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
			this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
			this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = this.dim[this.dim.length - 1];
			if(ox < d.minX) {
				d.minX = ox;
			}
			if(ox > d.maxX) {
				d.maxX = ox;
			}
			if(oy < d.minY) {
				d.minY = oy;
			}
			if(oy > d.maxY) {
				d.maxY = oy;
			}
			this.contour.reset();
			this.lineTo(arr[l - 2],arr[l - 1]);
		}
		this.x = x2;
		this.y = y2;
	}
	,quadThru: function(x1,y1,x2,y2) {
		var newx = 2 * x1 - 0.5 * (this.x + x2);
		var newy = 2 * y1 - 0.5 * (this.y + y2);
		this.tempArr = [];
		var p = this.tempArr;
		var ax = this.x;
		var ay = this.y;
		var x = ax - newx;
		var y = ay - newy;
		var x1 = newx - x2;
		var y1 = newy - y2;
		var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
		if(approxDistance == 0) {
			approxDistance = 0.000001;
		}
		var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
		var l = p.length;
		p[l++] = ax;
		p[l++] = ay;
		var t = step;
		while(t < 1.) {
			var u = 1 - t;
			p[l++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * x2;
			var u1 = 1 - t;
			p[l++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * y2;
			t += step;
		}
		p[l++] = x2;
		p[l++] = y2;
		var arr = this.tempArr;
		var withMove = false;
		if(withMove == null) {
			withMove = true;
		}
		var l = arr.length;
		var i = 2;
		if(withMove) {
			var x_ = arr[0];
			var y_ = arr[1];
			var tmp;
			switch(this.endLine) {
			case 0:case 1:case 6:case 9:case 12:case 15:case 18:
				tmp = false;
				break;
			case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
				tmp = true;
				break;
			}
			if(tmp) {
				this.contour.end(this.width);
			}
			this.x = x_;
			this.y = y_;
			var l1 = this.points.length;
			this.points[l1] = [];
			this.points[l1][0] = x_;
			this.points[l1][1] = y_;
			this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
			this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
			this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.contour.reset();
		} else {
			this.lineTo(arr[0],arr[1]);
		}
		var cx = (arr[0] + arr[l - 2]) / 2;
		var cy = (arr[1] + arr[l - 1]) / 2;
		var ox = this.x;
		var oy = this.y;
		while(i < l) {
			if(this.fill && this.penIsDown) {
				if(i > 0 && i < l - 2) {
					this.pen.triangle2DFill(arr[i - 2],arr[i - 1],arr[i],arr[i + 1],cx,cy);
				}
			}
			this.lineTo(arr[i],arr[i + 1]);
			i += 2;
		}
		if(this.fill && this.penIsDown) {
			var tmp;
			switch(this.endLine) {
			case 0:case 1:case 6:case 9:case 12:case 15:case 18:
				tmp = false;
				break;
			case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
				tmp = true;
				break;
			}
			if(tmp) {
				this.contour.end(this.width);
			}
			this.x = ox;
			this.y = oy;
			var l1 = this.points.length;
			this.points[l1] = [];
			this.points[l1][0] = ox;
			this.points[l1][1] = oy;
			this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
			this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
			this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = this.dim[this.dim.length - 1];
			if(ox < d.minX) {
				d.minX = ox;
			}
			if(ox > d.maxX) {
				d.maxX = ox;
			}
			if(oy < d.minY) {
				d.minY = oy;
			}
			if(oy > d.maxY) {
				d.maxY = oy;
			}
			this.contour.reset();
			this.lineTo(arr[l - 2],arr[l - 1]);
		}
		this.x = x2;
		this.y = y2;
	}
	,curveTo: function(x1,y1,x2,y2,x3,y3) {
		this.tempArr = [];
		var p = this.tempArr;
		var ax = this.x;
		var ay = this.y;
		var x = ax - x1;
		var y = ay - y1;
		var x4 = x1 - x2;
		var y4 = y1 - y2;
		var x5 = x2 - x3;
		var y5 = y2 - y3;
		var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x4 * x4 + y4 * y4) + Math.sqrt(x5 * x5 + y5 * y5);
		if(approxDistance == 0) {
			approxDistance = 0.000001;
		}
		var step = Math.min(1 / (approxDistance * 0.707),0.03);
		var l = p.length;
		p[l++] = ax;
		p[l++] = ay;
		var t = step;
		while(t < 1.) {
			var u = 1 - t;
			p[l++] = Math.pow(u,3) * ax + 3 * Math.pow(u,2) * t * x1 + 3 * u * Math.pow(t,2) * x2 + Math.pow(t,3) * x3;
			var u1 = 1 - t;
			p[l++] = Math.pow(u1,3) * ay + 3 * Math.pow(u1,2) * t * y1 + 3 * u1 * Math.pow(t,2) * y2 + Math.pow(t,3) * y3;
			t += step;
		}
		p[l++] = x3;
		p[l++] = y3;
		var arr = this.tempArr;
		var withMove = false;
		if(withMove == null) {
			withMove = true;
		}
		var l = arr.length;
		var i = 2;
		if(withMove) {
			var x_ = arr[0];
			var y_ = arr[1];
			var tmp;
			switch(this.endLine) {
			case 0:case 1:case 6:case 9:case 12:case 15:case 18:
				tmp = false;
				break;
			case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
				tmp = true;
				break;
			}
			if(tmp) {
				this.contour.end(this.width);
			}
			this.x = x_;
			this.y = y_;
			var l1 = this.points.length;
			this.points[l1] = [];
			this.points[l1][0] = x_;
			this.points[l1][1] = y_;
			this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
			this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
			this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.contour.reset();
		} else {
			this.lineTo(arr[0],arr[1]);
		}
		var cx = (arr[0] + arr[l - 2]) / 2;
		var cy = (arr[1] + arr[l - 1]) / 2;
		var ox = this.x;
		var oy = this.y;
		while(i < l) {
			if(this.fill && this.penIsDown) {
				if(i > 0 && i < l - 2) {
					this.pen.triangle2DFill(arr[i - 2],arr[i - 1],arr[i],arr[i + 1],cx,cy);
				}
			}
			this.lineTo(arr[i],arr[i + 1]);
			i += 2;
		}
		if(this.fill && this.penIsDown) {
			var tmp;
			switch(this.endLine) {
			case 0:case 1:case 6:case 9:case 12:case 15:case 18:
				tmp = false;
				break;
			case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
				tmp = true;
				break;
			}
			if(tmp) {
				this.contour.end(this.width);
			}
			this.x = ox;
			this.y = oy;
			var l1 = this.points.length;
			this.points[l1] = [];
			this.points[l1][0] = ox;
			this.points[l1][1] = oy;
			this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
			this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
			this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = this.dim[this.dim.length - 1];
			if(ox < d.minX) {
				d.minX = ox;
			}
			if(ox > d.maxX) {
				d.maxX = ox;
			}
			if(oy < d.minY) {
				d.minY = oy;
			}
			if(oy > d.maxY) {
				d.maxY = oy;
			}
			this.contour.reset();
			this.lineTo(arr[l - 2],arr[l - 1]);
		}
		this.x = x3;
		this.y = y3;
	}
	,plotCoord: function(arr,withMove) {
		if(withMove == null) {
			withMove = true;
		}
		var l = arr.length;
		var i = 2;
		if(withMove) {
			var x_ = arr[0];
			var y_ = arr[1];
			var tmp;
			switch(this.endLine) {
			case 0:case 1:case 6:case 9:case 12:case 15:case 18:
				tmp = false;
				break;
			case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
				tmp = true;
				break;
			}
			if(tmp) {
				this.contour.end(this.width);
			}
			this.x = x_;
			this.y = y_;
			var l1 = this.points.length;
			this.points[l1] = [];
			this.points[l1][0] = x_;
			this.points[l1][1] = y_;
			this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
			this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
			this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.contour.reset();
		} else {
			this.lineTo(arr[0],arr[1]);
		}
		var cx = (arr[0] + arr[l - 2]) / 2;
		var cy = (arr[1] + arr[l - 1]) / 2;
		var ox = this.x;
		var oy = this.y;
		while(i < l) {
			if(this.fill && this.penIsDown) {
				if(i > 0 && i < l - 2) {
					this.pen.triangle2DFill(arr[i - 2],arr[i - 1],arr[i],arr[i + 1],cx,cy);
				}
			}
			this.lineTo(arr[i],arr[i + 1]);
			i += 2;
		}
		if(this.fill && this.penIsDown) {
			var tmp;
			switch(this.endLine) {
			case 0:case 1:case 6:case 9:case 12:case 15:case 18:
				tmp = false;
				break;
			case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
				tmp = true;
				break;
			}
			if(tmp) {
				this.contour.end(this.width);
			}
			this.x = ox;
			this.y = oy;
			var l1 = this.points.length;
			this.points[l1] = [];
			this.points[l1][0] = ox;
			this.points[l1][1] = oy;
			this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
			this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
			this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = this.dim[this.dim.length - 1];
			if(ox < d.minX) {
				d.minX = ox;
			}
			if(ox > d.maxX) {
				d.maxX = ox;
			}
			if(oy < d.minY) {
				d.minY = oy;
			}
			if(oy > d.maxY) {
				d.maxY = oy;
			}
			this.contour.reset();
			this.lineTo(arr[l - 2],arr[l - 1]);
		}
	}
	,traceHistory: function() {
		haxe_Log.trace(this.historyCommands,{ fileName : "cornerContour/Sketcher.hx", lineNumber : 332, className : "cornerContour.Sketcher", methodName : "traceHistory"});
		haxe_Log.trace(this.historyParameters,{ fileName : "cornerContour/Sketcher.hx", lineNumber : 333, className : "cornerContour.Sketcher", methodName : "traceHistory"});
	}
	,historyAdd: function(command) {
		this.historyParamPos.push(this.historyParameters.length);
		this.historyCommands.push(command);
		return this.historyParameters.length;
	}
	,playHistory: function(start,end) {
		if(end == null) {
			end = -1;
		}
		if(start == null) {
			start = 0;
		}
		this.playCommands(this.historyCommands,this.historyParameters,start,end);
	}
	,historyUndo: function(autoPlay) {
		if(autoPlay == null) {
			autoPlay = true;
		}
		this.historyCommands.pop();
		if(autoPlay) {
			this.playHistory();
		}
	}
	,playCommands: function(commands,parameters,start,end) {
		if(end == null) {
			end = -1;
		}
		if(start == null) {
			start = 0;
		}
		if(end == -1) {
			end = commands.length;
		}
		var v = parameters;
		var j = this.historyParamPos[start];
		this.turtleHistoryOn = false;
		var _g = start;
		var _g1 = end;
		while(_g < _g1) {
			var i = _g++;
			var command = commands[i];
			switch(command) {
			case "ARC":
				var radius = v[j];
				var degrees = v[j + 1];
				if(this.turtleHistoryOn) {
					this.historyAdd("ARC");
					this.historyParameters.push(radius);
					this.historyParameters.push(degrees);
				}
				if(radius != 0) {
					if(this.repeatCommands) {
						this.turtleCommands.push("ARC");
						this.turtleParameters.push(radius);
						this.turtleParameters.push(degrees);
					} else {
						var beta = degrees * Math.PI / 180 / 24;
						var alpha = (Math.PI - beta) / 2;
						var rotate = -(Math.PI / 2 - alpha);
						var baseLength = 0.5 * radius * Math.sin(beta / 2);
						var ox = this.x;
						var oy = this.y;
						var arr = [];
						arr.push(this.x);
						arr.push(this.y);
						var _g2 = 0;
						while(_g2 < 48) {
							var i1 = _g2++;
							this.rotation += rotate;
							var wasHistoryOn = this.turtleHistoryOn;
							this.turtleHistoryOn = false;
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD");
								this.historyParameters.push(baseLength);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD");
								this.turtleParameters.push(baseLength);
							} else {
								var nx = this.x + baseLength * Math.cos(this.rotation);
								var ny = this.y + baseLength * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = baseLength;
									this.lineTo(nx,ny);
								} else {
									var tmp;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp = true;
										break;
									}
									if(tmp) {
										this.contour.end(this.width);
									}
									this.x = nx;
									this.y = ny;
									var l = this.points.length;
									this.points[l] = [];
									this.points[l][0] = nx;
									this.points[l][1] = ny;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d = this.dim[this.dim.length - 1];
									if(nx < d.minX) {
										d.minX = nx;
									}
									if(nx > d.maxX) {
										d.maxX = nx;
									}
									if(ny < d.minY) {
										d.minY = ny;
									}
									if(ny > d.maxY) {
										d.maxY = ny;
									}
									this.contour.reset();
								}
							}
							this.turtleHistoryOn = wasHistoryOn;
							if(this.fill) {
								arr.push(this.x);
								arr.push(this.y);
							}
						}
						if(this.fill) {
							var cx = (ox + arr[arr.length - 2]) / 2;
							var cy = (oy + arr[arr.length - 1]) / 2;
							var l1 = arr.length;
							var i2 = 2;
							var lx = 0.;
							var ly = 0.;
							this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
							while(i2 < l1) {
								if(i2 > 2) {
									this.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
								}
								lx = arr[i2];
								ly = arr[i2 + 1];
								i2 += 2;
							}
						}
						arr.length = 0;
					}
				}
				j += 2;
				break;
			case "ARCH_BEZIER":
				var distance = v[j];
				var distance2 = v[j + 1];
				var radius1 = v[j + 2];
				if(this.turtleHistoryOn) {
					this.historyAdd("ARCH_BEZIER");
					this.historyParameters.push(distance);
					this.historyParameters.push(distance2);
					this.historyParameters.push(radius1);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("ARCH_BEZIER");
					this.turtleParameters.push(distance);
					this.turtleParameters.push(distance2);
					this.turtleParameters.push(radius1);
				} else {
					var nx1 = this.x + distance * Math.cos(this.rotation);
					var ny1 = this.y + distance * Math.sin(this.rotation);
					if(this.penIsDown) {
						var thruX = this.x + distance2 * Math.cos(this.rotation) - radius1 * Math.cos(this.rotation + Math.PI / 2);
						var thruY = this.y + distance2 * Math.sin(this.rotation) - radius1 * Math.sin(this.rotation + Math.PI / 2);
						var newx = 2 * thruX - 0.5 * (this.x + nx1);
						var newy = 2 * thruY - 0.5 * (this.y + ny1);
						this.tempArr = [];
						var p = this.tempArr;
						var ax = this.x;
						var ay = this.y;
						var x = ax - newx;
						var y = ay - newy;
						var x1 = newx - nx1;
						var y1 = newy - ny1;
						var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
						if(approxDistance == 0) {
							approxDistance = 0.000001;
						}
						var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
						var l2 = p.length;
						p[l2++] = ax;
						p[l2++] = ay;
						var t = step;
						while(t < 1.) {
							var u = 1 - t;
							p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
							var u1 = 1 - t;
							p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
							t += step;
						}
						p[l2++] = nx1;
						p[l2++] = ny1;
						var arr1 = this.tempArr;
						var withMove = false;
						if(withMove == null) {
							withMove = true;
						}
						var l3 = arr1.length;
						var i3 = 2;
						if(withMove) {
							var x_ = arr1[0];
							var y_ = arr1[1];
							var tmp1;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp1 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp1 = true;
								break;
							}
							if(tmp1) {
								this.contour.end(this.width);
							}
							this.x = x_;
							this.y = y_;
							var l4 = this.points.length;
							this.points[l4] = [];
							this.points[l4][0] = x_;
							this.points[l4][1] = y_;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d1 = this.dim[this.dim.length - 1];
							if(x_ < d1.minX) {
								d1.minX = x_;
							}
							if(x_ > d1.maxX) {
								d1.maxX = x_;
							}
							if(y_ < d1.minY) {
								d1.minY = y_;
							}
							if(y_ > d1.maxY) {
								d1.maxY = y_;
							}
							this.contour.reset();
						} else {
							this.lineTo(arr1[0],arr1[1]);
						}
						var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
						var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
						var ox1 = this.x;
						var oy1 = this.y;
						while(i3 < l3) {
							if(this.fill && this.penIsDown) {
								if(i3 > 0 && i3 < l3 - 2) {
									this.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
								}
							}
							this.lineTo(arr1[i3],arr1[i3 + 1]);
							i3 += 2;
						}
						if(this.fill && this.penIsDown) {
							var tmp2;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp2 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp2 = true;
								break;
							}
							if(tmp2) {
								this.contour.end(this.width);
							}
							this.x = ox1;
							this.y = oy1;
							var l5 = this.points.length;
							this.points[l5] = [];
							this.points[l5][0] = ox1;
							this.points[l5][1] = oy1;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d2 = this.dim[this.dim.length - 1];
							if(ox1 < d2.minX) {
								d2.minX = ox1;
							}
							if(ox1 > d2.maxX) {
								d2.maxX = ox1;
							}
							if(oy1 < d2.minY) {
								d2.minY = oy1;
							}
							if(oy1 > d2.maxY) {
								d2.maxY = oy1;
							}
							this.contour.reset();
							this.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
						}
						this.x = nx1;
						this.y = ny1;
					} else {
						var tmp3;
						switch(this.endLine) {
						case 0:case 1:case 6:case 9:case 12:case 15:case 18:
							tmp3 = false;
							break;
						case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
							tmp3 = true;
							break;
						}
						if(tmp3) {
							this.contour.end(this.width);
						}
						this.x = nx1;
						this.y = ny1;
						var l6 = this.points.length;
						this.points[l6] = [];
						this.points[l6][0] = nx1;
						this.points[l6][1] = ny1;
						this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
						this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
						this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d3 = this.dim[this.dim.length - 1];
						if(nx1 < d3.minX) {
							d3.minX = nx1;
						}
						if(nx1 > d3.maxX) {
							d3.maxX = nx1;
						}
						if(ny1 < d3.minY) {
							d3.minY = ny1;
						}
						if(ny1 > d3.maxY) {
							d3.maxY = ny1;
						}
						this.contour.reset();
					}
				}
				j += 3;
				break;
			case "ARC_SIDES":
				var radius2 = v[j];
				var degrees1 = v[j + 1];
				var sides = v[j + 2];
				if(sides == null) {
					sides = 24;
				}
				if(this.turtleHistoryOn) {
					if(sides == 24) {
						this.historyAdd("ARC");
						this.historyParameters.push(radius2);
						this.historyParameters.push(degrees1);
					} else {
						this.historyAdd("ARC_SIDES");
						this.historyParameters.push(radius2);
						this.historyParameters.push(degrees1);
						this.historyParameters.push(sides);
					}
				}
				if(radius2 != 0) {
					if(this.repeatCommands) {
						if(sides == 24) {
							this.turtleCommands.push("ARC");
							this.turtleParameters.push(radius2);
							this.turtleParameters.push(degrees1);
						} else {
							this.turtleCommands.push("ARC_SIDES");
							this.turtleParameters.push(radius2);
							this.turtleParameters.push(degrees1);
							this.turtleParameters.push(sides);
						}
					} else {
						var beta1 = degrees1 * Math.PI / 180 / sides;
						var alpha1 = (Math.PI - beta1) / 2;
						var rotate1 = -(Math.PI / 2 - alpha1);
						var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
						var ox2 = this.x;
						var oy2 = this.y;
						var arr2 = [];
						arr2.push(this.x);
						arr2.push(this.y);
						var _g3 = 0;
						while(_g3 < 48) {
							var i4 = _g3++;
							this.rotation += rotate1;
							var wasHistoryOn1 = this.turtleHistoryOn;
							this.turtleHistoryOn = false;
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD");
								this.historyParameters.push(baseLength1);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD");
								this.turtleParameters.push(baseLength1);
							} else {
								var nx2 = this.x + baseLength1 * Math.cos(this.rotation);
								var ny2 = this.y + baseLength1 * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = baseLength1;
									this.lineTo(nx2,ny2);
								} else {
									var tmp4;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp4 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp4 = true;
										break;
									}
									if(tmp4) {
										this.contour.end(this.width);
									}
									this.x = nx2;
									this.y = ny2;
									var l7 = this.points.length;
									this.points[l7] = [];
									this.points[l7][0] = nx2;
									this.points[l7][1] = ny2;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d4 = this.dim[this.dim.length - 1];
									if(nx2 < d4.minX) {
										d4.minX = nx2;
									}
									if(nx2 > d4.maxX) {
										d4.maxX = nx2;
									}
									if(ny2 < d4.minY) {
										d4.minY = ny2;
									}
									if(ny2 > d4.maxY) {
										d4.maxY = ny2;
									}
									this.contour.reset();
								}
							}
							this.turtleHistoryOn = wasHistoryOn1;
							if(this.fill) {
								arr2.push(this.x);
								arr2.push(this.y);
							}
						}
						if(this.fill) {
							var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
							var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
							var l8 = arr2.length;
							var i5 = 2;
							var lx1 = 0.;
							var ly1 = 0.;
							this.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
							while(i5 < l8) {
								if(i5 > 2) {
									this.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
								}
								lx1 = arr2[i5];
								ly1 = arr2[i5 + 1];
								i5 += 2;
							}
						}
						arr2.length = 0;
					}
				}
				j += 3;
				break;
			case "BACKWARD":
				var distance1 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("BACKWARD");
					this.historyParameters.push(distance1);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("BACKWARD");
					this.turtleParameters.push(distance1);
				} else {
					var nx3 = this.x + distance1 * Math.cos(this.rotation + Math.PI);
					var ny3 = this.y + distance1 * Math.sin(this.rotation + Math.PI);
					if(this.penIsDown) {
						this.lineTo(nx3,ny3);
					} else {
						var tmp5;
						switch(this.endLine) {
						case 0:case 1:case 6:case 9:case 12:case 15:case 18:
							tmp5 = false;
							break;
						case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
							tmp5 = true;
							break;
						}
						if(tmp5) {
							this.contour.end(this.width);
						}
						this.x = nx3;
						this.y = ny3;
						var l9 = this.points.length;
						this.points[l9] = [];
						this.points[l9][0] = nx3;
						this.points[l9][1] = ny3;
						this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
						this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
						this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d5 = this.dim[this.dim.length - 1];
						if(nx3 < d5.minX) {
							d5.minX = nx3;
						}
						if(nx3 > d5.maxX) {
							d5.maxX = nx3;
						}
						if(ny3 < d5.minY) {
							d5.minY = ny3;
						}
						if(ny3 > d5.maxY) {
							d5.maxY = ny3;
						}
						this.contour.reset();
					}
				}
				++j;
				break;
			case "BEGIN_REPEAT":
				var repeatCount_ = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("BEGIN_REPEAT");
					this.historyParameters.push(Math.round(repeatCount_));
				}
				if(this.repeatCommands == true) {
					this.repeatCommands = false;
					if(this.turtleHistoryOn) {
						this.historyAdd("END_REPEAT");
					}
					var wasHistoryOn2 = this.turtleHistoryOn;
					this.turtleHistoryOn = false;
					var v1 = this.turtleParameters;
					var j1 = 0;
					var _g4 = 0;
					var _g5 = this.repeatCount;
					while(_g4 < _g5) {
						var k = _g4++;
						var _g6 = 0;
						var _g7 = this.turtleCommands.length;
						while(_g6 < _g7) {
							var i6 = _g6++;
							var command1 = this.turtleCommands[i6];
							switch(command1) {
							case "ARC":
								var radius3 = v1[j1];
								var degrees2 = v1[j1 + 1];
								if(this.turtleHistoryOn) {
									this.historyAdd("ARC");
									this.historyParameters.push(radius3);
									this.historyParameters.push(degrees2);
								}
								if(radius3 != 0) {
									if(this.repeatCommands) {
										this.turtleCommands.push("ARC");
										this.turtleParameters.push(radius3);
										this.turtleParameters.push(degrees2);
									} else {
										var beta2 = degrees2 * Math.PI / 180 / 24;
										var alpha2 = (Math.PI - beta2) / 2;
										var rotate2 = -(Math.PI / 2 - alpha2);
										var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
										var ox3 = this.x;
										var oy3 = this.y;
										var arr3 = [];
										arr3.push(this.x);
										arr3.push(this.y);
										var _g8 = 0;
										while(_g8 < 48) {
											var i7 = _g8++;
											this.rotation += rotate2;
											var wasHistoryOn3 = this.turtleHistoryOn;
											this.turtleHistoryOn = false;
											if(this.turtleHistoryOn) {
												this.historyAdd("FORWARD");
												this.historyParameters.push(baseLength2);
											}
											if(this.repeatCommands) {
												this.turtleCommands.push("FORWARD");
												this.turtleParameters.push(baseLength2);
											} else {
												var nx4 = this.x + baseLength2 * Math.cos(this.rotation);
												var ny4 = this.y + baseLength2 * Math.sin(this.rotation);
												if(this.penIsDown) {
													this.lastDistance = baseLength2;
													this.lineTo(nx4,ny4);
												} else {
													var tmp6;
													switch(this.endLine) {
													case 0:case 1:case 6:case 9:case 12:case 15:case 18:
														tmp6 = false;
														break;
													case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
														tmp6 = true;
														break;
													}
													if(tmp6) {
														this.contour.end(this.width);
													}
													this.x = nx4;
													this.y = ny4;
													var l10 = this.points.length;
													this.points[l10] = [];
													this.points[l10][0] = nx4;
													this.points[l10][1] = ny4;
													this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
													this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
													this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
													var d6 = this.dim[this.dim.length - 1];
													if(nx4 < d6.minX) {
														d6.minX = nx4;
													}
													if(nx4 > d6.maxX) {
														d6.maxX = nx4;
													}
													if(ny4 < d6.minY) {
														d6.minY = ny4;
													}
													if(ny4 > d6.maxY) {
														d6.maxY = ny4;
													}
													this.contour.reset();
												}
											}
											this.turtleHistoryOn = wasHistoryOn3;
											if(this.fill) {
												arr3.push(this.x);
												arr3.push(this.y);
											}
										}
										if(this.fill) {
											var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
											var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
											var l11 = arr3.length;
											var i8 = 2;
											var lx2 = 0.;
											var ly2 = 0.;
											this.pen.triangle2DFill(ox3,oy3,arr3[0],arr3[1],cx3,cy3);
											while(i8 < l11) {
												if(i8 > 2) {
													this.pen.triangle2DFill(lx2,ly2,arr3[i8],arr3[i8 + 1],cx3,cy3);
												}
												lx2 = arr3[i8];
												ly2 = arr3[i8 + 1];
												i8 += 2;
											}
										}
										arr3.length = 0;
									}
								}
								j1 += 2;
								break;
							case "ARCH_BEZIER":
								var distance3 = v1[j1];
								var distance21 = v1[j1 + 1];
								var radius4 = v1[j1 + 2];
								if(this.turtleHistoryOn) {
									this.historyAdd("ARCH_BEZIER");
									this.historyParameters.push(distance3);
									this.historyParameters.push(distance21);
									this.historyParameters.push(radius4);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("ARCH_BEZIER");
									this.turtleParameters.push(distance3);
									this.turtleParameters.push(distance21);
									this.turtleParameters.push(radius4);
								} else {
									var nx5 = this.x + distance3 * Math.cos(this.rotation);
									var ny5 = this.y + distance3 * Math.sin(this.rotation);
									if(this.penIsDown) {
										var thruX1 = this.x + distance21 * Math.cos(this.rotation) - radius4 * Math.cos(this.rotation + Math.PI / 2);
										var thruY1 = this.y + distance21 * Math.sin(this.rotation) - radius4 * Math.sin(this.rotation + Math.PI / 2);
										var newx1 = 2 * thruX1 - 0.5 * (this.x + nx5);
										var newy1 = 2 * thruY1 - 0.5 * (this.y + ny5);
										this.tempArr = [];
										var p1 = this.tempArr;
										var ax1 = this.x;
										var ay1 = this.y;
										var x2 = ax1 - newx1;
										var y2 = ay1 - newy1;
										var x3 = newx1 - nx5;
										var y3 = newy1 - ny5;
										var approxDistance1 = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3);
										if(approxDistance1 == 0) {
											approxDistance1 = 0.000001;
										}
										var step1 = Math.min(1 / (approxDistance1 * 0.707),cornerContour_CurveMath_quadStep);
										var l12 = p1.length;
										p1[l12++] = ax1;
										p1[l12++] = ay1;
										var t1 = step1;
										while(t1 < 1.) {
											var u2 = 1 - t1;
											p1[l12++] = Math.pow(u2,2) * ax1 + 2 * u2 * t1 * newx1 + Math.pow(t1,2) * nx5;
											var u3 = 1 - t1;
											p1[l12++] = Math.pow(u3,2) * ay1 + 2 * u3 * t1 * newy1 + Math.pow(t1,2) * ny5;
											t1 += step1;
										}
										p1[l12++] = nx5;
										p1[l12++] = ny5;
										var arr4 = this.tempArr;
										var withMove1 = false;
										if(withMove1 == null) {
											withMove1 = true;
										}
										var l13 = arr4.length;
										var i9 = 2;
										if(withMove1) {
											var x_1 = arr4[0];
											var y_1 = arr4[1];
											var tmp7;
											switch(this.endLine) {
											case 0:case 1:case 6:case 9:case 12:case 15:case 18:
												tmp7 = false;
												break;
											case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
												tmp7 = true;
												break;
											}
											if(tmp7) {
												this.contour.end(this.width);
											}
											this.x = x_1;
											this.y = y_1;
											var l14 = this.points.length;
											this.points[l14] = [];
											this.points[l14][0] = x_1;
											this.points[l14][1] = y_1;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d7 = this.dim[this.dim.length - 1];
											if(x_1 < d7.minX) {
												d7.minX = x_1;
											}
											if(x_1 > d7.maxX) {
												d7.maxX = x_1;
											}
											if(y_1 < d7.minY) {
												d7.minY = y_1;
											}
											if(y_1 > d7.maxY) {
												d7.maxY = y_1;
											}
											this.contour.reset();
										} else {
											this.lineTo(arr4[0],arr4[1]);
										}
										var cx4 = (arr4[0] + arr4[l13 - 2]) / 2;
										var cy4 = (arr4[1] + arr4[l13 - 1]) / 2;
										var ox4 = this.x;
										var oy4 = this.y;
										while(i9 < l13) {
											if(this.fill && this.penIsDown) {
												if(i9 > 0 && i9 < l13 - 2) {
													this.pen.triangle2DFill(arr4[i9 - 2],arr4[i9 - 1],arr4[i9],arr4[i9 + 1],cx4,cy4);
												}
											}
											this.lineTo(arr4[i9],arr4[i9 + 1]);
											i9 += 2;
										}
										if(this.fill && this.penIsDown) {
											var tmp8;
											switch(this.endLine) {
											case 0:case 1:case 6:case 9:case 12:case 15:case 18:
												tmp8 = false;
												break;
											case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
												tmp8 = true;
												break;
											}
											if(tmp8) {
												this.contour.end(this.width);
											}
											this.x = ox4;
											this.y = oy4;
											var l15 = this.points.length;
											this.points[l15] = [];
											this.points[l15][0] = ox4;
											this.points[l15][1] = oy4;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d8 = this.dim[this.dim.length - 1];
											if(ox4 < d8.minX) {
												d8.minX = ox4;
											}
											if(ox4 > d8.maxX) {
												d8.maxX = ox4;
											}
											if(oy4 < d8.minY) {
												d8.minY = oy4;
											}
											if(oy4 > d8.maxY) {
												d8.maxY = oy4;
											}
											this.contour.reset();
											this.lineTo(arr4[l13 - 2],arr4[l13 - 1]);
										}
										this.x = nx5;
										this.y = ny5;
									} else {
										var tmp9;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp9 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp9 = true;
											break;
										}
										if(tmp9) {
											this.contour.end(this.width);
										}
										this.x = nx5;
										this.y = ny5;
										var l16 = this.points.length;
										this.points[l16] = [];
										this.points[l16][0] = nx5;
										this.points[l16][1] = ny5;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d9 = this.dim[this.dim.length - 1];
										if(nx5 < d9.minX) {
											d9.minX = nx5;
										}
										if(nx5 > d9.maxX) {
											d9.maxX = nx5;
										}
										if(ny5 < d9.minY) {
											d9.minY = ny5;
										}
										if(ny5 > d9.maxY) {
											d9.maxY = ny5;
										}
										this.contour.reset();
									}
								}
								j1 += 3;
								break;
							case "ARC_SIDES":
								var radius5 = v1[j1];
								var degrees3 = v1[j1 + 1];
								var sides1 = v1[j1 + 2];
								if(sides1 == null) {
									sides1 = 24;
								}
								if(this.turtleHistoryOn) {
									if(sides1 == 24) {
										this.historyAdd("ARC");
										this.historyParameters.push(radius5);
										this.historyParameters.push(degrees3);
									} else {
										this.historyAdd("ARC_SIDES");
										this.historyParameters.push(radius5);
										this.historyParameters.push(degrees3);
										this.historyParameters.push(sides1);
									}
								}
								if(radius5 != 0) {
									if(this.repeatCommands) {
										if(sides1 == 24) {
											this.turtleCommands.push("ARC");
											this.turtleParameters.push(radius5);
											this.turtleParameters.push(degrees3);
										} else {
											this.turtleCommands.push("ARC_SIDES");
											this.turtleParameters.push(radius5);
											this.turtleParameters.push(degrees3);
											this.turtleParameters.push(sides1);
										}
									} else {
										var beta3 = degrees3 * Math.PI / 180 / sides1;
										var alpha3 = (Math.PI - beta3) / 2;
										var rotate3 = -(Math.PI / 2 - alpha3);
										var baseLength3 = 0.5 * radius5 * Math.sin(beta3 / 2);
										var ox5 = this.x;
										var oy5 = this.y;
										var arr5 = [];
										arr5.push(this.x);
										arr5.push(this.y);
										var _g9 = 0;
										while(_g9 < 48) {
											var i10 = _g9++;
											this.rotation += rotate3;
											var wasHistoryOn4 = this.turtleHistoryOn;
											this.turtleHistoryOn = false;
											if(this.turtleHistoryOn) {
												this.historyAdd("FORWARD");
												this.historyParameters.push(baseLength3);
											}
											if(this.repeatCommands) {
												this.turtleCommands.push("FORWARD");
												this.turtleParameters.push(baseLength3);
											} else {
												var nx6 = this.x + baseLength3 * Math.cos(this.rotation);
												var ny6 = this.y + baseLength3 * Math.sin(this.rotation);
												if(this.penIsDown) {
													this.lastDistance = baseLength3;
													this.lineTo(nx6,ny6);
												} else {
													var tmp10;
													switch(this.endLine) {
													case 0:case 1:case 6:case 9:case 12:case 15:case 18:
														tmp10 = false;
														break;
													case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
														tmp10 = true;
														break;
													}
													if(tmp10) {
														this.contour.end(this.width);
													}
													this.x = nx6;
													this.y = ny6;
													var l17 = this.points.length;
													this.points[l17] = [];
													this.points[l17][0] = nx6;
													this.points[l17][1] = ny6;
													this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
													this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
													this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
													var d10 = this.dim[this.dim.length - 1];
													if(nx6 < d10.minX) {
														d10.minX = nx6;
													}
													if(nx6 > d10.maxX) {
														d10.maxX = nx6;
													}
													if(ny6 < d10.minY) {
														d10.minY = ny6;
													}
													if(ny6 > d10.maxY) {
														d10.maxY = ny6;
													}
													this.contour.reset();
												}
											}
											this.turtleHistoryOn = wasHistoryOn4;
											if(this.fill) {
												arr5.push(this.x);
												arr5.push(this.y);
											}
										}
										if(this.fill) {
											var cx5 = (ox5 + arr5[arr5.length - 2]) / 2;
											var cy5 = (oy5 + arr5[arr5.length - 1]) / 2;
											var l18 = arr5.length;
											var i11 = 2;
											var lx3 = 0.;
											var ly3 = 0.;
											this.pen.triangle2DFill(ox5,oy5,arr5[0],arr5[1],cx5,cy5);
											while(i11 < l18) {
												if(i11 > 2) {
													this.pen.triangle2DFill(lx3,ly3,arr5[i11],arr5[i11 + 1],cx5,cy5);
												}
												lx3 = arr5[i11];
												ly3 = arr5[i11 + 1];
												i11 += 2;
											}
										}
										arr5.length = 0;
									}
								}
								j1 += 3;
								break;
							case "BACKWARD":
								var distance4 = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("BACKWARD");
									this.historyParameters.push(distance4);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("BACKWARD");
									this.turtleParameters.push(distance4);
								} else {
									var nx7 = this.x + distance4 * Math.cos(this.rotation + Math.PI);
									var ny7 = this.y + distance4 * Math.sin(this.rotation + Math.PI);
									if(this.penIsDown) {
										this.lineTo(nx7,ny7);
									} else {
										var tmp11;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp11 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp11 = true;
											break;
										}
										if(tmp11) {
											this.contour.end(this.width);
										}
										this.x = nx7;
										this.y = ny7;
										var l19 = this.points.length;
										this.points[l19] = [];
										this.points[l19][0] = nx7;
										this.points[l19][1] = ny7;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d11 = this.dim[this.dim.length - 1];
										if(nx7 < d11.minX) {
											d11.minX = nx7;
										}
										if(nx7 > d11.maxX) {
											d11.maxX = nx7;
										}
										if(ny7 < d11.minY) {
											d11.minY = ny7;
										}
										if(ny7 > d11.maxY) {
											d11.maxY = ny7;
										}
										this.contour.reset();
									}
								}
								++j1;
								break;
							case "BEGIN_REPEAT":
								break;
							case "BLACK":
								if(this.turtleHistoryOn) {
									this.historyAdd("BLACK");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("BLACK");
								} else {
									this.pen.currentColor = -16777216;
								}
								break;
							case "BLUE":
								if(this.turtleHistoryOn) {
									this.historyAdd("BLUE");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("BLUE");
								} else {
									this.pen.currentColor = -16776961;
								}
								break;
							case "BROWN":
								if(this.turtleHistoryOn) {
									this.historyAdd("BROWN");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("BROWN");
								} else {
									this.pen.currentColor = -6594501;
								}
								break;
							case "CIRCLE":
								var radius6 = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("CIRCLE");
									this.historyParameters.push(radius6);
								}
								if(radius6 != 0) {
									if(this.repeatCommands) {
										this.turtleCommands.push("CIRCLE");
										this.turtleParameters.push(radius6);
									} else {
										var beta4 = 2 * Math.PI / 24;
										var alpha4 = (Math.PI - beta4) / 2;
										var rotate4 = -(Math.PI / 2 - alpha4);
										var baseLength4 = 0.5 * radius6 * Math.sin(beta4 / 2);
										var ox6 = this.x;
										var oy6 = this.y;
										var arr6 = [];
										var _g10 = 0;
										while(_g10 < 48) {
											var i12 = _g10++;
											this.rotation += rotate4;
											var wasHistoryOn5 = this.turtleHistoryOn;
											this.turtleHistoryOn = false;
											if(this.turtleHistoryOn) {
												this.historyAdd("FORWARD");
												this.historyParameters.push(baseLength4);
											}
											if(this.repeatCommands) {
												this.turtleCommands.push("FORWARD");
												this.turtleParameters.push(baseLength4);
											} else {
												var nx8 = this.x + baseLength4 * Math.cos(this.rotation);
												var ny8 = this.y + baseLength4 * Math.sin(this.rotation);
												if(this.penIsDown) {
													this.lastDistance = baseLength4;
													this.lineTo(nx8,ny8);
												} else {
													var tmp12;
													switch(this.endLine) {
													case 0:case 1:case 6:case 9:case 12:case 15:case 18:
														tmp12 = false;
														break;
													case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
														tmp12 = true;
														break;
													}
													if(tmp12) {
														this.contour.end(this.width);
													}
													this.x = nx8;
													this.y = ny8;
													var l20 = this.points.length;
													this.points[l20] = [];
													this.points[l20][0] = nx8;
													this.points[l20][1] = ny8;
													this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
													this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
													this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
													var d12 = this.dim[this.dim.length - 1];
													if(nx8 < d12.minX) {
														d12.minX = nx8;
													}
													if(nx8 > d12.maxX) {
														d12.maxX = nx8;
													}
													if(ny8 < d12.minY) {
														d12.minY = ny8;
													}
													if(ny8 > d12.maxY) {
														d12.maxY = ny8;
													}
													this.contour.reset();
												}
											}
											this.turtleHistoryOn = wasHistoryOn5;
											if(this.fill) {
												arr6.push(this.x);
												arr6.push(this.y);
											}
										}
										if(this.fill) {
											var cx6 = (ox6 + arr6[arr6.length - 2]) / 2;
											var cy6 = (oy6 + arr6[arr6.length - 1]) / 2;
											var l21 = arr6.length;
											var i13 = 2;
											var lx4 = 0.;
											var ly4 = 0.;
											while(i13 < l21) {
												if(i13 > 2) {
													this.pen.triangle2DFill(lx4,ly4,arr6[i13],arr6[i13 + 1],cx6,cy6);
												}
												lx4 = arr6[i13];
												ly4 = arr6[i13 + 1];
												i13 += 2;
											}
										}
										arr6.length = 0;
									}
								}
								++j1;
								break;
							case "CIRCLE_SIDES":
								var radius7 = v1[j1];
								var sides2 = v1[j1 + 1];
								if(sides2 == null) {
									sides2 = 24;
								}
								if(this.turtleHistoryOn) {
									if(sides2 == 24) {
										this.historyAdd("CIRCLE");
										this.historyParameters.push(radius7);
									} else {
										this.historyAdd("CIRCLE_SIDES");
										this.historyParameters.push(radius7);
										this.historyParameters.push(sides2);
									}
								}
								if(radius7 != 0) {
									if(this.repeatCommands) {
										if(sides2 == 24) {
											this.turtleCommands.push("CIRCLE");
											this.turtleParameters.push(radius7);
										} else {
											this.turtleCommands.push("CIRCLE_SIDES");
											this.turtleParameters.push(radius7);
											this.turtleParameters.push(sides2);
										}
									} else {
										var beta5 = 2 * Math.PI / sides2;
										var alpha5 = (Math.PI - beta5) / 2;
										var rotate5 = -(Math.PI / 2 - alpha5);
										var baseLength5 = 0.5 * radius7 * Math.sin(beta5 / 2);
										var ox7 = this.x;
										var oy7 = this.y;
										var arr7 = [];
										var _g11 = 0;
										while(_g11 < 48) {
											var i14 = _g11++;
											this.rotation += rotate5;
											var wasHistoryOn6 = this.turtleHistoryOn;
											this.turtleHistoryOn = false;
											if(this.turtleHistoryOn) {
												this.historyAdd("FORWARD");
												this.historyParameters.push(baseLength5);
											}
											if(this.repeatCommands) {
												this.turtleCommands.push("FORWARD");
												this.turtleParameters.push(baseLength5);
											} else {
												var nx9 = this.x + baseLength5 * Math.cos(this.rotation);
												var ny9 = this.y + baseLength5 * Math.sin(this.rotation);
												if(this.penIsDown) {
													this.lastDistance = baseLength5;
													this.lineTo(nx9,ny9);
												} else {
													var tmp13;
													switch(this.endLine) {
													case 0:case 1:case 6:case 9:case 12:case 15:case 18:
														tmp13 = false;
														break;
													case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
														tmp13 = true;
														break;
													}
													if(tmp13) {
														this.contour.end(this.width);
													}
													this.x = nx9;
													this.y = ny9;
													var l22 = this.points.length;
													this.points[l22] = [];
													this.points[l22][0] = nx9;
													this.points[l22][1] = ny9;
													this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
													this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
													this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
													var d13 = this.dim[this.dim.length - 1];
													if(nx9 < d13.minX) {
														d13.minX = nx9;
													}
													if(nx9 > d13.maxX) {
														d13.maxX = nx9;
													}
													if(ny9 < d13.minY) {
														d13.minY = ny9;
													}
													if(ny9 > d13.maxY) {
														d13.maxY = ny9;
													}
													this.contour.reset();
												}
											}
											this.turtleHistoryOn = wasHistoryOn6;
											if(this.fill) {
												arr7.push(this.x);
												arr7.push(this.y);
											}
										}
										if(this.fill) {
											var cx7 = (ox7 + arr7[arr7.length - 2]) / 2;
											var cy7 = (oy7 + arr7[arr7.length - 1]) / 2;
											var l23 = arr7.length;
											var i15 = 2;
											var lx5 = 0.;
											var ly5 = 0.;
											while(i15 < l23) {
												if(i15 > 2) {
													this.pen.triangle2DFill(lx5,ly5,arr7[i15],arr7[i15 + 1],cx7,cy7);
												}
												lx5 = arr7[i15];
												ly5 = arr7[i15 + 1];
												i15 += 2;
											}
										}
										arr7.length = 0;
									}
								}
								j1 += 2;
								break;
							case "CYAN":
								if(this.turtleHistoryOn) {
									this.historyAdd("CYAN");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("CYAN");
								} else {
									this.pen.currentColor = -16711681;
								}
								break;
							case "DARKISH_BLUE":
								if(this.turtleHistoryOn) {
									this.historyAdd("DARKISH_BLUE");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("DARKISH_BLUE");
								} else {
									this.pen.currentColor = -8864837;
								}
								break;
							case "DARK_GREEN":
								if(this.turtleHistoryOn) {
									this.historyAdd("DARK_GREEN");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("DARK_GREEN");
								} else {
									this.pen.currentColor = -10182080;
								}
								break;
							case "EAST":
								if(this.turtleHistoryOn) {
									this.historyAdd("WEST");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("EAST");
								} else {
									this.rotation = Math.PI;
								}
								break;
							case "END_REPEAT":
								break;
							case "FILL_OFF":
								if(this.turtleHistoryOn) {
									this.historyAdd("FILL_OFF");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FILL_OFF");
								} else {
									this.fill = false;
								}
								break;
							case "FILL_ON":
								if(this.turtleHistoryOn) {
									this.historyAdd("FILL_ON");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FILL_ON");
								} else {
									this.fill = true;
								}
								break;
							case "FORWARD":
								var distance5 = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD");
									this.historyParameters.push(distance5);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD");
									this.turtleParameters.push(distance5);
								} else {
									var nx10 = this.x + distance5 * Math.cos(this.rotation);
									var ny10 = this.y + distance5 * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = distance5;
										this.lineTo(nx10,ny10);
									} else {
										var tmp14;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp14 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp14 = true;
											break;
										}
										if(tmp14) {
											this.contour.end(this.width);
										}
										this.x = nx10;
										this.y = ny10;
										var l24 = this.points.length;
										this.points[l24] = [];
										this.points[l24][0] = nx10;
										this.points[l24][1] = ny10;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d14 = this.dim[this.dim.length - 1];
										if(nx10 < d14.minX) {
											d14.minX = nx10;
										}
										if(nx10 > d14.maxX) {
											d14.maxX = nx10;
										}
										if(ny10 < d14.minY) {
											d14.minY = ny10;
										}
										if(ny10 > d14.maxY) {
											d14.maxY = ny10;
										}
										this.contour.reset();
									}
								}
								++j1;
								break;
							case "FORWARD_CHANGE":
								var deltaDistance = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD_CHANGE");
									this.historyParameters.push(deltaDistance);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD_CHANGE");
									this.turtleParameters.push(deltaDistance);
								} else {
									var distance6 = this.lastDistance + deltaDistance;
									var nx11 = this.x + distance6 * Math.cos(this.rotation);
									var ny11 = this.y + distance6 * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = distance6 + deltaDistance;
										this.lineTo(nx11,ny11);
									} else {
										var tmp15;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp15 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp15 = true;
											break;
										}
										if(tmp15) {
											this.contour.end(this.width);
										}
										this.x = nx11;
										this.y = ny11;
										var l25 = this.points.length;
										this.points[l25] = [];
										this.points[l25][0] = nx11;
										this.points[l25][1] = ny11;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d15 = this.dim[this.dim.length - 1];
										if(nx11 < d15.minX) {
											d15.minX = nx11;
										}
										if(nx11 > d15.maxX) {
											d15.maxX = nx11;
										}
										if(ny11 < d15.minY) {
											d15.minY = ny11;
										}
										if(ny11 > d15.maxY) {
											d15.maxY = ny11;
										}
										this.contour.reset();
									}
								}
								++j1;
								break;
							case "FORWARD_FACTOR":
								var factor = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD_FACTOR");
									this.historyParameters.push(factor);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD_FACTOR");
									this.turtleParameters.push(factor);
								} else {
									var distance7 = this.lastDistance * factor;
									var nx12 = this.x + distance7 * Math.cos(this.rotation);
									var ny12 = this.y + distance7 * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = distance7;
										this.lineTo(nx12,ny12);
									} else {
										var tmp16;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp16 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp16 = true;
											break;
										}
										if(tmp16) {
											this.contour.end(this.width);
										}
										this.x = nx12;
										this.y = ny12;
										var l26 = this.points.length;
										this.points[l26] = [];
										this.points[l26][0] = nx12;
										this.points[l26][1] = ny12;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d16 = this.dim[this.dim.length - 1];
										if(nx12 < d16.minX) {
											d16.minX = nx12;
										}
										if(nx12 > d16.maxX) {
											d16.maxX = nx12;
										}
										if(ny12 < d16.minY) {
											d16.minY = ny12;
										}
										if(ny12 > d16.maxY) {
											d16.maxY = ny12;
										}
										this.contour.reset();
									}
								}
								++j1;
								break;
							case "GREEN":
								if(this.turtleHistoryOn) {
									this.historyAdd("GREEN");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("GREEN");
								} else {
									this.pen.currentColor = -16711936;
								}
								break;
							case "GREY":
								if(this.turtleHistoryOn) {
									this.historyAdd("GREY");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("GREY");
								} else {
									this.pen.currentColor = -4737097;
								}
								break;
							case "LEFT":
								var degrees4 = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("LEFT");
									this.historyParameters.push(degrees4);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("LEFT");
									this.turtleParameters.push(degrees4);
								} else {
									this.rotation -= degrees4 * Math.PI / 180;
								}
								++j1;
								break;
							case "LIGHT_BROWN":
								if(this.turtleHistoryOn) {
									this.historyAdd("LIGHT_BROWN");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("LIGHT_BROWN");
								} else {
									this.pen.currentColor = -3831790;
								}
								break;
							case "LINE_STYLE":
								var thickness = v1[j1];
								var color = v1[j1 + 1];
								if(this.turtleHistoryOn) {
									this.historyAdd("LINE_STYLE");
									this.historyParameters.push(thickness);
									this.historyParameters.push(color);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("LINE_STYLE");
									this.historyParameters.push(thickness);
									this.historyParameters.push(color);
								} else {
									this.width = thickness;
									this.pen.currentColor = color | 0;
								}
								j1 += 2;
								break;
							case "MAGENTA":
								if(this.turtleHistoryOn) {
									this.historyAdd("MAGENTA");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("MAGENTA");
								} else {
									this.pen.currentColor = -65281;
								}
								break;
							case "MOVE_PEN":
								var distance8 = v1[j1];
								if(this.repeatCommands) {
									this.turtleCommands.push("MOVE_PEN");
									this.turtleParameters.push(distance8);
								} else if(this.penIsDown) {
									if(this.turtleHistoryOn) {
										this.historyAdd("PEN_UP");
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("PEN_UP");
									} else {
										this.penIsDown = false;
									}
									if(this.turtleHistoryOn) {
										this.historyAdd("FORWARD");
										this.historyParameters.push(distance8);
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("FORWARD");
										this.turtleParameters.push(distance8);
									} else {
										var nx13 = this.x + distance8 * Math.cos(this.rotation);
										var ny13 = this.y + distance8 * Math.sin(this.rotation);
										if(this.penIsDown) {
											this.lastDistance = distance8;
											this.lineTo(nx13,ny13);
										} else {
											var tmp17;
											switch(this.endLine) {
											case 0:case 1:case 6:case 9:case 12:case 15:case 18:
												tmp17 = false;
												break;
											case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
												tmp17 = true;
												break;
											}
											if(tmp17) {
												this.contour.end(this.width);
											}
											this.x = nx13;
											this.y = ny13;
											var l27 = this.points.length;
											this.points[l27] = [];
											this.points[l27][0] = nx13;
											this.points[l27][1] = ny13;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d17 = this.dim[this.dim.length - 1];
											if(nx13 < d17.minX) {
												d17.minX = nx13;
											}
											if(nx13 > d17.maxX) {
												d17.maxX = nx13;
											}
											if(ny13 < d17.minY) {
												d17.minY = ny13;
											}
											if(ny13 > d17.maxY) {
												d17.maxY = ny13;
											}
											this.contour.reset();
										}
									}
									if(this.turtleHistoryOn) {
										this.historyAdd("PEN_DOWN");
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("PEN_DOWN");
									} else {
										this.penIsDown = true;
									}
								} else {
									if(this.turtleHistoryOn) {
										this.historyAdd("FORWARD");
										this.historyParameters.push(distance8);
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("FORWARD");
										this.turtleParameters.push(distance8);
									} else {
										var nx14 = this.x + distance8 * Math.cos(this.rotation);
										var ny14 = this.y + distance8 * Math.sin(this.rotation);
										if(this.penIsDown) {
											this.lastDistance = distance8;
											this.lineTo(nx14,ny14);
										} else {
											var tmp18;
											switch(this.endLine) {
											case 0:case 1:case 6:case 9:case 12:case 15:case 18:
												tmp18 = false;
												break;
											case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
												tmp18 = true;
												break;
											}
											if(tmp18) {
												this.contour.end(this.width);
											}
											this.x = nx14;
											this.y = ny14;
											var l28 = this.points.length;
											this.points[l28] = [];
											this.points[l28][0] = nx14;
											this.points[l28][1] = ny14;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d18 = this.dim[this.dim.length - 1];
											if(nx14 < d18.minX) {
												d18.minX = nx14;
											}
											if(nx14 > d18.maxX) {
												d18.maxX = nx14;
											}
											if(ny14 < d18.minY) {
												d18.minY = ny14;
											}
											if(ny14 > d18.maxY) {
												d18.maxY = ny14;
											}
											this.contour.reset();
										}
									}
								}
								++j1;
								break;
							case "NORTH":
								if(this.turtleHistoryOn) {
									this.historyAdd("NORTH");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("NORTH");
								} else {
									this.rotation = -Math.PI / 2;
								}
								break;
							case "ORANGE":
								if(this.turtleHistoryOn) {
									this.historyAdd("ORANGE");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("ORANGE");
								} else {
									this.pen.currentColor = -23808;
								}
								break;
							case "PEN_COLOR":
								var r = v1[j1];
								var g = v1[j1 + 1];
								var b = v1[j1 + 2];
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_COLOR");
									this.historyParameters.push(r);
									this.historyParameters.push(g);
									this.historyParameters.push(b);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_COLOR");
									this.turtleParameters.push(r);
									this.turtleParameters.push(g);
									this.turtleParameters.push(b);
								} else {
									this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
								}
								j1 += 3;
								break;
							case "PEN_COLOR_B":
								var r1 = v1[j1];
								var g1 = v1[j1 + 1];
								var b1 = v1[j1 + 2];
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_COLOR_B");
									this.historyParameters.push(r1);
									this.historyParameters.push(g1);
									this.historyParameters.push(b1);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_COLOR_B");
									this.turtleParameters.push(r1);
									this.turtleParameters.push(g1);
									this.turtleParameters.push(b1);
								} else {
									this.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
								}
								j1 += 3;
								break;
							case "PEN_COLOR_C":
								var r2 = v1[j1];
								var g2 = v1[j1 + 1];
								var b2 = v1[j1 + 2];
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_COLOR_C");
									this.historyParameters.push(r2);
									this.historyParameters.push(g2);
									this.historyParameters.push(b2);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_COLOR_C");
									this.turtleParameters.push(r2);
									this.turtleParameters.push(g2);
									this.turtleParameters.push(b2);
								} else {
									this.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
								}
								j1 += 3;
								break;
							case "PEN_COLOR_CHANGE":
								var r3 = v1[j1];
								var g3 = v1[j1 + 1];
								var b3 = v1[j1 + 2];
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_COLOR_CHANGE");
									this.historyParameters.push(r3);
									this.historyParameters.push(g3);
									this.historyParameters.push(b3);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_COLOR_CHANGE");
									this.turtleParameters.push(r3);
									this.turtleParameters.push(g3);
									this.turtleParameters.push(b3);
								} else {
									var c = this.pen.currentColor;
									var r0 = (c >> 16 & 255) / 255;
									var g0 = (c >> 8 & 255) / 255;
									var b0 = (c & 255) / 255;
									this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
								}
								j1 += 3;
								break;
							case "PEN_COLOR_CHANGE_B":
								var r4 = v1[j1];
								var g4 = v1[j1 + 1];
								var b4 = v1[j1 + 2];
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_COLOR_CHANGE_B");
									this.historyParameters.push(r4);
									this.historyParameters.push(g4);
									this.historyParameters.push(b4);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_COLOR_CHANGE_B");
									this.turtleParameters.push(r4);
									this.turtleParameters.push(g4);
									this.turtleParameters.push(b4);
								} else {
									var c1 = this.pen.colorB;
									var r01 = (c1 >> 16 & 255) / 255;
									var g01 = (c1 >> 8 & 255) / 255;
									var b01 = (c1 & 255) / 255;
									this.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
								}
								j1 += 3;
								break;
							case "PEN_COLOR_CHANGE_C":
								var r5 = v1[j1];
								var g5 = v1[j1 + 1];
								var b5 = v1[j1 + 2];
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_COLOR_CHANGE_C");
									this.historyParameters.push(r5);
									this.historyParameters.push(g5);
									this.historyParameters.push(b5);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_COLOR_CHANGE_C");
									this.turtleParameters.push(r5);
									this.turtleParameters.push(g5);
									this.turtleParameters.push(b5);
								} else {
									var c2 = this.pen.colorC;
									var r02 = (c2 >> 16 & 255) / 255;
									var g02 = (c2 >> 8 & 255) / 255;
									var b02 = (c2 & 255) / 255;
									this.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
								}
								j1 += 3;
								break;
							case "PEN_DOWN":
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_DOWN");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_DOWN");
								} else {
									this.penIsDown = true;
								}
								break;
							case "PEN_SIZE":
								var w = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_SIZE");
									this.historyParameters.push(w);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_SIZE");
									this.turtleParameters.push(w);
								} else {
									this.width = w;
								}
								++j1;
								break;
							case "PEN_SIZE_CHANGE":
								var dw = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_SIZE_CHANGE");
									this.historyParameters.push(dw);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_SIZE_CHANGE");
									this.turtleParameters.push(dw);
								} else {
									this.width += dw;
								}
								++j1;
								break;
							case "PEN_SIZE_FACTOR":
								var factor1 = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_SIZE_FACTOR");
									this.historyParameters.push(factor1);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_SIZE_FACTOR");
									this.turtleParameters.push(factor1);
								} else {
									this.width *= factor1;
								}
								++j1;
								break;
							case "PEN_UP":
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_UP");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_UP");
								} else {
									this.penIsDown = false;
								}
								break;
							case "PLUM":
								if(this.turtleHistoryOn) {
									this.historyAdd("PLUM");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PLUM");
								} else {
									this.pen.currentColor = -7310896;
								}
								break;
							case "RED":
								if(this.turtleHistoryOn) {
									this.historyAdd("RED");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("RED");
								} else {
									this.pen.currentColor = -65536;
								}
								break;
							case "RIGHT":
								var degrees5 = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("RIGHT");
									this.historyParameters.push(degrees5);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("RIGHT");
									this.turtleParameters.push(degrees5);
								} else {
									this.rotation += degrees5 * Math.PI / 180;
								}
								++j1;
								break;
							case "SET_ANGLE":
								var degrees6 = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("SET_ANGLE");
									this.historyParameters.push(degrees6);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("SET_ANGLE");
									this.turtleParameters.push(degrees6);
								} else {
									this.rotation = -Math.PI / 2;
									this.rotation += degrees6 * Math.PI / 180;
								}
								++j1;
								break;
							case "SET_POSITION":
								var x4 = v1[j1];
								var y4 = v1[j1 + 1];
								if(this.turtleHistoryOn) {
									this.historyAdd("SET_POSITION");
									this.historyParameters.push(x4);
									this.historyParameters.push(y4);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("SET_POSITION");
									this.turtleParameters.push(x4);
									this.turtleParameters.push(y4);
								} else {
									var tmp19;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp19 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp19 = true;
										break;
									}
									if(tmp19) {
										this.contour.end(this.width);
									}
									this.x = x4;
									this.y = y4;
									var l29 = this.points.length;
									this.points[l29] = [];
									this.points[l29][0] = x4;
									this.points[l29][1] = y4;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d19 = this.dim[this.dim.length - 1];
									if(x4 < d19.minX) {
										d19.minX = x4;
									}
									if(x4 > d19.maxX) {
										d19.maxX = x4;
									}
									if(y4 < d19.minY) {
										d19.minY = y4;
									}
									if(y4 > d19.maxY) {
										d19.maxY = y4;
									}
									this.contour.reset();
								}
								j1 += 2;
								break;
							case "SOUTH":
								if(this.turtleHistoryOn) {
									this.historyAdd("SOUTH");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("SOUTH");
								} else {
									this.rotation = Math.PI / 2;
								}
								break;
							case "TAN":
								if(this.turtleHistoryOn) {
									this.historyAdd("TAN");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("TAN");
								} else {
									this.pen.currentColor = -27273;
								}
								break;
							case "TRIANGLE_ARCH":
								var distance9 = v1[j1];
								var distance22 = v1[j1 + 1];
								var radius8 = v1[j1 + 2];
								if(this.turtleHistoryOn) {
									this.historyAdd("TRIANGLE_ARCH");
									this.historyParameters.push(distance9);
									this.historyParameters.push(distance22);
									this.historyParameters.push(radius8);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("TRIANGLE_ARCH");
									this.turtleParameters.push(distance9);
									this.turtleParameters.push(distance22);
									this.turtleParameters.push(radius8);
								} else {
									var nx15 = this.x + distance9 * Math.cos(this.rotation);
									var ny15 = this.y + distance9 * Math.sin(this.rotation);
									if(this.penIsDown) {
										var thruX2 = this.x + distance22 * Math.cos(this.rotation) - radius8 * Math.cos(this.rotation + Math.PI / 2);
										var thruY2 = this.y + distance22 * Math.sin(this.rotation) - radius8 * Math.sin(this.rotation + Math.PI / 2);
										if(this.fill) {
											this.pen.triangle2DFill(this.x,this.y,thruX2,thruY2,nx15,ny15);
										}
										this.lineTo(thruX2,thruY2);
										this.lineTo(nx15,ny15);
										if(this.fill) {
											this.lineTo(this.x,this.y);
										}
										var tmp20;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp20 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp20 = true;
											break;
										}
										if(tmp20) {
											this.contour.end(this.width);
										}
										this.x = nx15;
										this.y = ny15;
										var l30 = this.points.length;
										this.points[l30] = [];
										this.points[l30][0] = nx15;
										this.points[l30][1] = ny15;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d20 = this.dim[this.dim.length - 1];
										if(nx15 < d20.minX) {
											d20.minX = nx15;
										}
										if(nx15 > d20.maxX) {
											d20.maxX = nx15;
										}
										if(ny15 < d20.minY) {
											d20.minY = ny15;
										}
										if(ny15 > d20.maxY) {
											d20.maxY = ny15;
										}
										this.contour.reset();
									} else {
										var tmp21;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp21 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp21 = true;
											break;
										}
										if(tmp21) {
											this.contour.end(this.width);
										}
										this.x = nx15;
										this.y = ny15;
										var l31 = this.points.length;
										this.points[l31] = [];
										this.points[l31][0] = nx15;
										this.points[l31][1] = ny15;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d21 = this.dim[this.dim.length - 1];
										if(nx15 < d21.minX) {
											d21.minX = nx15;
										}
										if(nx15 > d21.maxX) {
											d21.maxX = nx15;
										}
										if(ny15 < d21.minY) {
											d21.minY = ny15;
										}
										if(ny15 > d21.maxY) {
											d21.maxY = ny15;
										}
										this.contour.reset();
									}
								}
								j1 += 3;
								break;
							case "WEST":
								if(this.turtleHistoryOn) {
									this.historyAdd("WEST");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("WEST");
								} else {
									this.rotation = 0;
								}
								break;
							case "WHITE":
								if(this.turtleHistoryOn) {
									this.historyAdd("WHITE");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("WHITE");
								} else {
									this.pen.currentColor = -1;
								}
								break;
							case "YELLOW":
								if(this.turtleHistoryOn) {
									this.historyAdd("YELLOW");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("YELLOW");
								} else {
									this.pen.currentColor = -256;
								}
								break;
							}
						}
						j1 = 0;
					}
					this.turtleHistoryOn = wasHistoryOn2;
					this.turtleCommands.length = 0;
					this.turtleParameters.length = 0;
				}
				if(repeatCount_ > 0) {
					this.repeatCount = Math.round(repeatCount_);
					this.repeatCommands = true;
					this.turtleCommands.length = 0;
					this.turtleParameters.length = 0;
				}
				++j;
				break;
			case "BLACK":
				if(this.turtleHistoryOn) {
					this.historyAdd("BLACK");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("BLACK");
				} else {
					this.pen.currentColor = -16777216;
				}
				break;
			case "BLUE":
				if(this.turtleHistoryOn) {
					this.historyAdd("BLUE");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("BLUE");
				} else {
					this.pen.currentColor = -16776961;
				}
				break;
			case "BROWN":
				if(this.turtleHistoryOn) {
					this.historyAdd("BROWN");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("BROWN");
				} else {
					this.pen.currentColor = -6594501;
				}
				break;
			case "CIRCLE":
				var radius9 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("CIRCLE");
					this.historyParameters.push(radius9);
				}
				if(radius9 != 0) {
					if(this.repeatCommands) {
						this.turtleCommands.push("CIRCLE");
						this.turtleParameters.push(radius9);
					} else {
						var beta6 = 2 * Math.PI / 24;
						var alpha6 = (Math.PI - beta6) / 2;
						var rotate6 = -(Math.PI / 2 - alpha6);
						var baseLength6 = 0.5 * radius9 * Math.sin(beta6 / 2);
						var ox8 = this.x;
						var oy8 = this.y;
						var arr8 = [];
						var _g12 = 0;
						while(_g12 < 48) {
							var i16 = _g12++;
							this.rotation += rotate6;
							var wasHistoryOn7 = this.turtleHistoryOn;
							this.turtleHistoryOn = false;
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD");
								this.historyParameters.push(baseLength6);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD");
								this.turtleParameters.push(baseLength6);
							} else {
								var nx16 = this.x + baseLength6 * Math.cos(this.rotation);
								var ny16 = this.y + baseLength6 * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = baseLength6;
									this.lineTo(nx16,ny16);
								} else {
									var tmp22;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp22 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp22 = true;
										break;
									}
									if(tmp22) {
										this.contour.end(this.width);
									}
									this.x = nx16;
									this.y = ny16;
									var l32 = this.points.length;
									this.points[l32] = [];
									this.points[l32][0] = nx16;
									this.points[l32][1] = ny16;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d22 = this.dim[this.dim.length - 1];
									if(nx16 < d22.minX) {
										d22.minX = nx16;
									}
									if(nx16 > d22.maxX) {
										d22.maxX = nx16;
									}
									if(ny16 < d22.minY) {
										d22.minY = ny16;
									}
									if(ny16 > d22.maxY) {
										d22.maxY = ny16;
									}
									this.contour.reset();
								}
							}
							this.turtleHistoryOn = wasHistoryOn7;
							if(this.fill) {
								arr8.push(this.x);
								arr8.push(this.y);
							}
						}
						if(this.fill) {
							var cx8 = (ox8 + arr8[arr8.length - 2]) / 2;
							var cy8 = (oy8 + arr8[arr8.length - 1]) / 2;
							var l33 = arr8.length;
							var i17 = 2;
							var lx6 = 0.;
							var ly6 = 0.;
							while(i17 < l33) {
								if(i17 > 2) {
									this.pen.triangle2DFill(lx6,ly6,arr8[i17],arr8[i17 + 1],cx8,cy8);
								}
								lx6 = arr8[i17];
								ly6 = arr8[i17 + 1];
								i17 += 2;
							}
						}
						arr8.length = 0;
					}
				}
				++j;
				break;
			case "CIRCLE_SIDES":
				var radius10 = v[j];
				var sides3 = v[j + 1];
				if(sides3 == null) {
					sides3 = 24;
				}
				if(this.turtleHistoryOn) {
					if(sides3 == 24) {
						this.historyAdd("CIRCLE");
						this.historyParameters.push(radius10);
					} else {
						this.historyAdd("CIRCLE_SIDES");
						this.historyParameters.push(radius10);
						this.historyParameters.push(sides3);
					}
				}
				if(radius10 != 0) {
					if(this.repeatCommands) {
						if(sides3 == 24) {
							this.turtleCommands.push("CIRCLE");
							this.turtleParameters.push(radius10);
						} else {
							this.turtleCommands.push("CIRCLE_SIDES");
							this.turtleParameters.push(radius10);
							this.turtleParameters.push(sides3);
						}
					} else {
						var beta7 = 2 * Math.PI / sides3;
						var alpha7 = (Math.PI - beta7) / 2;
						var rotate7 = -(Math.PI / 2 - alpha7);
						var baseLength7 = 0.5 * radius10 * Math.sin(beta7 / 2);
						var ox9 = this.x;
						var oy9 = this.y;
						var arr9 = [];
						var _g13 = 0;
						while(_g13 < 48) {
							var i18 = _g13++;
							this.rotation += rotate7;
							var wasHistoryOn8 = this.turtleHistoryOn;
							this.turtleHistoryOn = false;
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD");
								this.historyParameters.push(baseLength7);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD");
								this.turtleParameters.push(baseLength7);
							} else {
								var nx17 = this.x + baseLength7 * Math.cos(this.rotation);
								var ny17 = this.y + baseLength7 * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = baseLength7;
									this.lineTo(nx17,ny17);
								} else {
									var tmp23;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp23 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp23 = true;
										break;
									}
									if(tmp23) {
										this.contour.end(this.width);
									}
									this.x = nx17;
									this.y = ny17;
									var l34 = this.points.length;
									this.points[l34] = [];
									this.points[l34][0] = nx17;
									this.points[l34][1] = ny17;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d23 = this.dim[this.dim.length - 1];
									if(nx17 < d23.minX) {
										d23.minX = nx17;
									}
									if(nx17 > d23.maxX) {
										d23.maxX = nx17;
									}
									if(ny17 < d23.minY) {
										d23.minY = ny17;
									}
									if(ny17 > d23.maxY) {
										d23.maxY = ny17;
									}
									this.contour.reset();
								}
							}
							this.turtleHistoryOn = wasHistoryOn8;
							if(this.fill) {
								arr9.push(this.x);
								arr9.push(this.y);
							}
						}
						if(this.fill) {
							var cx9 = (ox9 + arr9[arr9.length - 2]) / 2;
							var cy9 = (oy9 + arr9[arr9.length - 1]) / 2;
							var l35 = arr9.length;
							var i19 = 2;
							var lx7 = 0.;
							var ly7 = 0.;
							while(i19 < l35) {
								if(i19 > 2) {
									this.pen.triangle2DFill(lx7,ly7,arr9[i19],arr9[i19 + 1],cx9,cy9);
								}
								lx7 = arr9[i19];
								ly7 = arr9[i19 + 1];
								i19 += 2;
							}
						}
						arr9.length = 0;
					}
				}
				j += 2;
				break;
			case "CYAN":
				if(this.turtleHistoryOn) {
					this.historyAdd("CYAN");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("CYAN");
				} else {
					this.pen.currentColor = -16711681;
				}
				break;
			case "DARKISH_BLUE":
				if(this.turtleHistoryOn) {
					this.historyAdd("DARKISH_BLUE");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("DARKISH_BLUE");
				} else {
					this.pen.currentColor = -8864837;
				}
				break;
			case "DARK_GREEN":
				if(this.turtleHistoryOn) {
					this.historyAdd("DARK_GREEN");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("DARK_GREEN");
				} else {
					this.pen.currentColor = -10182080;
				}
				break;
			case "EAST":
				if(this.turtleHistoryOn) {
					this.historyAdd("WEST");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("EAST");
				} else {
					this.rotation = Math.PI;
				}
				break;
			case "END_REPEAT":
				this.repeatCommands = false;
				if(this.turtleHistoryOn) {
					this.historyAdd("END_REPEAT");
				}
				var wasHistoryOn9 = this.turtleHistoryOn;
				this.turtleHistoryOn = false;
				var v2 = this.turtleParameters;
				var j2 = 0;
				var _g14 = 0;
				var _g15 = this.repeatCount;
				while(_g14 < _g15) {
					var k1 = _g14++;
					var _g16 = 0;
					var _g17 = this.turtleCommands.length;
					while(_g16 < _g17) {
						var i20 = _g16++;
						var command2 = this.turtleCommands[i20];
						switch(command2) {
						case "ARC":
							var radius11 = v2[j2];
							var degrees7 = v2[j2 + 1];
							if(this.turtleHistoryOn) {
								this.historyAdd("ARC");
								this.historyParameters.push(radius11);
								this.historyParameters.push(degrees7);
							}
							if(radius11 != 0) {
								if(this.repeatCommands) {
									this.turtleCommands.push("ARC");
									this.turtleParameters.push(radius11);
									this.turtleParameters.push(degrees7);
								} else {
									var beta8 = degrees7 * Math.PI / 180 / 24;
									var alpha8 = (Math.PI - beta8) / 2;
									var rotate8 = -(Math.PI / 2 - alpha8);
									var baseLength8 = 0.5 * radius11 * Math.sin(beta8 / 2);
									var ox10 = this.x;
									var oy10 = this.y;
									var arr10 = [];
									arr10.push(this.x);
									arr10.push(this.y);
									var _g18 = 0;
									while(_g18 < 48) {
										var i21 = _g18++;
										this.rotation += rotate8;
										var wasHistoryOn10 = this.turtleHistoryOn;
										this.turtleHistoryOn = false;
										if(this.turtleHistoryOn) {
											this.historyAdd("FORWARD");
											this.historyParameters.push(baseLength8);
										}
										if(this.repeatCommands) {
											this.turtleCommands.push("FORWARD");
											this.turtleParameters.push(baseLength8);
										} else {
											var nx18 = this.x + baseLength8 * Math.cos(this.rotation);
											var ny18 = this.y + baseLength8 * Math.sin(this.rotation);
											if(this.penIsDown) {
												this.lastDistance = baseLength8;
												this.lineTo(nx18,ny18);
											} else {
												var tmp24;
												switch(this.endLine) {
												case 0:case 1:case 6:case 9:case 12:case 15:case 18:
													tmp24 = false;
													break;
												case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
													tmp24 = true;
													break;
												}
												if(tmp24) {
													this.contour.end(this.width);
												}
												this.x = nx18;
												this.y = ny18;
												var l36 = this.points.length;
												this.points[l36] = [];
												this.points[l36][0] = nx18;
												this.points[l36][1] = ny18;
												this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
												this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
												this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
												var d24 = this.dim[this.dim.length - 1];
												if(nx18 < d24.minX) {
													d24.minX = nx18;
												}
												if(nx18 > d24.maxX) {
													d24.maxX = nx18;
												}
												if(ny18 < d24.minY) {
													d24.minY = ny18;
												}
												if(ny18 > d24.maxY) {
													d24.maxY = ny18;
												}
												this.contour.reset();
											}
										}
										this.turtleHistoryOn = wasHistoryOn10;
										if(this.fill) {
											arr10.push(this.x);
											arr10.push(this.y);
										}
									}
									if(this.fill) {
										var cx10 = (ox10 + arr10[arr10.length - 2]) / 2;
										var cy10 = (oy10 + arr10[arr10.length - 1]) / 2;
										var l37 = arr10.length;
										var i22 = 2;
										var lx8 = 0.;
										var ly8 = 0.;
										this.pen.triangle2DFill(ox10,oy10,arr10[0],arr10[1],cx10,cy10);
										while(i22 < l37) {
											if(i22 > 2) {
												this.pen.triangle2DFill(lx8,ly8,arr10[i22],arr10[i22 + 1],cx10,cy10);
											}
											lx8 = arr10[i22];
											ly8 = arr10[i22 + 1];
											i22 += 2;
										}
									}
									arr10.length = 0;
								}
							}
							j2 += 2;
							break;
						case "ARCH_BEZIER":
							var distance10 = v2[j2];
							var distance23 = v2[j2 + 1];
							var radius12 = v2[j2 + 2];
							if(this.turtleHistoryOn) {
								this.historyAdd("ARCH_BEZIER");
								this.historyParameters.push(distance10);
								this.historyParameters.push(distance23);
								this.historyParameters.push(radius12);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("ARCH_BEZIER");
								this.turtleParameters.push(distance10);
								this.turtleParameters.push(distance23);
								this.turtleParameters.push(radius12);
							} else {
								var nx19 = this.x + distance10 * Math.cos(this.rotation);
								var ny19 = this.y + distance10 * Math.sin(this.rotation);
								if(this.penIsDown) {
									var thruX3 = this.x + distance23 * Math.cos(this.rotation) - radius12 * Math.cos(this.rotation + Math.PI / 2);
									var thruY3 = this.y + distance23 * Math.sin(this.rotation) - radius12 * Math.sin(this.rotation + Math.PI / 2);
									var newx2 = 2 * thruX3 - 0.5 * (this.x + nx19);
									var newy2 = 2 * thruY3 - 0.5 * (this.y + ny19);
									this.tempArr = [];
									var p2 = this.tempArr;
									var ax2 = this.x;
									var ay2 = this.y;
									var x5 = ax2 - newx2;
									var y5 = ay2 - newy2;
									var x6 = newx2 - nx19;
									var y6 = newy2 - ny19;
									var approxDistance2 = Math.sqrt(x5 * x5 + y5 * y5) + Math.sqrt(x6 * x6 + y6 * y6);
									if(approxDistance2 == 0) {
										approxDistance2 = 0.000001;
									}
									var step2 = Math.min(1 / (approxDistance2 * 0.707),cornerContour_CurveMath_quadStep);
									var l38 = p2.length;
									p2[l38++] = ax2;
									p2[l38++] = ay2;
									var t2 = step2;
									while(t2 < 1.) {
										var u4 = 1 - t2;
										p2[l38++] = Math.pow(u4,2) * ax2 + 2 * u4 * t2 * newx2 + Math.pow(t2,2) * nx19;
										var u5 = 1 - t2;
										p2[l38++] = Math.pow(u5,2) * ay2 + 2 * u5 * t2 * newy2 + Math.pow(t2,2) * ny19;
										t2 += step2;
									}
									p2[l38++] = nx19;
									p2[l38++] = ny19;
									var arr11 = this.tempArr;
									var withMove2 = false;
									if(withMove2 == null) {
										withMove2 = true;
									}
									var l39 = arr11.length;
									var i23 = 2;
									if(withMove2) {
										var x_2 = arr11[0];
										var y_2 = arr11[1];
										var tmp25;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp25 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp25 = true;
											break;
										}
										if(tmp25) {
											this.contour.end(this.width);
										}
										this.x = x_2;
										this.y = y_2;
										var l40 = this.points.length;
										this.points[l40] = [];
										this.points[l40][0] = x_2;
										this.points[l40][1] = y_2;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d25 = this.dim[this.dim.length - 1];
										if(x_2 < d25.minX) {
											d25.minX = x_2;
										}
										if(x_2 > d25.maxX) {
											d25.maxX = x_2;
										}
										if(y_2 < d25.minY) {
											d25.minY = y_2;
										}
										if(y_2 > d25.maxY) {
											d25.maxY = y_2;
										}
										this.contour.reset();
									} else {
										this.lineTo(arr11[0],arr11[1]);
									}
									var cx11 = (arr11[0] + arr11[l39 - 2]) / 2;
									var cy11 = (arr11[1] + arr11[l39 - 1]) / 2;
									var ox11 = this.x;
									var oy11 = this.y;
									while(i23 < l39) {
										if(this.fill && this.penIsDown) {
											if(i23 > 0 && i23 < l39 - 2) {
												this.pen.triangle2DFill(arr11[i23 - 2],arr11[i23 - 1],arr11[i23],arr11[i23 + 1],cx11,cy11);
											}
										}
										this.lineTo(arr11[i23],arr11[i23 + 1]);
										i23 += 2;
									}
									if(this.fill && this.penIsDown) {
										var tmp26;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp26 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp26 = true;
											break;
										}
										if(tmp26) {
											this.contour.end(this.width);
										}
										this.x = ox11;
										this.y = oy11;
										var l41 = this.points.length;
										this.points[l41] = [];
										this.points[l41][0] = ox11;
										this.points[l41][1] = oy11;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d26 = this.dim[this.dim.length - 1];
										if(ox11 < d26.minX) {
											d26.minX = ox11;
										}
										if(ox11 > d26.maxX) {
											d26.maxX = ox11;
										}
										if(oy11 < d26.minY) {
											d26.minY = oy11;
										}
										if(oy11 > d26.maxY) {
											d26.maxY = oy11;
										}
										this.contour.reset();
										this.lineTo(arr11[l39 - 2],arr11[l39 - 1]);
									}
									this.x = nx19;
									this.y = ny19;
								} else {
									var tmp27;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp27 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp27 = true;
										break;
									}
									if(tmp27) {
										this.contour.end(this.width);
									}
									this.x = nx19;
									this.y = ny19;
									var l42 = this.points.length;
									this.points[l42] = [];
									this.points[l42][0] = nx19;
									this.points[l42][1] = ny19;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d27 = this.dim[this.dim.length - 1];
									if(nx19 < d27.minX) {
										d27.minX = nx19;
									}
									if(nx19 > d27.maxX) {
										d27.maxX = nx19;
									}
									if(ny19 < d27.minY) {
										d27.minY = ny19;
									}
									if(ny19 > d27.maxY) {
										d27.maxY = ny19;
									}
									this.contour.reset();
								}
							}
							j2 += 3;
							break;
						case "ARC_SIDES":
							var radius13 = v2[j2];
							var degrees8 = v2[j2 + 1];
							var sides4 = v2[j2 + 2];
							if(sides4 == null) {
								sides4 = 24;
							}
							if(this.turtleHistoryOn) {
								if(sides4 == 24) {
									this.historyAdd("ARC");
									this.historyParameters.push(radius13);
									this.historyParameters.push(degrees8);
								} else {
									this.historyAdd("ARC_SIDES");
									this.historyParameters.push(radius13);
									this.historyParameters.push(degrees8);
									this.historyParameters.push(sides4);
								}
							}
							if(radius13 != 0) {
								if(this.repeatCommands) {
									if(sides4 == 24) {
										this.turtleCommands.push("ARC");
										this.turtleParameters.push(radius13);
										this.turtleParameters.push(degrees8);
									} else {
										this.turtleCommands.push("ARC_SIDES");
										this.turtleParameters.push(radius13);
										this.turtleParameters.push(degrees8);
										this.turtleParameters.push(sides4);
									}
								} else {
									var beta9 = degrees8 * Math.PI / 180 / sides4;
									var alpha9 = (Math.PI - beta9) / 2;
									var rotate9 = -(Math.PI / 2 - alpha9);
									var baseLength9 = 0.5 * radius13 * Math.sin(beta9 / 2);
									var ox12 = this.x;
									var oy12 = this.y;
									var arr12 = [];
									arr12.push(this.x);
									arr12.push(this.y);
									var _g19 = 0;
									while(_g19 < 48) {
										var i24 = _g19++;
										this.rotation += rotate9;
										var wasHistoryOn11 = this.turtleHistoryOn;
										this.turtleHistoryOn = false;
										if(this.turtleHistoryOn) {
											this.historyAdd("FORWARD");
											this.historyParameters.push(baseLength9);
										}
										if(this.repeatCommands) {
											this.turtleCommands.push("FORWARD");
											this.turtleParameters.push(baseLength9);
										} else {
											var nx20 = this.x + baseLength9 * Math.cos(this.rotation);
											var ny20 = this.y + baseLength9 * Math.sin(this.rotation);
											if(this.penIsDown) {
												this.lastDistance = baseLength9;
												this.lineTo(nx20,ny20);
											} else {
												var tmp28;
												switch(this.endLine) {
												case 0:case 1:case 6:case 9:case 12:case 15:case 18:
													tmp28 = false;
													break;
												case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
													tmp28 = true;
													break;
												}
												if(tmp28) {
													this.contour.end(this.width);
												}
												this.x = nx20;
												this.y = ny20;
												var l43 = this.points.length;
												this.points[l43] = [];
												this.points[l43][0] = nx20;
												this.points[l43][1] = ny20;
												this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
												this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
												this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
												var d28 = this.dim[this.dim.length - 1];
												if(nx20 < d28.minX) {
													d28.minX = nx20;
												}
												if(nx20 > d28.maxX) {
													d28.maxX = nx20;
												}
												if(ny20 < d28.minY) {
													d28.minY = ny20;
												}
												if(ny20 > d28.maxY) {
													d28.maxY = ny20;
												}
												this.contour.reset();
											}
										}
										this.turtleHistoryOn = wasHistoryOn11;
										if(this.fill) {
											arr12.push(this.x);
											arr12.push(this.y);
										}
									}
									if(this.fill) {
										var cx12 = (ox12 + arr12[arr12.length - 2]) / 2;
										var cy12 = (oy12 + arr12[arr12.length - 1]) / 2;
										var l44 = arr12.length;
										var i25 = 2;
										var lx9 = 0.;
										var ly9 = 0.;
										this.pen.triangle2DFill(ox12,oy12,arr12[0],arr12[1],cx12,cy12);
										while(i25 < l44) {
											if(i25 > 2) {
												this.pen.triangle2DFill(lx9,ly9,arr12[i25],arr12[i25 + 1],cx12,cy12);
											}
											lx9 = arr12[i25];
											ly9 = arr12[i25 + 1];
											i25 += 2;
										}
									}
									arr12.length = 0;
								}
							}
							j2 += 3;
							break;
						case "BACKWARD":
							var distance11 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("BACKWARD");
								this.historyParameters.push(distance11);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("BACKWARD");
								this.turtleParameters.push(distance11);
							} else {
								var nx21 = this.x + distance11 * Math.cos(this.rotation + Math.PI);
								var ny21 = this.y + distance11 * Math.sin(this.rotation + Math.PI);
								if(this.penIsDown) {
									this.lineTo(nx21,ny21);
								} else {
									var tmp29;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp29 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp29 = true;
										break;
									}
									if(tmp29) {
										this.contour.end(this.width);
									}
									this.x = nx21;
									this.y = ny21;
									var l45 = this.points.length;
									this.points[l45] = [];
									this.points[l45][0] = nx21;
									this.points[l45][1] = ny21;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d29 = this.dim[this.dim.length - 1];
									if(nx21 < d29.minX) {
										d29.minX = nx21;
									}
									if(nx21 > d29.maxX) {
										d29.maxX = nx21;
									}
									if(ny21 < d29.minY) {
										d29.minY = ny21;
									}
									if(ny21 > d29.maxY) {
										d29.maxY = ny21;
									}
									this.contour.reset();
								}
							}
							++j2;
							break;
						case "BEGIN_REPEAT":
							break;
						case "BLACK":
							if(this.turtleHistoryOn) {
								this.historyAdd("BLACK");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("BLACK");
							} else {
								this.pen.currentColor = -16777216;
							}
							break;
						case "BLUE":
							if(this.turtleHistoryOn) {
								this.historyAdd("BLUE");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("BLUE");
							} else {
								this.pen.currentColor = -16776961;
							}
							break;
						case "BROWN":
							if(this.turtleHistoryOn) {
								this.historyAdd("BROWN");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("BROWN");
							} else {
								this.pen.currentColor = -6594501;
							}
							break;
						case "CIRCLE":
							var radius14 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("CIRCLE");
								this.historyParameters.push(radius14);
							}
							if(radius14 != 0) {
								if(this.repeatCommands) {
									this.turtleCommands.push("CIRCLE");
									this.turtleParameters.push(radius14);
								} else {
									var beta10 = 2 * Math.PI / 24;
									var alpha10 = (Math.PI - beta10) / 2;
									var rotate10 = -(Math.PI / 2 - alpha10);
									var baseLength10 = 0.5 * radius14 * Math.sin(beta10 / 2);
									var ox13 = this.x;
									var oy13 = this.y;
									var arr13 = [];
									var _g20 = 0;
									while(_g20 < 48) {
										var i26 = _g20++;
										this.rotation += rotate10;
										var wasHistoryOn12 = this.turtleHistoryOn;
										this.turtleHistoryOn = false;
										if(this.turtleHistoryOn) {
											this.historyAdd("FORWARD");
											this.historyParameters.push(baseLength10);
										}
										if(this.repeatCommands) {
											this.turtleCommands.push("FORWARD");
											this.turtleParameters.push(baseLength10);
										} else {
											var nx22 = this.x + baseLength10 * Math.cos(this.rotation);
											var ny22 = this.y + baseLength10 * Math.sin(this.rotation);
											if(this.penIsDown) {
												this.lastDistance = baseLength10;
												this.lineTo(nx22,ny22);
											} else {
												var tmp30;
												switch(this.endLine) {
												case 0:case 1:case 6:case 9:case 12:case 15:case 18:
													tmp30 = false;
													break;
												case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
													tmp30 = true;
													break;
												}
												if(tmp30) {
													this.contour.end(this.width);
												}
												this.x = nx22;
												this.y = ny22;
												var l46 = this.points.length;
												this.points[l46] = [];
												this.points[l46][0] = nx22;
												this.points[l46][1] = ny22;
												this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
												this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
												this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
												var d30 = this.dim[this.dim.length - 1];
												if(nx22 < d30.minX) {
													d30.minX = nx22;
												}
												if(nx22 > d30.maxX) {
													d30.maxX = nx22;
												}
												if(ny22 < d30.minY) {
													d30.minY = ny22;
												}
												if(ny22 > d30.maxY) {
													d30.maxY = ny22;
												}
												this.contour.reset();
											}
										}
										this.turtleHistoryOn = wasHistoryOn12;
										if(this.fill) {
											arr13.push(this.x);
											arr13.push(this.y);
										}
									}
									if(this.fill) {
										var cx13 = (ox13 + arr13[arr13.length - 2]) / 2;
										var cy13 = (oy13 + arr13[arr13.length - 1]) / 2;
										var l47 = arr13.length;
										var i27 = 2;
										var lx10 = 0.;
										var ly10 = 0.;
										while(i27 < l47) {
											if(i27 > 2) {
												this.pen.triangle2DFill(lx10,ly10,arr13[i27],arr13[i27 + 1],cx13,cy13);
											}
											lx10 = arr13[i27];
											ly10 = arr13[i27 + 1];
											i27 += 2;
										}
									}
									arr13.length = 0;
								}
							}
							++j2;
							break;
						case "CIRCLE_SIDES":
							var radius15 = v2[j2];
							var sides5 = v2[j2 + 1];
							if(sides5 == null) {
								sides5 = 24;
							}
							if(this.turtleHistoryOn) {
								if(sides5 == 24) {
									this.historyAdd("CIRCLE");
									this.historyParameters.push(radius15);
								} else {
									this.historyAdd("CIRCLE_SIDES");
									this.historyParameters.push(radius15);
									this.historyParameters.push(sides5);
								}
							}
							if(radius15 != 0) {
								if(this.repeatCommands) {
									if(sides5 == 24) {
										this.turtleCommands.push("CIRCLE");
										this.turtleParameters.push(radius15);
									} else {
										this.turtleCommands.push("CIRCLE_SIDES");
										this.turtleParameters.push(radius15);
										this.turtleParameters.push(sides5);
									}
								} else {
									var beta11 = 2 * Math.PI / sides5;
									var alpha11 = (Math.PI - beta11) / 2;
									var rotate11 = -(Math.PI / 2 - alpha11);
									var baseLength11 = 0.5 * radius15 * Math.sin(beta11 / 2);
									var ox14 = this.x;
									var oy14 = this.y;
									var arr14 = [];
									var _g21 = 0;
									while(_g21 < 48) {
										var i28 = _g21++;
										this.rotation += rotate11;
										var wasHistoryOn13 = this.turtleHistoryOn;
										this.turtleHistoryOn = false;
										if(this.turtleHistoryOn) {
											this.historyAdd("FORWARD");
											this.historyParameters.push(baseLength11);
										}
										if(this.repeatCommands) {
											this.turtleCommands.push("FORWARD");
											this.turtleParameters.push(baseLength11);
										} else {
											var nx23 = this.x + baseLength11 * Math.cos(this.rotation);
											var ny23 = this.y + baseLength11 * Math.sin(this.rotation);
											if(this.penIsDown) {
												this.lastDistance = baseLength11;
												this.lineTo(nx23,ny23);
											} else {
												var tmp31;
												switch(this.endLine) {
												case 0:case 1:case 6:case 9:case 12:case 15:case 18:
													tmp31 = false;
													break;
												case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
													tmp31 = true;
													break;
												}
												if(tmp31) {
													this.contour.end(this.width);
												}
												this.x = nx23;
												this.y = ny23;
												var l48 = this.points.length;
												this.points[l48] = [];
												this.points[l48][0] = nx23;
												this.points[l48][1] = ny23;
												this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
												this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
												this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
												var d31 = this.dim[this.dim.length - 1];
												if(nx23 < d31.minX) {
													d31.minX = nx23;
												}
												if(nx23 > d31.maxX) {
													d31.maxX = nx23;
												}
												if(ny23 < d31.minY) {
													d31.minY = ny23;
												}
												if(ny23 > d31.maxY) {
													d31.maxY = ny23;
												}
												this.contour.reset();
											}
										}
										this.turtleHistoryOn = wasHistoryOn13;
										if(this.fill) {
											arr14.push(this.x);
											arr14.push(this.y);
										}
									}
									if(this.fill) {
										var cx14 = (ox14 + arr14[arr14.length - 2]) / 2;
										var cy14 = (oy14 + arr14[arr14.length - 1]) / 2;
										var l49 = arr14.length;
										var i29 = 2;
										var lx11 = 0.;
										var ly11 = 0.;
										while(i29 < l49) {
											if(i29 > 2) {
												this.pen.triangle2DFill(lx11,ly11,arr14[i29],arr14[i29 + 1],cx14,cy14);
											}
											lx11 = arr14[i29];
											ly11 = arr14[i29 + 1];
											i29 += 2;
										}
									}
									arr14.length = 0;
								}
							}
							j2 += 2;
							break;
						case "CYAN":
							if(this.turtleHistoryOn) {
								this.historyAdd("CYAN");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("CYAN");
							} else {
								this.pen.currentColor = -16711681;
							}
							break;
						case "DARKISH_BLUE":
							if(this.turtleHistoryOn) {
								this.historyAdd("DARKISH_BLUE");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("DARKISH_BLUE");
							} else {
								this.pen.currentColor = -8864837;
							}
							break;
						case "DARK_GREEN":
							if(this.turtleHistoryOn) {
								this.historyAdd("DARK_GREEN");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("DARK_GREEN");
							} else {
								this.pen.currentColor = -10182080;
							}
							break;
						case "EAST":
							if(this.turtleHistoryOn) {
								this.historyAdd("WEST");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("EAST");
							} else {
								this.rotation = Math.PI;
							}
							break;
						case "END_REPEAT":
							break;
						case "FILL_OFF":
							if(this.turtleHistoryOn) {
								this.historyAdd("FILL_OFF");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FILL_OFF");
							} else {
								this.fill = false;
							}
							break;
						case "FILL_ON":
							if(this.turtleHistoryOn) {
								this.historyAdd("FILL_ON");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FILL_ON");
							} else {
								this.fill = true;
							}
							break;
						case "FORWARD":
							var distance12 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD");
								this.historyParameters.push(distance12);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD");
								this.turtleParameters.push(distance12);
							} else {
								var nx24 = this.x + distance12 * Math.cos(this.rotation);
								var ny24 = this.y + distance12 * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = distance12;
									this.lineTo(nx24,ny24);
								} else {
									var tmp32;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp32 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp32 = true;
										break;
									}
									if(tmp32) {
										this.contour.end(this.width);
									}
									this.x = nx24;
									this.y = ny24;
									var l50 = this.points.length;
									this.points[l50] = [];
									this.points[l50][0] = nx24;
									this.points[l50][1] = ny24;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d32 = this.dim[this.dim.length - 1];
									if(nx24 < d32.minX) {
										d32.minX = nx24;
									}
									if(nx24 > d32.maxX) {
										d32.maxX = nx24;
									}
									if(ny24 < d32.minY) {
										d32.minY = ny24;
									}
									if(ny24 > d32.maxY) {
										d32.maxY = ny24;
									}
									this.contour.reset();
								}
							}
							++j2;
							break;
						case "FORWARD_CHANGE":
							var deltaDistance1 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD_CHANGE");
								this.historyParameters.push(deltaDistance1);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD_CHANGE");
								this.turtleParameters.push(deltaDistance1);
							} else {
								var distance13 = this.lastDistance + deltaDistance1;
								var nx25 = this.x + distance13 * Math.cos(this.rotation);
								var ny25 = this.y + distance13 * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = distance13 + deltaDistance1;
									this.lineTo(nx25,ny25);
								} else {
									var tmp33;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp33 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp33 = true;
										break;
									}
									if(tmp33) {
										this.contour.end(this.width);
									}
									this.x = nx25;
									this.y = ny25;
									var l51 = this.points.length;
									this.points[l51] = [];
									this.points[l51][0] = nx25;
									this.points[l51][1] = ny25;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d33 = this.dim[this.dim.length - 1];
									if(nx25 < d33.minX) {
										d33.minX = nx25;
									}
									if(nx25 > d33.maxX) {
										d33.maxX = nx25;
									}
									if(ny25 < d33.minY) {
										d33.minY = ny25;
									}
									if(ny25 > d33.maxY) {
										d33.maxY = ny25;
									}
									this.contour.reset();
								}
							}
							++j2;
							break;
						case "FORWARD_FACTOR":
							var factor2 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD_FACTOR");
								this.historyParameters.push(factor2);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD_FACTOR");
								this.turtleParameters.push(factor2);
							} else {
								var distance14 = this.lastDistance * factor2;
								var nx26 = this.x + distance14 * Math.cos(this.rotation);
								var ny26 = this.y + distance14 * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = distance14;
									this.lineTo(nx26,ny26);
								} else {
									var tmp34;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp34 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp34 = true;
										break;
									}
									if(tmp34) {
										this.contour.end(this.width);
									}
									this.x = nx26;
									this.y = ny26;
									var l52 = this.points.length;
									this.points[l52] = [];
									this.points[l52][0] = nx26;
									this.points[l52][1] = ny26;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d34 = this.dim[this.dim.length - 1];
									if(nx26 < d34.minX) {
										d34.minX = nx26;
									}
									if(nx26 > d34.maxX) {
										d34.maxX = nx26;
									}
									if(ny26 < d34.minY) {
										d34.minY = ny26;
									}
									if(ny26 > d34.maxY) {
										d34.maxY = ny26;
									}
									this.contour.reset();
								}
							}
							++j2;
							break;
						case "GREEN":
							if(this.turtleHistoryOn) {
								this.historyAdd("GREEN");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("GREEN");
							} else {
								this.pen.currentColor = -16711936;
							}
							break;
						case "GREY":
							if(this.turtleHistoryOn) {
								this.historyAdd("GREY");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("GREY");
							} else {
								this.pen.currentColor = -4737097;
							}
							break;
						case "LEFT":
							var degrees9 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("LEFT");
								this.historyParameters.push(degrees9);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("LEFT");
								this.turtleParameters.push(degrees9);
							} else {
								this.rotation -= degrees9 * Math.PI / 180;
							}
							++j2;
							break;
						case "LIGHT_BROWN":
							if(this.turtleHistoryOn) {
								this.historyAdd("LIGHT_BROWN");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("LIGHT_BROWN");
							} else {
								this.pen.currentColor = -3831790;
							}
							break;
						case "LINE_STYLE":
							var thickness1 = v2[j2];
							var color1 = v2[j2 + 1];
							if(this.turtleHistoryOn) {
								this.historyAdd("LINE_STYLE");
								this.historyParameters.push(thickness1);
								this.historyParameters.push(color1);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("LINE_STYLE");
								this.historyParameters.push(thickness1);
								this.historyParameters.push(color1);
							} else {
								this.width = thickness1;
								this.pen.currentColor = color1 | 0;
							}
							j2 += 2;
							break;
						case "MAGENTA":
							if(this.turtleHistoryOn) {
								this.historyAdd("MAGENTA");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("MAGENTA");
							} else {
								this.pen.currentColor = -65281;
							}
							break;
						case "MOVE_PEN":
							var distance15 = v2[j2];
							if(this.repeatCommands) {
								this.turtleCommands.push("MOVE_PEN");
								this.turtleParameters.push(distance15);
							} else if(this.penIsDown) {
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_UP");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_UP");
								} else {
									this.penIsDown = false;
								}
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD");
									this.historyParameters.push(distance15);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD");
									this.turtleParameters.push(distance15);
								} else {
									var nx27 = this.x + distance15 * Math.cos(this.rotation);
									var ny27 = this.y + distance15 * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = distance15;
										this.lineTo(nx27,ny27);
									} else {
										var tmp35;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp35 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp35 = true;
											break;
										}
										if(tmp35) {
											this.contour.end(this.width);
										}
										this.x = nx27;
										this.y = ny27;
										var l53 = this.points.length;
										this.points[l53] = [];
										this.points[l53][0] = nx27;
										this.points[l53][1] = ny27;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d35 = this.dim[this.dim.length - 1];
										if(nx27 < d35.minX) {
											d35.minX = nx27;
										}
										if(nx27 > d35.maxX) {
											d35.maxX = nx27;
										}
										if(ny27 < d35.minY) {
											d35.minY = ny27;
										}
										if(ny27 > d35.maxY) {
											d35.maxY = ny27;
										}
										this.contour.reset();
									}
								}
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_DOWN");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_DOWN");
								} else {
									this.penIsDown = true;
								}
							} else {
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD");
									this.historyParameters.push(distance15);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD");
									this.turtleParameters.push(distance15);
								} else {
									var nx28 = this.x + distance15 * Math.cos(this.rotation);
									var ny28 = this.y + distance15 * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = distance15;
										this.lineTo(nx28,ny28);
									} else {
										var tmp36;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp36 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp36 = true;
											break;
										}
										if(tmp36) {
											this.contour.end(this.width);
										}
										this.x = nx28;
										this.y = ny28;
										var l54 = this.points.length;
										this.points[l54] = [];
										this.points[l54][0] = nx28;
										this.points[l54][1] = ny28;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d36 = this.dim[this.dim.length - 1];
										if(nx28 < d36.minX) {
											d36.minX = nx28;
										}
										if(nx28 > d36.maxX) {
											d36.maxX = nx28;
										}
										if(ny28 < d36.minY) {
											d36.minY = ny28;
										}
										if(ny28 > d36.maxY) {
											d36.maxY = ny28;
										}
										this.contour.reset();
									}
								}
							}
							++j2;
							break;
						case "NORTH":
							if(this.turtleHistoryOn) {
								this.historyAdd("NORTH");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("NORTH");
							} else {
								this.rotation = -Math.PI / 2;
							}
							break;
						case "ORANGE":
							if(this.turtleHistoryOn) {
								this.historyAdd("ORANGE");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("ORANGE");
							} else {
								this.pen.currentColor = -23808;
							}
							break;
						case "PEN_COLOR":
							var r6 = v2[j2];
							var g6 = v2[j2 + 1];
							var b6 = v2[j2 + 2];
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_COLOR");
								this.historyParameters.push(r6);
								this.historyParameters.push(g6);
								this.historyParameters.push(b6);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_COLOR");
								this.turtleParameters.push(r6);
								this.turtleParameters.push(g6);
								this.turtleParameters.push(b6);
							} else {
								this.pen.currentColor = Math.round(255) << 24 | Math.round(r6 * 255) << 16 | Math.round(g6 * 255) << 8 | Math.round(b6 * 255);
							}
							j2 += 3;
							break;
						case "PEN_COLOR_B":
							var r7 = v2[j2];
							var g7 = v2[j2 + 1];
							var b7 = v2[j2 + 2];
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_COLOR_B");
								this.historyParameters.push(r7);
								this.historyParameters.push(g7);
								this.historyParameters.push(b7);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_COLOR_B");
								this.turtleParameters.push(r7);
								this.turtleParameters.push(g7);
								this.turtleParameters.push(b7);
							} else {
								this.pen.colorB = Math.round(255) << 24 | Math.round(r7 * 255) << 16 | Math.round(g7 * 255) << 8 | Math.round(b7 * 255);
							}
							j2 += 3;
							break;
						case "PEN_COLOR_C":
							var r8 = v2[j2];
							var g8 = v2[j2 + 1];
							var b8 = v2[j2 + 2];
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_COLOR_C");
								this.historyParameters.push(r8);
								this.historyParameters.push(g8);
								this.historyParameters.push(b8);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_COLOR_C");
								this.turtleParameters.push(r8);
								this.turtleParameters.push(g8);
								this.turtleParameters.push(b8);
							} else {
								this.pen.colorC = Math.round(255) << 24 | Math.round(r8 * 255) << 16 | Math.round(g8 * 255) << 8 | Math.round(b8 * 255);
							}
							j2 += 3;
							break;
						case "PEN_COLOR_CHANGE":
							var r9 = v2[j2];
							var g9 = v2[j2 + 1];
							var b9 = v2[j2 + 2];
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_COLOR_CHANGE");
								this.historyParameters.push(r9);
								this.historyParameters.push(g9);
								this.historyParameters.push(b9);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_COLOR_CHANGE");
								this.turtleParameters.push(r9);
								this.turtleParameters.push(g9);
								this.turtleParameters.push(b9);
							} else {
								var c3 = this.pen.currentColor;
								var r03 = (c3 >> 16 & 255) / 255;
								var g03 = (c3 >> 8 & 255) / 255;
								var b03 = (c3 & 255) / 255;
								this.pen.currentColor = Math.round(255) << 24 | Math.round((r03 + r9) * 255) << 16 | Math.round((g03 + g9) * 255) << 8 | Math.round((b03 + b9) * 255);
							}
							j2 += 3;
							break;
						case "PEN_COLOR_CHANGE_B":
							var r10 = v2[j2];
							var g10 = v2[j2 + 1];
							var b10 = v2[j2 + 2];
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_COLOR_CHANGE_B");
								this.historyParameters.push(r10);
								this.historyParameters.push(g10);
								this.historyParameters.push(b10);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_COLOR_CHANGE_B");
								this.turtleParameters.push(r10);
								this.turtleParameters.push(g10);
								this.turtleParameters.push(b10);
							} else {
								var c4 = this.pen.colorB;
								var r04 = (c4 >> 16 & 255) / 255;
								var g04 = (c4 >> 8 & 255) / 255;
								var b04 = (c4 & 255) / 255;
								this.pen.colorB = Math.round(255) << 24 | Math.round((r04 + r10) * 255) << 16 | Math.round((g04 + g10) * 255) << 8 | Math.round((b04 + b10) * 255);
							}
							j2 += 3;
							break;
						case "PEN_COLOR_CHANGE_C":
							var r11 = v2[j2];
							var g11 = v2[j2 + 1];
							var b11 = v2[j2 + 2];
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_COLOR_CHANGE_C");
								this.historyParameters.push(r11);
								this.historyParameters.push(g11);
								this.historyParameters.push(b11);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_COLOR_CHANGE_C");
								this.turtleParameters.push(r11);
								this.turtleParameters.push(g11);
								this.turtleParameters.push(b11);
							} else {
								var c5 = this.pen.colorC;
								var r05 = (c5 >> 16 & 255) / 255;
								var g05 = (c5 >> 8 & 255) / 255;
								var b05 = (c5 & 255) / 255;
								this.pen.colorC = Math.round(255) << 24 | Math.round((r05 + r11) * 255) << 16 | Math.round((g05 + g11) * 255) << 8 | Math.round((b05 + b11) * 255);
							}
							j2 += 3;
							break;
						case "PEN_DOWN":
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_DOWN");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_DOWN");
							} else {
								this.penIsDown = true;
							}
							break;
						case "PEN_SIZE":
							var w1 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_SIZE");
								this.historyParameters.push(w1);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_SIZE");
								this.turtleParameters.push(w1);
							} else {
								this.width = w1;
							}
							++j2;
							break;
						case "PEN_SIZE_CHANGE":
							var dw1 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_SIZE_CHANGE");
								this.historyParameters.push(dw1);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_SIZE_CHANGE");
								this.turtleParameters.push(dw1);
							} else {
								this.width += dw1;
							}
							++j2;
							break;
						case "PEN_SIZE_FACTOR":
							var factor3 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_SIZE_FACTOR");
								this.historyParameters.push(factor3);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_SIZE_FACTOR");
								this.turtleParameters.push(factor3);
							} else {
								this.width *= factor3;
							}
							++j2;
							break;
						case "PEN_UP":
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_UP");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_UP");
							} else {
								this.penIsDown = false;
							}
							break;
						case "PLUM":
							if(this.turtleHistoryOn) {
								this.historyAdd("PLUM");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PLUM");
							} else {
								this.pen.currentColor = -7310896;
							}
							break;
						case "RED":
							if(this.turtleHistoryOn) {
								this.historyAdd("RED");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("RED");
							} else {
								this.pen.currentColor = -65536;
							}
							break;
						case "RIGHT":
							var degrees10 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("RIGHT");
								this.historyParameters.push(degrees10);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("RIGHT");
								this.turtleParameters.push(degrees10);
							} else {
								this.rotation += degrees10 * Math.PI / 180;
							}
							++j2;
							break;
						case "SET_ANGLE":
							var degrees11 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("SET_ANGLE");
								this.historyParameters.push(degrees11);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("SET_ANGLE");
								this.turtleParameters.push(degrees11);
							} else {
								this.rotation = -Math.PI / 2;
								this.rotation += degrees11 * Math.PI / 180;
							}
							++j2;
							break;
						case "SET_POSITION":
							var x7 = v2[j2];
							var y7 = v2[j2 + 1];
							if(this.turtleHistoryOn) {
								this.historyAdd("SET_POSITION");
								this.historyParameters.push(x7);
								this.historyParameters.push(y7);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("SET_POSITION");
								this.turtleParameters.push(x7);
								this.turtleParameters.push(y7);
							} else {
								var tmp37;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp37 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp37 = true;
									break;
								}
								if(tmp37) {
									this.contour.end(this.width);
								}
								this.x = x7;
								this.y = y7;
								var l55 = this.points.length;
								this.points[l55] = [];
								this.points[l55][0] = x7;
								this.points[l55][1] = y7;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d37 = this.dim[this.dim.length - 1];
								if(x7 < d37.minX) {
									d37.minX = x7;
								}
								if(x7 > d37.maxX) {
									d37.maxX = x7;
								}
								if(y7 < d37.minY) {
									d37.minY = y7;
								}
								if(y7 > d37.maxY) {
									d37.maxY = y7;
								}
								this.contour.reset();
							}
							j2 += 2;
							break;
						case "SOUTH":
							if(this.turtleHistoryOn) {
								this.historyAdd("SOUTH");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("SOUTH");
							} else {
								this.rotation = Math.PI / 2;
							}
							break;
						case "TAN":
							if(this.turtleHistoryOn) {
								this.historyAdd("TAN");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("TAN");
							} else {
								this.pen.currentColor = -27273;
							}
							break;
						case "TRIANGLE_ARCH":
							var distance16 = v2[j2];
							var distance24 = v2[j2 + 1];
							var radius16 = v2[j2 + 2];
							if(this.turtleHistoryOn) {
								this.historyAdd("TRIANGLE_ARCH");
								this.historyParameters.push(distance16);
								this.historyParameters.push(distance24);
								this.historyParameters.push(radius16);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("TRIANGLE_ARCH");
								this.turtleParameters.push(distance16);
								this.turtleParameters.push(distance24);
								this.turtleParameters.push(radius16);
							} else {
								var nx29 = this.x + distance16 * Math.cos(this.rotation);
								var ny29 = this.y + distance16 * Math.sin(this.rotation);
								if(this.penIsDown) {
									var thruX4 = this.x + distance24 * Math.cos(this.rotation) - radius16 * Math.cos(this.rotation + Math.PI / 2);
									var thruY4 = this.y + distance24 * Math.sin(this.rotation) - radius16 * Math.sin(this.rotation + Math.PI / 2);
									if(this.fill) {
										this.pen.triangle2DFill(this.x,this.y,thruX4,thruY4,nx29,ny29);
									}
									this.lineTo(thruX4,thruY4);
									this.lineTo(nx29,ny29);
									if(this.fill) {
										this.lineTo(this.x,this.y);
									}
									var tmp38;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp38 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp38 = true;
										break;
									}
									if(tmp38) {
										this.contour.end(this.width);
									}
									this.x = nx29;
									this.y = ny29;
									var l56 = this.points.length;
									this.points[l56] = [];
									this.points[l56][0] = nx29;
									this.points[l56][1] = ny29;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d38 = this.dim[this.dim.length - 1];
									if(nx29 < d38.minX) {
										d38.minX = nx29;
									}
									if(nx29 > d38.maxX) {
										d38.maxX = nx29;
									}
									if(ny29 < d38.minY) {
										d38.minY = ny29;
									}
									if(ny29 > d38.maxY) {
										d38.maxY = ny29;
									}
									this.contour.reset();
								} else {
									var tmp39;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp39 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp39 = true;
										break;
									}
									if(tmp39) {
										this.contour.end(this.width);
									}
									this.x = nx29;
									this.y = ny29;
									var l57 = this.points.length;
									this.points[l57] = [];
									this.points[l57][0] = nx29;
									this.points[l57][1] = ny29;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d39 = this.dim[this.dim.length - 1];
									if(nx29 < d39.minX) {
										d39.minX = nx29;
									}
									if(nx29 > d39.maxX) {
										d39.maxX = nx29;
									}
									if(ny29 < d39.minY) {
										d39.minY = ny29;
									}
									if(ny29 > d39.maxY) {
										d39.maxY = ny29;
									}
									this.contour.reset();
								}
							}
							j2 += 3;
							break;
						case "WEST":
							if(this.turtleHistoryOn) {
								this.historyAdd("WEST");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("WEST");
							} else {
								this.rotation = 0;
							}
							break;
						case "WHITE":
							if(this.turtleHistoryOn) {
								this.historyAdd("WHITE");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("WHITE");
							} else {
								this.pen.currentColor = -1;
							}
							break;
						case "YELLOW":
							if(this.turtleHistoryOn) {
								this.historyAdd("YELLOW");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("YELLOW");
							} else {
								this.pen.currentColor = -256;
							}
							break;
						}
					}
					j2 = 0;
				}
				this.turtleHistoryOn = wasHistoryOn9;
				this.turtleCommands.length = 0;
				this.turtleParameters.length = 0;
				break;
			case "FILL_OFF":
				if(this.turtleHistoryOn) {
					this.historyAdd("FILL_OFF");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("FILL_OFF");
				} else {
					this.fill = false;
				}
				break;
			case "FILL_ON":
				if(this.turtleHistoryOn) {
					this.historyAdd("FILL_ON");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("FILL_ON");
				} else {
					this.fill = true;
				}
				break;
			case "FORWARD":
				var distance17 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("FORWARD");
					this.historyParameters.push(distance17);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("FORWARD");
					this.turtleParameters.push(distance17);
				} else {
					var nx30 = this.x + distance17 * Math.cos(this.rotation);
					var ny30 = this.y + distance17 * Math.sin(this.rotation);
					if(this.penIsDown) {
						this.lastDistance = distance17;
						this.lineTo(nx30,ny30);
					} else {
						var tmp40;
						switch(this.endLine) {
						case 0:case 1:case 6:case 9:case 12:case 15:case 18:
							tmp40 = false;
							break;
						case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
							tmp40 = true;
							break;
						}
						if(tmp40) {
							this.contour.end(this.width);
						}
						this.x = nx30;
						this.y = ny30;
						var l58 = this.points.length;
						this.points[l58] = [];
						this.points[l58][0] = nx30;
						this.points[l58][1] = ny30;
						this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
						this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
						this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d40 = this.dim[this.dim.length - 1];
						if(nx30 < d40.minX) {
							d40.minX = nx30;
						}
						if(nx30 > d40.maxX) {
							d40.maxX = nx30;
						}
						if(ny30 < d40.minY) {
							d40.minY = ny30;
						}
						if(ny30 > d40.maxY) {
							d40.maxY = ny30;
						}
						this.contour.reset();
					}
				}
				++j;
				break;
			case "FORWARD_CHANGE":
				var deltaDistance2 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("FORWARD_CHANGE");
					this.historyParameters.push(deltaDistance2);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("FORWARD_CHANGE");
					this.turtleParameters.push(deltaDistance2);
				} else {
					var distance18 = this.lastDistance + deltaDistance2;
					var nx31 = this.x + distance18 * Math.cos(this.rotation);
					var ny31 = this.y + distance18 * Math.sin(this.rotation);
					if(this.penIsDown) {
						this.lastDistance = distance18 + deltaDistance2;
						this.lineTo(nx31,ny31);
					} else {
						var tmp41;
						switch(this.endLine) {
						case 0:case 1:case 6:case 9:case 12:case 15:case 18:
							tmp41 = false;
							break;
						case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
							tmp41 = true;
							break;
						}
						if(tmp41) {
							this.contour.end(this.width);
						}
						this.x = nx31;
						this.y = ny31;
						var l59 = this.points.length;
						this.points[l59] = [];
						this.points[l59][0] = nx31;
						this.points[l59][1] = ny31;
						this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
						this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
						this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d41 = this.dim[this.dim.length - 1];
						if(nx31 < d41.minX) {
							d41.minX = nx31;
						}
						if(nx31 > d41.maxX) {
							d41.maxX = nx31;
						}
						if(ny31 < d41.minY) {
							d41.minY = ny31;
						}
						if(ny31 > d41.maxY) {
							d41.maxY = ny31;
						}
						this.contour.reset();
					}
				}
				++j;
				break;
			case "FORWARD_FACTOR":
				var factor4 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("FORWARD_FACTOR");
					this.historyParameters.push(factor4);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("FORWARD_FACTOR");
					this.turtleParameters.push(factor4);
				} else {
					var distance19 = this.lastDistance * factor4;
					var nx32 = this.x + distance19 * Math.cos(this.rotation);
					var ny32 = this.y + distance19 * Math.sin(this.rotation);
					if(this.penIsDown) {
						this.lastDistance = distance19;
						this.lineTo(nx32,ny32);
					} else {
						var tmp42;
						switch(this.endLine) {
						case 0:case 1:case 6:case 9:case 12:case 15:case 18:
							tmp42 = false;
							break;
						case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
							tmp42 = true;
							break;
						}
						if(tmp42) {
							this.contour.end(this.width);
						}
						this.x = nx32;
						this.y = ny32;
						var l60 = this.points.length;
						this.points[l60] = [];
						this.points[l60][0] = nx32;
						this.points[l60][1] = ny32;
						this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
						this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
						this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d42 = this.dim[this.dim.length - 1];
						if(nx32 < d42.minX) {
							d42.minX = nx32;
						}
						if(nx32 > d42.maxX) {
							d42.maxX = nx32;
						}
						if(ny32 < d42.minY) {
							d42.minY = ny32;
						}
						if(ny32 > d42.maxY) {
							d42.maxY = ny32;
						}
						this.contour.reset();
					}
				}
				++j;
				break;
			case "GREEN":
				if(this.turtleHistoryOn) {
					this.historyAdd("GREEN");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("GREEN");
				} else {
					this.pen.currentColor = -16711936;
				}
				break;
			case "GREY":
				if(this.turtleHistoryOn) {
					this.historyAdd("GREY");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("GREY");
				} else {
					this.pen.currentColor = -4737097;
				}
				break;
			case "LEFT":
				var degrees12 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("LEFT");
					this.historyParameters.push(degrees12);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("LEFT");
					this.turtleParameters.push(degrees12);
				} else {
					this.rotation -= degrees12 * Math.PI / 180;
				}
				++j;
				break;
			case "LIGHT_BROWN":
				if(this.turtleHistoryOn) {
					this.historyAdd("LIGHT_BROWN");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("LIGHT_BROWN");
				} else {
					this.pen.currentColor = -3831790;
				}
				break;
			case "LINE_STYLE":
				var thickness2 = v[j];
				var color2 = v[j + 1];
				if(this.turtleHistoryOn) {
					this.historyAdd("LINE_STYLE");
					this.historyParameters.push(thickness2);
					this.historyParameters.push(color2);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("LINE_STYLE");
					this.historyParameters.push(thickness2);
					this.historyParameters.push(color2);
				} else {
					this.width = thickness2;
					this.pen.currentColor = color2 | 0;
				}
				j += 2;
				break;
			case "MAGENTA":
				if(this.turtleHistoryOn) {
					this.historyAdd("MAGENTA");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("MAGENTA");
				} else {
					this.pen.currentColor = -65281;
				}
				break;
			case "MOVE_PEN":
				var distance20 = v[j];
				if(this.repeatCommands) {
					this.turtleCommands.push("MOVE_PEN");
					this.turtleParameters.push(distance20);
				} else if(this.penIsDown) {
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_UP");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_UP");
					} else {
						this.penIsDown = false;
					}
					if(this.turtleHistoryOn) {
						this.historyAdd("FORWARD");
						this.historyParameters.push(distance20);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FORWARD");
						this.turtleParameters.push(distance20);
					} else {
						var nx33 = this.x + distance20 * Math.cos(this.rotation);
						var ny33 = this.y + distance20 * Math.sin(this.rotation);
						if(this.penIsDown) {
							this.lastDistance = distance20;
							this.lineTo(nx33,ny33);
						} else {
							var tmp43;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp43 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp43 = true;
								break;
							}
							if(tmp43) {
								this.contour.end(this.width);
							}
							this.x = nx33;
							this.y = ny33;
							var l61 = this.points.length;
							this.points[l61] = [];
							this.points[l61][0] = nx33;
							this.points[l61][1] = ny33;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d43 = this.dim[this.dim.length - 1];
							if(nx33 < d43.minX) {
								d43.minX = nx33;
							}
							if(nx33 > d43.maxX) {
								d43.maxX = nx33;
							}
							if(ny33 < d43.minY) {
								d43.minY = ny33;
							}
							if(ny33 > d43.maxY) {
								d43.maxY = ny33;
							}
							this.contour.reset();
						}
					}
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_DOWN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_DOWN");
					} else {
						this.penIsDown = true;
					}
				} else {
					if(this.turtleHistoryOn) {
						this.historyAdd("FORWARD");
						this.historyParameters.push(distance20);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FORWARD");
						this.turtleParameters.push(distance20);
					} else {
						var nx34 = this.x + distance20 * Math.cos(this.rotation);
						var ny34 = this.y + distance20 * Math.sin(this.rotation);
						if(this.penIsDown) {
							this.lastDistance = distance20;
							this.lineTo(nx34,ny34);
						} else {
							var tmp44;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp44 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp44 = true;
								break;
							}
							if(tmp44) {
								this.contour.end(this.width);
							}
							this.x = nx34;
							this.y = ny34;
							var l62 = this.points.length;
							this.points[l62] = [];
							this.points[l62][0] = nx34;
							this.points[l62][1] = ny34;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d44 = this.dim[this.dim.length - 1];
							if(nx34 < d44.minX) {
								d44.minX = nx34;
							}
							if(nx34 > d44.maxX) {
								d44.maxX = nx34;
							}
							if(ny34 < d44.minY) {
								d44.minY = ny34;
							}
							if(ny34 > d44.maxY) {
								d44.maxY = ny34;
							}
							this.contour.reset();
						}
					}
				}
				++j;
				break;
			case "NORTH":
				if(this.turtleHistoryOn) {
					this.historyAdd("NORTH");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("NORTH");
				} else {
					this.rotation = -Math.PI / 2;
				}
				break;
			case "ORANGE":
				if(this.turtleHistoryOn) {
					this.historyAdd("ORANGE");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("ORANGE");
				} else {
					this.pen.currentColor = -23808;
				}
				break;
			case "PEN_COLOR":
				var r12 = v[j];
				var g12 = v[j + 1];
				var b12 = v[j + 2];
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_COLOR");
					this.historyParameters.push(r12);
					this.historyParameters.push(g12);
					this.historyParameters.push(b12);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_COLOR");
					this.turtleParameters.push(r12);
					this.turtleParameters.push(g12);
					this.turtleParameters.push(b12);
				} else {
					this.pen.currentColor = Math.round(255) << 24 | Math.round(r12 * 255) << 16 | Math.round(g12 * 255) << 8 | Math.round(b12 * 255);
				}
				j += 3;
				break;
			case "PEN_COLOR_B":
				var r13 = v[j];
				var g13 = v[j + 1];
				var b13 = v[j + 2];
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_COLOR_B");
					this.historyParameters.push(r13);
					this.historyParameters.push(g13);
					this.historyParameters.push(b13);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_COLOR_B");
					this.turtleParameters.push(r13);
					this.turtleParameters.push(g13);
					this.turtleParameters.push(b13);
				} else {
					this.pen.colorB = Math.round(255) << 24 | Math.round(r13 * 255) << 16 | Math.round(g13 * 255) << 8 | Math.round(b13 * 255);
				}
				j += 3;
				break;
			case "PEN_COLOR_C":
				var r14 = v[j];
				var g14 = v[j + 1];
				var b14 = v[j + 2];
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_COLOR_C");
					this.historyParameters.push(r14);
					this.historyParameters.push(g14);
					this.historyParameters.push(b14);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_COLOR_C");
					this.turtleParameters.push(r14);
					this.turtleParameters.push(g14);
					this.turtleParameters.push(b14);
				} else {
					this.pen.colorC = Math.round(255) << 24 | Math.round(r14 * 255) << 16 | Math.round(g14 * 255) << 8 | Math.round(b14 * 255);
				}
				j += 3;
				break;
			case "PEN_COLOR_CHANGE":
				var r15 = v[j];
				var g15 = v[j + 1];
				var b15 = v[j + 2];
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_COLOR_CHANGE");
					this.historyParameters.push(r15);
					this.historyParameters.push(g15);
					this.historyParameters.push(b15);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_COLOR_CHANGE");
					this.turtleParameters.push(r15);
					this.turtleParameters.push(g15);
					this.turtleParameters.push(b15);
				} else {
					var c6 = this.pen.currentColor;
					var r06 = (c6 >> 16 & 255) / 255;
					var g06 = (c6 >> 8 & 255) / 255;
					var b06 = (c6 & 255) / 255;
					this.pen.currentColor = Math.round(255) << 24 | Math.round((r06 + r15) * 255) << 16 | Math.round((g06 + g15) * 255) << 8 | Math.round((b06 + b15) * 255);
				}
				j += 3;
				break;
			case "PEN_COLOR_CHANGE_B":
				var r16 = v[j];
				var g16 = v[j + 1];
				var b16 = v[j + 2];
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_COLOR_CHANGE_B");
					this.historyParameters.push(r16);
					this.historyParameters.push(g16);
					this.historyParameters.push(b16);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_COLOR_CHANGE_B");
					this.turtleParameters.push(r16);
					this.turtleParameters.push(g16);
					this.turtleParameters.push(b16);
				} else {
					var c7 = this.pen.colorB;
					var r07 = (c7 >> 16 & 255) / 255;
					var g07 = (c7 >> 8 & 255) / 255;
					var b07 = (c7 & 255) / 255;
					this.pen.colorB = Math.round(255) << 24 | Math.round((r07 + r16) * 255) << 16 | Math.round((g07 + g16) * 255) << 8 | Math.round((b07 + b16) * 255);
				}
				j += 3;
				break;
			case "PEN_COLOR_CHANGE_C":
				var r17 = v[j];
				var g17 = v[j + 1];
				var b17 = v[j + 2];
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_COLOR_CHANGE_C");
					this.historyParameters.push(r17);
					this.historyParameters.push(g17);
					this.historyParameters.push(b17);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_COLOR_CHANGE_C");
					this.turtleParameters.push(r17);
					this.turtleParameters.push(g17);
					this.turtleParameters.push(b17);
				} else {
					var c8 = this.pen.colorC;
					var r08 = (c8 >> 16 & 255) / 255;
					var g08 = (c8 >> 8 & 255) / 255;
					var b08 = (c8 & 255) / 255;
					this.pen.colorC = Math.round(255) << 24 | Math.round((r08 + r17) * 255) << 16 | Math.round((g08 + g17) * 255) << 8 | Math.round((b08 + b17) * 255);
				}
				j += 3;
				break;
			case "PEN_DOWN":
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_DOWN");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_DOWN");
				} else {
					this.penIsDown = true;
				}
				break;
			case "PEN_SIZE":
				var w2 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_SIZE");
					this.historyParameters.push(w2);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_SIZE");
					this.turtleParameters.push(w2);
				} else {
					this.width = w2;
				}
				++j;
				break;
			case "PEN_SIZE_CHANGE":
				var dw2 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_SIZE_CHANGE");
					this.historyParameters.push(dw2);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_SIZE_CHANGE");
					this.turtleParameters.push(dw2);
				} else {
					this.width += dw2;
				}
				++j;
				break;
			case "PEN_SIZE_FACTOR":
				var factor5 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_SIZE_FACTOR");
					this.historyParameters.push(factor5);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_SIZE_FACTOR");
					this.turtleParameters.push(factor5);
				} else {
					this.width *= factor5;
				}
				++j;
				break;
			case "PEN_UP":
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_UP");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_UP");
				} else {
					this.penIsDown = false;
				}
				break;
			case "PLUM":
				if(this.turtleHistoryOn) {
					this.historyAdd("PLUM");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PLUM");
				} else {
					this.pen.currentColor = -7310896;
				}
				break;
			case "RED":
				if(this.turtleHistoryOn) {
					this.historyAdd("RED");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("RED");
				} else {
					this.pen.currentColor = -65536;
				}
				break;
			case "RIGHT":
				var degrees13 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("RIGHT");
					this.historyParameters.push(degrees13);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("RIGHT");
					this.turtleParameters.push(degrees13);
				} else {
					this.rotation += degrees13 * Math.PI / 180;
				}
				++j;
				break;
			case "SET_ANGLE":
				var degrees14 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("SET_ANGLE");
					this.historyParameters.push(degrees14);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("SET_ANGLE");
					this.turtleParameters.push(degrees14);
				} else {
					this.rotation = -Math.PI / 2;
					this.rotation += degrees14 * Math.PI / 180;
				}
				++j;
				break;
			case "SET_POSITION":
				var x8 = v[j];
				var y8 = v[j + 1];
				if(this.turtleHistoryOn) {
					this.historyAdd("SET_POSITION");
					this.historyParameters.push(x8);
					this.historyParameters.push(y8);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("SET_POSITION");
					this.turtleParameters.push(x8);
					this.turtleParameters.push(y8);
				} else {
					var tmp45;
					switch(this.endLine) {
					case 0:case 1:case 6:case 9:case 12:case 15:case 18:
						tmp45 = false;
						break;
					case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
						tmp45 = true;
						break;
					}
					if(tmp45) {
						this.contour.end(this.width);
					}
					this.x = x8;
					this.y = y8;
					var l63 = this.points.length;
					this.points[l63] = [];
					this.points[l63][0] = x8;
					this.points[l63][1] = y8;
					this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
					this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
					this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d45 = this.dim[this.dim.length - 1];
					if(x8 < d45.minX) {
						d45.minX = x8;
					}
					if(x8 > d45.maxX) {
						d45.maxX = x8;
					}
					if(y8 < d45.minY) {
						d45.minY = y8;
					}
					if(y8 > d45.maxY) {
						d45.maxY = y8;
					}
					this.contour.reset();
				}
				j += 2;
				break;
			case "SOUTH":
				if(this.turtleHistoryOn) {
					this.historyAdd("SOUTH");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("SOUTH");
				} else {
					this.rotation = Math.PI / 2;
				}
				break;
			case "TAN":
				if(this.turtleHistoryOn) {
					this.historyAdd("TAN");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("TAN");
				} else {
					this.pen.currentColor = -27273;
				}
				break;
			case "TRIANGLE_ARCH":
				var distance25 = v[j];
				var distance26 = v[j + 1];
				var radius17 = v[j + 2];
				if(this.turtleHistoryOn) {
					this.historyAdd("TRIANGLE_ARCH");
					this.historyParameters.push(distance25);
					this.historyParameters.push(distance26);
					this.historyParameters.push(radius17);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("TRIANGLE_ARCH");
					this.turtleParameters.push(distance25);
					this.turtleParameters.push(distance26);
					this.turtleParameters.push(radius17);
				} else {
					var nx35 = this.x + distance25 * Math.cos(this.rotation);
					var ny35 = this.y + distance25 * Math.sin(this.rotation);
					if(this.penIsDown) {
						var thruX5 = this.x + distance26 * Math.cos(this.rotation) - radius17 * Math.cos(this.rotation + Math.PI / 2);
						var thruY5 = this.y + distance26 * Math.sin(this.rotation) - radius17 * Math.sin(this.rotation + Math.PI / 2);
						if(this.fill) {
							this.pen.triangle2DFill(this.x,this.y,thruX5,thruY5,nx35,ny35);
						}
						this.lineTo(thruX5,thruY5);
						this.lineTo(nx35,ny35);
						if(this.fill) {
							this.lineTo(this.x,this.y);
						}
						var tmp46;
						switch(this.endLine) {
						case 0:case 1:case 6:case 9:case 12:case 15:case 18:
							tmp46 = false;
							break;
						case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
							tmp46 = true;
							break;
						}
						if(tmp46) {
							this.contour.end(this.width);
						}
						this.x = nx35;
						this.y = ny35;
						var l64 = this.points.length;
						this.points[l64] = [];
						this.points[l64][0] = nx35;
						this.points[l64][1] = ny35;
						this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
						this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
						this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d46 = this.dim[this.dim.length - 1];
						if(nx35 < d46.minX) {
							d46.minX = nx35;
						}
						if(nx35 > d46.maxX) {
							d46.maxX = nx35;
						}
						if(ny35 < d46.minY) {
							d46.minY = ny35;
						}
						if(ny35 > d46.maxY) {
							d46.maxY = ny35;
						}
						this.contour.reset();
					} else {
						var tmp47;
						switch(this.endLine) {
						case 0:case 1:case 6:case 9:case 12:case 15:case 18:
							tmp47 = false;
							break;
						case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
							tmp47 = true;
							break;
						}
						if(tmp47) {
							this.contour.end(this.width);
						}
						this.x = nx35;
						this.y = ny35;
						var l65 = this.points.length;
						this.points[l65] = [];
						this.points[l65][0] = nx35;
						this.points[l65][1] = ny35;
						this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
						this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
						this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d47 = this.dim[this.dim.length - 1];
						if(nx35 < d47.minX) {
							d47.minX = nx35;
						}
						if(nx35 > d47.maxX) {
							d47.maxX = nx35;
						}
						if(ny35 < d47.minY) {
							d47.minY = ny35;
						}
						if(ny35 > d47.maxY) {
							d47.maxY = ny35;
						}
						this.contour.reset();
					}
				}
				j += 3;
				break;
			case "WEST":
				if(this.turtleHistoryOn) {
					this.historyAdd("WEST");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("WEST");
				} else {
					this.rotation = 0;
				}
				break;
			case "WHITE":
				if(this.turtleHistoryOn) {
					this.historyAdd("WHITE");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("WHITE");
				} else {
					this.pen.currentColor = -1;
				}
				break;
			case "YELLOW":
				if(this.turtleHistoryOn) {
					this.historyAdd("YELLOW");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("YELLOW");
				} else {
					this.pen.currentColor = -256;
				}
				break;
			}
		}
	}
	,fillOn: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("FILL_ON");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("FILL_ON");
		} else {
			this.fill = true;
		}
		return this;
	}
	,fillon: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("FILL_ON");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("FILL_ON");
		} else {
			this.fill = true;
		}
		return this;
	}
	,fillOff: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("FILL_OFF");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("FILL_OFF");
		} else {
			this.fill = false;
		}
		return this;
	}
	,filloff: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("FILL_OFF");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("FILL_OFF");
		} else {
			this.fill = false;
		}
		return this;
	}
	,penUp: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("PEN_UP");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("PEN_UP");
		} else {
			this.penIsDown = false;
		}
		return this;
	}
	,penup: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("PEN_UP");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("PEN_UP");
		} else {
			this.penIsDown = false;
		}
		return this;
	}
	,up: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("PEN_UP");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("PEN_UP");
		} else {
			this.penIsDown = false;
		}
		return this;
	}
	,penDown: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("PEN_DOWN");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("PEN_DOWN");
		} else {
			this.penIsDown = true;
		}
		return this;
	}
	,pendown: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("PEN_DOWN");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("PEN_DOWN");
		} else {
			this.penIsDown = true;
		}
		return this;
	}
	,down: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("PEN_DOWN");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("PEN_DOWN");
		} else {
			this.penIsDown = true;
		}
		return this;
	}
	,toRadians: function(degrees) {
		return degrees * Math.PI / 180;
	}
	,left: function(degrees) {
		if(this.turtleHistoryOn) {
			this.historyAdd("LEFT");
			this.historyParameters.push(degrees);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("LEFT");
			this.turtleParameters.push(degrees);
		} else {
			this.rotation -= degrees * Math.PI / 180;
		}
		return this;
	}
	,lt: function(degrees) {
		if(this.turtleHistoryOn) {
			this.historyAdd("LEFT");
			this.historyParameters.push(degrees);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("LEFT");
			this.turtleParameters.push(degrees);
		} else {
			this.rotation -= degrees * Math.PI / 180;
		}
		return this;
	}
	,right: function(degrees) {
		if(this.turtleHistoryOn) {
			this.historyAdd("RIGHT");
			this.historyParameters.push(degrees);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("RIGHT");
			this.turtleParameters.push(degrees);
		} else {
			this.rotation += degrees * Math.PI / 180;
		}
		return this;
	}
	,turn: function(degrees) {
		if(this.turtleHistoryOn) {
			this.historyAdd("RIGHT");
			this.historyParameters.push(degrees);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("RIGHT");
			this.turtleParameters.push(degrees);
		} else {
			this.rotation += degrees * Math.PI / 180;
		}
		return this;
	}
	,rt: function(degrees) {
		if(this.turtleHistoryOn) {
			this.historyAdd("RIGHT");
			this.historyParameters.push(degrees);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("RIGHT");
			this.turtleParameters.push(degrees);
		} else {
			this.rotation += degrees * Math.PI / 180;
		}
		return this;
	}
	,setAngle: function(degrees) {
		if(this.turtleHistoryOn) {
			this.historyAdd("SET_ANGLE");
			this.historyParameters.push(degrees);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("SET_ANGLE");
			this.turtleParameters.push(degrees);
		} else {
			this.rotation = -Math.PI / 2;
			this.rotation += degrees * Math.PI / 180;
		}
		return this;
	}
	,forward: function(distance) {
		if(this.turtleHistoryOn) {
			this.historyAdd("FORWARD");
			this.historyParameters.push(distance);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("FORWARD");
			this.turtleParameters.push(distance);
		} else {
			var nx = this.x + distance * Math.cos(this.rotation);
			var ny = this.y + distance * Math.sin(this.rotation);
			if(this.penIsDown) {
				this.lastDistance = distance;
				this.lineTo(nx,ny);
			} else {
				var tmp;
				switch(this.endLine) {
				case 0:case 1:case 6:case 9:case 12:case 15:case 18:
					tmp = false;
					break;
				case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
					tmp = true;
					break;
				}
				if(tmp) {
					this.contour.end(this.width);
				}
				this.x = nx;
				this.y = ny;
				var l = this.points.length;
				this.points[l] = [];
				this.points[l][0] = nx;
				this.points[l][1] = ny;
				this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
				this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
				this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = this.dim[this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				this.contour.reset();
			}
		}
		return this;
	}
	,forwardChange: function(deltaDistance) {
		if(this.turtleHistoryOn) {
			this.historyAdd("FORWARD_CHANGE");
			this.historyParameters.push(deltaDistance);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("FORWARD_CHANGE");
			this.turtleParameters.push(deltaDistance);
		} else {
			var distance = this.lastDistance + deltaDistance;
			var nx = this.x + distance * Math.cos(this.rotation);
			var ny = this.y + distance * Math.sin(this.rotation);
			if(this.penIsDown) {
				this.lastDistance = distance + deltaDistance;
				this.lineTo(nx,ny);
			} else {
				var tmp;
				switch(this.endLine) {
				case 0:case 1:case 6:case 9:case 12:case 15:case 18:
					tmp = false;
					break;
				case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
					tmp = true;
					break;
				}
				if(tmp) {
					this.contour.end(this.width);
				}
				this.x = nx;
				this.y = ny;
				var l = this.points.length;
				this.points[l] = [];
				this.points[l][0] = nx;
				this.points[l][1] = ny;
				this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
				this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
				this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = this.dim[this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				this.contour.reset();
			}
		}
		return this;
	}
	,forwardFactor: function(factor) {
		if(this.turtleHistoryOn) {
			this.historyAdd("FORWARD_FACTOR");
			this.historyParameters.push(factor);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("FORWARD_FACTOR");
			this.turtleParameters.push(factor);
		} else {
			var distance = this.lastDistance * factor;
			var nx = this.x + distance * Math.cos(this.rotation);
			var ny = this.y + distance * Math.sin(this.rotation);
			if(this.penIsDown) {
				this.lastDistance = distance;
				this.lineTo(nx,ny);
			} else {
				var tmp;
				switch(this.endLine) {
				case 0:case 1:case 6:case 9:case 12:case 15:case 18:
					tmp = false;
					break;
				case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
					tmp = true;
					break;
				}
				if(tmp) {
					this.contour.end(this.width);
				}
				this.x = nx;
				this.y = ny;
				var l = this.points.length;
				this.points[l] = [];
				this.points[l][0] = nx;
				this.points[l][1] = ny;
				this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
				this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
				this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = this.dim[this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				this.contour.reset();
			}
		}
		return this;
	}
	,triangleArch: function(distance,distance2,radius) {
		if(this.turtleHistoryOn) {
			this.historyAdd("TRIANGLE_ARCH");
			this.historyParameters.push(distance);
			this.historyParameters.push(distance2);
			this.historyParameters.push(radius);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("TRIANGLE_ARCH");
			this.turtleParameters.push(distance);
			this.turtleParameters.push(distance2);
			this.turtleParameters.push(radius);
		} else {
			var nx = this.x + distance * Math.cos(this.rotation);
			var ny = this.y + distance * Math.sin(this.rotation);
			if(this.penIsDown) {
				var thruX = this.x + distance2 * Math.cos(this.rotation) - radius * Math.cos(this.rotation + Math.PI / 2);
				var thruY = this.y + distance2 * Math.sin(this.rotation) - radius * Math.sin(this.rotation + Math.PI / 2);
				if(this.fill) {
					this.pen.triangle2DFill(this.x,this.y,thruX,thruY,nx,ny);
				}
				this.lineTo(thruX,thruY);
				this.lineTo(nx,ny);
				if(this.fill) {
					this.lineTo(this.x,this.y);
				}
				var tmp;
				switch(this.endLine) {
				case 0:case 1:case 6:case 9:case 12:case 15:case 18:
					tmp = false;
					break;
				case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
					tmp = true;
					break;
				}
				if(tmp) {
					this.contour.end(this.width);
				}
				this.x = nx;
				this.y = ny;
				var l = this.points.length;
				this.points[l] = [];
				this.points[l][0] = nx;
				this.points[l][1] = ny;
				this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
				this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
				this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = this.dim[this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				this.contour.reset();
			} else {
				var tmp;
				switch(this.endLine) {
				case 0:case 1:case 6:case 9:case 12:case 15:case 18:
					tmp = false;
					break;
				case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
					tmp = true;
					break;
				}
				if(tmp) {
					this.contour.end(this.width);
				}
				this.x = nx;
				this.y = ny;
				var l = this.points.length;
				this.points[l] = [];
				this.points[l][0] = nx;
				this.points[l][1] = ny;
				this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
				this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
				this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = this.dim[this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				this.contour.reset();
			}
		}
		return this;
	}
	,archBezier: function(distance,distance2,radius) {
		if(this.turtleHistoryOn) {
			this.historyAdd("ARCH_BEZIER");
			this.historyParameters.push(distance);
			this.historyParameters.push(distance2);
			this.historyParameters.push(radius);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("ARCH_BEZIER");
			this.turtleParameters.push(distance);
			this.turtleParameters.push(distance2);
			this.turtleParameters.push(radius);
		} else {
			var nx = this.x + distance * Math.cos(this.rotation);
			var ny = this.y + distance * Math.sin(this.rotation);
			if(this.penIsDown) {
				var thruX = this.x + distance2 * Math.cos(this.rotation) - radius * Math.cos(this.rotation + Math.PI / 2);
				var thruY = this.y + distance2 * Math.sin(this.rotation) - radius * Math.sin(this.rotation + Math.PI / 2);
				var newx = 2 * thruX - 0.5 * (this.x + nx);
				var newy = 2 * thruY - 0.5 * (this.y + ny);
				this.tempArr = [];
				var p = this.tempArr;
				var ax = this.x;
				var ay = this.y;
				var x = ax - newx;
				var y = ay - newy;
				var x1 = newx - nx;
				var y1 = newy - ny;
				var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
				if(approxDistance == 0) {
					approxDistance = 0.000001;
				}
				var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
				var l = p.length;
				p[l++] = ax;
				p[l++] = ay;
				var t = step;
				while(t < 1.) {
					var u = 1 - t;
					p[l++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx;
					var u1 = 1 - t;
					p[l++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny;
					t += step;
				}
				p[l++] = nx;
				p[l++] = ny;
				var arr = this.tempArr;
				var withMove = false;
				if(withMove == null) {
					withMove = true;
				}
				var l = arr.length;
				var i = 2;
				if(withMove) {
					var x_ = arr[0];
					var y_ = arr[1];
					var tmp;
					switch(this.endLine) {
					case 0:case 1:case 6:case 9:case 12:case 15:case 18:
						tmp = false;
						break;
					case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
						tmp = true;
						break;
					}
					if(tmp) {
						this.contour.end(this.width);
					}
					this.x = x_;
					this.y = y_;
					var l1 = this.points.length;
					this.points[l1] = [];
					this.points[l1][0] = x_;
					this.points[l1][1] = y_;
					this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
					this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
					this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d = this.dim[this.dim.length - 1];
					if(x_ < d.minX) {
						d.minX = x_;
					}
					if(x_ > d.maxX) {
						d.maxX = x_;
					}
					if(y_ < d.minY) {
						d.minY = y_;
					}
					if(y_ > d.maxY) {
						d.maxY = y_;
					}
					this.contour.reset();
				} else {
					this.lineTo(arr[0],arr[1]);
				}
				var cx = (arr[0] + arr[l - 2]) / 2;
				var cy = (arr[1] + arr[l - 1]) / 2;
				var ox = this.x;
				var oy = this.y;
				while(i < l) {
					if(this.fill && this.penIsDown) {
						if(i > 0 && i < l - 2) {
							this.pen.triangle2DFill(arr[i - 2],arr[i - 1],arr[i],arr[i + 1],cx,cy);
						}
					}
					this.lineTo(arr[i],arr[i + 1]);
					i += 2;
				}
				if(this.fill && this.penIsDown) {
					var tmp;
					switch(this.endLine) {
					case 0:case 1:case 6:case 9:case 12:case 15:case 18:
						tmp = false;
						break;
					case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
						tmp = true;
						break;
					}
					if(tmp) {
						this.contour.end(this.width);
					}
					this.x = ox;
					this.y = oy;
					var l1 = this.points.length;
					this.points[l1] = [];
					this.points[l1][0] = ox;
					this.points[l1][1] = oy;
					this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
					this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
					this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d = this.dim[this.dim.length - 1];
					if(ox < d.minX) {
						d.minX = ox;
					}
					if(ox > d.maxX) {
						d.maxX = ox;
					}
					if(oy < d.minY) {
						d.minY = oy;
					}
					if(oy > d.maxY) {
						d.maxY = oy;
					}
					this.contour.reset();
					this.lineTo(arr[l - 2],arr[l - 1]);
				}
				this.x = nx;
				this.y = ny;
			} else {
				var tmp;
				switch(this.endLine) {
				case 0:case 1:case 6:case 9:case 12:case 15:case 18:
					tmp = false;
					break;
				case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
					tmp = true;
					break;
				}
				if(tmp) {
					this.contour.end(this.width);
				}
				this.x = nx;
				this.y = ny;
				var l = this.points.length;
				this.points[l] = [];
				this.points[l][0] = nx;
				this.points[l][1] = ny;
				this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
				this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
				this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = this.dim[this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				this.contour.reset();
			}
		}
		return this;
	}
	,fd: function(distance) {
		if(this.turtleHistoryOn) {
			this.historyAdd("FORWARD");
			this.historyParameters.push(distance);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("FORWARD");
			this.turtleParameters.push(distance);
		} else {
			var nx = this.x + distance * Math.cos(this.rotation);
			var ny = this.y + distance * Math.sin(this.rotation);
			if(this.penIsDown) {
				this.lastDistance = distance;
				this.lineTo(nx,ny);
			} else {
				var tmp;
				switch(this.endLine) {
				case 0:case 1:case 6:case 9:case 12:case 15:case 18:
					tmp = false;
					break;
				case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
					tmp = true;
					break;
				}
				if(tmp) {
					this.contour.end(this.width);
				}
				this.x = nx;
				this.y = ny;
				var l = this.points.length;
				this.points[l] = [];
				this.points[l][0] = nx;
				this.points[l][1] = ny;
				this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
				this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
				this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = this.dim[this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				this.contour.reset();
			}
		}
		return this;
	}
	,backward: function(distance) {
		if(this.turtleHistoryOn) {
			this.historyAdd("BACKWARD");
			this.historyParameters.push(distance);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("BACKWARD");
			this.turtleParameters.push(distance);
		} else {
			var nx = this.x + distance * Math.cos(this.rotation + Math.PI);
			var ny = this.y + distance * Math.sin(this.rotation + Math.PI);
			if(this.penIsDown) {
				this.lineTo(nx,ny);
			} else {
				var tmp;
				switch(this.endLine) {
				case 0:case 1:case 6:case 9:case 12:case 15:case 18:
					tmp = false;
					break;
				case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
					tmp = true;
					break;
				}
				if(tmp) {
					this.contour.end(this.width);
				}
				this.x = nx;
				this.y = ny;
				var l = this.points.length;
				this.points[l] = [];
				this.points[l][0] = nx;
				this.points[l][1] = ny;
				this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
				this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
				this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = this.dim[this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				this.contour.reset();
			}
		}
		return this;
	}
	,bk: function(distance) {
		if(this.turtleHistoryOn) {
			this.historyAdd("BACKWARD");
			this.historyParameters.push(distance);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("BACKWARD");
			this.turtleParameters.push(distance);
		} else {
			var nx = this.x + distance * Math.cos(this.rotation + Math.PI);
			var ny = this.y + distance * Math.sin(this.rotation + Math.PI);
			if(this.penIsDown) {
				this.lineTo(nx,ny);
			} else {
				var tmp;
				switch(this.endLine) {
				case 0:case 1:case 6:case 9:case 12:case 15:case 18:
					tmp = false;
					break;
				case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
					tmp = true;
					break;
				}
				if(tmp) {
					this.contour.end(this.width);
				}
				this.x = nx;
				this.y = ny;
				var l = this.points.length;
				this.points[l] = [];
				this.points[l][0] = nx;
				this.points[l][1] = ny;
				this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
				this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
				this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = this.dim[this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				this.contour.reset();
			}
		}
		return this;
	}
	,movePen: function(distance) {
		if(this.repeatCommands) {
			this.turtleCommands.push("MOVE_PEN");
			this.turtleParameters.push(distance);
		} else if(this.penIsDown) {
			if(this.turtleHistoryOn) {
				this.historyAdd("PEN_UP");
			}
			if(this.repeatCommands) {
				this.turtleCommands.push("PEN_UP");
			} else {
				this.penIsDown = false;
			}
			if(this.turtleHistoryOn) {
				this.historyAdd("FORWARD");
				this.historyParameters.push(distance);
			}
			if(this.repeatCommands) {
				this.turtleCommands.push("FORWARD");
				this.turtleParameters.push(distance);
			} else {
				var nx = this.x + distance * Math.cos(this.rotation);
				var ny = this.y + distance * Math.sin(this.rotation);
				if(this.penIsDown) {
					this.lastDistance = distance;
					this.lineTo(nx,ny);
				} else {
					var tmp;
					switch(this.endLine) {
					case 0:case 1:case 6:case 9:case 12:case 15:case 18:
						tmp = false;
						break;
					case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
						tmp = true;
						break;
					}
					if(tmp) {
						this.contour.end(this.width);
					}
					this.x = nx;
					this.y = ny;
					var l = this.points.length;
					this.points[l] = [];
					this.points[l][0] = nx;
					this.points[l][1] = ny;
					this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
					this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
					this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d = this.dim[this.dim.length - 1];
					if(nx < d.minX) {
						d.minX = nx;
					}
					if(nx > d.maxX) {
						d.maxX = nx;
					}
					if(ny < d.minY) {
						d.minY = ny;
					}
					if(ny > d.maxY) {
						d.maxY = ny;
					}
					this.contour.reset();
				}
			}
			if(this.turtleHistoryOn) {
				this.historyAdd("PEN_DOWN");
			}
			if(this.repeatCommands) {
				this.turtleCommands.push("PEN_DOWN");
			} else {
				this.penIsDown = true;
			}
		} else {
			if(this.turtleHistoryOn) {
				this.historyAdd("FORWARD");
				this.historyParameters.push(distance);
			}
			if(this.repeatCommands) {
				this.turtleCommands.push("FORWARD");
				this.turtleParameters.push(distance);
			} else {
				var nx = this.x + distance * Math.cos(this.rotation);
				var ny = this.y + distance * Math.sin(this.rotation);
				if(this.penIsDown) {
					this.lastDistance = distance;
					this.lineTo(nx,ny);
				} else {
					var tmp;
					switch(this.endLine) {
					case 0:case 1:case 6:case 9:case 12:case 15:case 18:
						tmp = false;
						break;
					case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
						tmp = true;
						break;
					}
					if(tmp) {
						this.contour.end(this.width);
					}
					this.x = nx;
					this.y = ny;
					var l = this.points.length;
					this.points[l] = [];
					this.points[l][0] = nx;
					this.points[l][1] = ny;
					this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
					this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
					this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d = this.dim[this.dim.length - 1];
					if(nx < d.minX) {
						d.minX = nx;
					}
					if(nx > d.maxX) {
						d.maxX = nx;
					}
					if(ny < d.minY) {
						d.minY = ny;
					}
					if(ny > d.maxY) {
						d.maxY = ny;
					}
					this.contour.reset();
				}
			}
		}
		return this;
	}
	,circle: function(radius,sides) {
		if(sides == null) {
			sides = 24;
		}
		if(this.turtleHistoryOn) {
			if(sides == 24) {
				this.historyAdd("CIRCLE");
				this.historyParameters.push(radius);
			} else {
				this.historyAdd("CIRCLE_SIDES");
				this.historyParameters.push(radius);
				this.historyParameters.push(sides);
			}
		}
		if(radius == 0) {
			return this;
		} else {
			if(this.repeatCommands) {
				if(sides == 24) {
					this.turtleCommands.push("CIRCLE");
					this.turtleParameters.push(radius);
				} else {
					this.turtleCommands.push("CIRCLE_SIDES");
					this.turtleParameters.push(radius);
					this.turtleParameters.push(sides);
				}
			} else {
				var beta = 2 * Math.PI / sides;
				var alpha = (Math.PI - beta) / 2;
				var rotate = -(Math.PI / 2 - alpha);
				var baseLength = 0.5 * radius * Math.sin(beta / 2);
				var ox = this.x;
				var oy = this.y;
				var arr = [];
				var _g = 0;
				while(_g < 48) {
					var i = _g++;
					this.rotation += rotate;
					var wasHistoryOn = this.turtleHistoryOn;
					this.turtleHistoryOn = false;
					if(this.turtleHistoryOn) {
						this.historyAdd("FORWARD");
						this.historyParameters.push(baseLength);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FORWARD");
						this.turtleParameters.push(baseLength);
					} else {
						var nx = this.x + baseLength * Math.cos(this.rotation);
						var ny = this.y + baseLength * Math.sin(this.rotation);
						if(this.penIsDown) {
							this.lastDistance = baseLength;
							this.lineTo(nx,ny);
						} else {
							var tmp;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp = true;
								break;
							}
							if(tmp) {
								this.contour.end(this.width);
							}
							this.x = nx;
							this.y = ny;
							var l = this.points.length;
							this.points[l] = [];
							this.points[l][0] = nx;
							this.points[l][1] = ny;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d = this.dim[this.dim.length - 1];
							if(nx < d.minX) {
								d.minX = nx;
							}
							if(nx > d.maxX) {
								d.maxX = nx;
							}
							if(ny < d.minY) {
								d.minY = ny;
							}
							if(ny > d.maxY) {
								d.maxY = ny;
							}
							this.contour.reset();
						}
					}
					this.turtleHistoryOn = wasHistoryOn;
					if(this.fill) {
						arr.push(this.x);
						arr.push(this.y);
					}
				}
				if(this.fill) {
					var cx = (ox + arr[arr.length - 2]) / 2;
					var cy = (oy + arr[arr.length - 1]) / 2;
					var l = arr.length;
					var i = 2;
					var lx = 0.;
					var ly = 0.;
					while(i < l) {
						if(i > 2) {
							this.pen.triangle2DFill(lx,ly,arr[i],arr[i + 1],cx,cy);
						}
						lx = arr[i];
						ly = arr[i + 1];
						i += 2;
					}
				}
				arr.length = 0;
			}
			return this;
		}
	}
	,arc: function(radius,degrees,sides) {
		if(sides == null) {
			sides = 24;
		}
		if(this.turtleHistoryOn) {
			if(sides == 24) {
				this.historyAdd("ARC");
				this.historyParameters.push(radius);
				this.historyParameters.push(degrees);
			} else {
				this.historyAdd("ARC_SIDES");
				this.historyParameters.push(radius);
				this.historyParameters.push(degrees);
				this.historyParameters.push(sides);
			}
		}
		if(radius == 0) {
			return this;
		} else {
			if(this.repeatCommands) {
				if(sides == 24) {
					this.turtleCommands.push("ARC");
					this.turtleParameters.push(radius);
					this.turtleParameters.push(degrees);
				} else {
					this.turtleCommands.push("ARC_SIDES");
					this.turtleParameters.push(radius);
					this.turtleParameters.push(degrees);
					this.turtleParameters.push(sides);
				}
			} else {
				var beta = degrees * Math.PI / 180 / sides;
				var alpha = (Math.PI - beta) / 2;
				var rotate = -(Math.PI / 2 - alpha);
				var baseLength = 0.5 * radius * Math.sin(beta / 2);
				var ox = this.x;
				var oy = this.y;
				var arr = [];
				arr.push(this.x);
				arr.push(this.y);
				var _g = 0;
				while(_g < 48) {
					var i = _g++;
					this.rotation += rotate;
					var wasHistoryOn = this.turtleHistoryOn;
					this.turtleHistoryOn = false;
					if(this.turtleHistoryOn) {
						this.historyAdd("FORWARD");
						this.historyParameters.push(baseLength);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FORWARD");
						this.turtleParameters.push(baseLength);
					} else {
						var nx = this.x + baseLength * Math.cos(this.rotation);
						var ny = this.y + baseLength * Math.sin(this.rotation);
						if(this.penIsDown) {
							this.lastDistance = baseLength;
							this.lineTo(nx,ny);
						} else {
							var tmp;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp = true;
								break;
							}
							if(tmp) {
								this.contour.end(this.width);
							}
							this.x = nx;
							this.y = ny;
							var l = this.points.length;
							this.points[l] = [];
							this.points[l][0] = nx;
							this.points[l][1] = ny;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d = this.dim[this.dim.length - 1];
							if(nx < d.minX) {
								d.minX = nx;
							}
							if(nx > d.maxX) {
								d.maxX = nx;
							}
							if(ny < d.minY) {
								d.minY = ny;
							}
							if(ny > d.maxY) {
								d.maxY = ny;
							}
							this.contour.reset();
						}
					}
					this.turtleHistoryOn = wasHistoryOn;
					if(this.fill) {
						arr.push(this.x);
						arr.push(this.y);
					}
				}
				if(this.fill) {
					var cx = (ox + arr[arr.length - 2]) / 2;
					var cy = (oy + arr[arr.length - 1]) / 2;
					var l = arr.length;
					var i = 2;
					var lx = 0.;
					var ly = 0.;
					this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
					while(i < l) {
						if(i > 2) {
							this.pen.triangle2DFill(lx,ly,arr[i],arr[i + 1],cx,cy);
						}
						lx = arr[i];
						ly = arr[i + 1];
						i += 2;
					}
				}
				arr.length = 0;
			}
			return this;
		}
	}
	,north: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("NORTH");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("NORTH");
		} else {
			this.rotation = -Math.PI / 2;
		}
		return this;
	}
	,rotationReset: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("NORTH");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("NORTH");
		} else {
			this.rotation = -Math.PI / 2;
		}
		return this;
	}
	,west: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("WEST");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("WEST");
		} else {
			this.rotation = 0;
		}
		return this;
	}
	,east: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("WEST");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("EAST");
		} else {
			this.rotation = Math.PI;
		}
		return this;
	}
	,south: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("SOUTH");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("SOUTH");
		} else {
			this.rotation = Math.PI / 2;
		}
		return this;
	}
	,heading: function() {
		var deg = 180 * this.rotation / Math.PI;
		return deg;
	}
	,position: function() {
		return { x : this.x, y : this.y};
	}
	,goto: function(x,y) {
		if(this.turtleHistoryOn) {
			this.historyAdd("SET_POSITION");
			this.historyParameters.push(x);
			this.historyParameters.push(y);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("SET_POSITION");
			this.turtleParameters.push(x);
			this.turtleParameters.push(y);
		} else {
			var tmp;
			switch(this.endLine) {
			case 0:case 1:case 6:case 9:case 12:case 15:case 18:
				tmp = false;
				break;
			case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
				tmp = true;
				break;
			}
			if(tmp) {
				this.contour.end(this.width);
			}
			this.x = x;
			this.y = y;
			var l = this.points.length;
			this.points[l] = [];
			this.points[l][0] = x;
			this.points[l][1] = y;
			this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
			this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
			this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = this.dim[this.dim.length - 1];
			if(x < d.minX) {
				d.minX = x;
			}
			if(x > d.maxX) {
				d.maxX = x;
			}
			if(y < d.minY) {
				d.minY = y;
			}
			if(y > d.maxY) {
				d.maxY = y;
			}
			this.contour.reset();
		}
		return this;
	}
	,setPosition: function(x,y) {
		if(this.turtleHistoryOn) {
			this.historyAdd("SET_POSITION");
			this.historyParameters.push(x);
			this.historyParameters.push(y);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("SET_POSITION");
			this.turtleParameters.push(x);
			this.turtleParameters.push(y);
		} else {
			var tmp;
			switch(this.endLine) {
			case 0:case 1:case 6:case 9:case 12:case 15:case 18:
				tmp = false;
				break;
			case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
				tmp = true;
				break;
			}
			if(tmp) {
				this.contour.end(this.width);
			}
			this.x = x;
			this.y = y;
			var l = this.points.length;
			this.points[l] = [];
			this.points[l][0] = x;
			this.points[l][1] = y;
			this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
			this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
			this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = this.dim[this.dim.length - 1];
			if(x < d.minX) {
				d.minX = x;
			}
			if(x > d.maxX) {
				d.maxX = x;
			}
			if(y < d.minY) {
				d.minY = y;
			}
			if(y > d.maxY) {
				d.maxY = y;
			}
			this.contour.reset();
		}
		return this;
	}
	,setposition: function(x,y) {
		if(this.turtleHistoryOn) {
			this.historyAdd("SET_POSITION");
			this.historyParameters.push(x);
			this.historyParameters.push(y);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("SET_POSITION");
			this.turtleParameters.push(x);
			this.turtleParameters.push(y);
		} else {
			var tmp;
			switch(this.endLine) {
			case 0:case 1:case 6:case 9:case 12:case 15:case 18:
				tmp = false;
				break;
			case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
				tmp = true;
				break;
			}
			if(tmp) {
				this.contour.end(this.width);
			}
			this.x = x;
			this.y = y;
			var l = this.points.length;
			this.points[l] = [];
			this.points[l][0] = x;
			this.points[l][1] = y;
			this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
			this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
			this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = this.dim[this.dim.length - 1];
			if(x < d.minX) {
				d.minX = x;
			}
			if(x > d.maxX) {
				d.maxX = x;
			}
			if(y < d.minY) {
				d.minY = y;
			}
			if(y > d.maxY) {
				d.maxY = y;
			}
			this.contour.reset();
		}
		return this;
	}
	,penSize: function(w) {
		if(this.turtleHistoryOn) {
			this.historyAdd("PEN_SIZE");
			this.historyParameters.push(w);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("PEN_SIZE");
			this.turtleParameters.push(w);
		} else {
			this.width = w;
		}
		return this;
	}
	,pensize: function(w) {
		if(this.turtleHistoryOn) {
			this.historyAdd("PEN_SIZE");
			this.historyParameters.push(w);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("PEN_SIZE");
			this.turtleParameters.push(w);
		} else {
			this.width = w;
		}
		return this;
	}
	,penSizeChange: function(dw) {
		if(this.turtleHistoryOn) {
			this.historyAdd("PEN_SIZE_CHANGE");
			this.historyParameters.push(dw);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("PEN_SIZE_CHANGE");
			this.turtleParameters.push(dw);
		} else {
			this.width += dw;
		}
		return this;
	}
	,penSizeFactor: function(factor) {
		if(this.turtleHistoryOn) {
			this.historyAdd("PEN_SIZE_FACTOR");
			this.historyParameters.push(factor);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("PEN_SIZE_FACTOR");
			this.turtleParameters.push(factor);
		} else {
			this.width *= factor;
		}
		return this;
	}
	,repeat: function(repeatCount_) {
		if(this.turtleHistoryOn) {
			this.historyAdd("BEGIN_REPEAT");
			this.historyParameters.push(Math.round(repeatCount_));
		}
		if(this.repeatCommands == true) {
			this.repeatCommands = false;
			if(this.turtleHistoryOn) {
				this.historyAdd("END_REPEAT");
			}
			var wasHistoryOn = this.turtleHistoryOn;
			this.turtleHistoryOn = false;
			var v = this.turtleParameters;
			var j = 0;
			var _g = 0;
			var _g1 = this.repeatCount;
			while(_g < _g1) {
				var k = _g++;
				var _g2 = 0;
				var _g3 = this.turtleCommands.length;
				while(_g2 < _g3) {
					var i = _g2++;
					var command = this.turtleCommands[i];
					switch(command) {
					case "ARC":
						var radius = v[j];
						var degrees = v[j + 1];
						if(this.turtleHistoryOn) {
							this.historyAdd("ARC");
							this.historyParameters.push(radius);
							this.historyParameters.push(degrees);
						}
						if(radius != 0) {
							if(this.repeatCommands) {
								this.turtleCommands.push("ARC");
								this.turtleParameters.push(radius);
								this.turtleParameters.push(degrees);
							} else {
								var beta = degrees * Math.PI / 180 / 24;
								var alpha = (Math.PI - beta) / 2;
								var rotate = -(Math.PI / 2 - alpha);
								var baseLength = 0.5 * radius * Math.sin(beta / 2);
								var ox = this.x;
								var oy = this.y;
								var arr = [];
								arr.push(this.x);
								arr.push(this.y);
								var _g4 = 0;
								while(_g4 < 48) {
									var i1 = _g4++;
									this.rotation += rotate;
									var wasHistoryOn1 = this.turtleHistoryOn;
									this.turtleHistoryOn = false;
									if(this.turtleHistoryOn) {
										this.historyAdd("FORWARD");
										this.historyParameters.push(baseLength);
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("FORWARD");
										this.turtleParameters.push(baseLength);
									} else {
										var nx = this.x + baseLength * Math.cos(this.rotation);
										var ny = this.y + baseLength * Math.sin(this.rotation);
										if(this.penIsDown) {
											this.lastDistance = baseLength;
											this.lineTo(nx,ny);
										} else {
											var tmp;
											switch(this.endLine) {
											case 0:case 1:case 6:case 9:case 12:case 15:case 18:
												tmp = false;
												break;
											case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
												tmp = true;
												break;
											}
											if(tmp) {
												this.contour.end(this.width);
											}
											this.x = nx;
											this.y = ny;
											var l = this.points.length;
											this.points[l] = [];
											this.points[l][0] = nx;
											this.points[l][1] = ny;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d = this.dim[this.dim.length - 1];
											if(nx < d.minX) {
												d.minX = nx;
											}
											if(nx > d.maxX) {
												d.maxX = nx;
											}
											if(ny < d.minY) {
												d.minY = ny;
											}
											if(ny > d.maxY) {
												d.maxY = ny;
											}
											this.contour.reset();
										}
									}
									this.turtleHistoryOn = wasHistoryOn1;
									if(this.fill) {
										arr.push(this.x);
										arr.push(this.y);
									}
								}
								if(this.fill) {
									var cx = (ox + arr[arr.length - 2]) / 2;
									var cy = (oy + arr[arr.length - 1]) / 2;
									var l1 = arr.length;
									var i2 = 2;
									var lx = 0.;
									var ly = 0.;
									this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
									while(i2 < l1) {
										if(i2 > 2) {
											this.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
										}
										lx = arr[i2];
										ly = arr[i2 + 1];
										i2 += 2;
									}
								}
								arr.length = 0;
							}
						}
						j += 2;
						break;
					case "ARCH_BEZIER":
						var distance = v[j];
						var distance2 = v[j + 1];
						var radius1 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("ARCH_BEZIER");
							this.historyParameters.push(distance);
							this.historyParameters.push(distance2);
							this.historyParameters.push(radius1);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("ARCH_BEZIER");
							this.turtleParameters.push(distance);
							this.turtleParameters.push(distance2);
							this.turtleParameters.push(radius1);
						} else {
							var nx1 = this.x + distance * Math.cos(this.rotation);
							var ny1 = this.y + distance * Math.sin(this.rotation);
							if(this.penIsDown) {
								var thruX = this.x + distance2 * Math.cos(this.rotation) - radius1 * Math.cos(this.rotation + Math.PI / 2);
								var thruY = this.y + distance2 * Math.sin(this.rotation) - radius1 * Math.sin(this.rotation + Math.PI / 2);
								var newx = 2 * thruX - 0.5 * (this.x + nx1);
								var newy = 2 * thruY - 0.5 * (this.y + ny1);
								this.tempArr = [];
								var p = this.tempArr;
								var ax = this.x;
								var ay = this.y;
								var x = ax - newx;
								var y = ay - newy;
								var x1 = newx - nx1;
								var y1 = newy - ny1;
								var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
								if(approxDistance == 0) {
									approxDistance = 0.000001;
								}
								var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
								var l2 = p.length;
								p[l2++] = ax;
								p[l2++] = ay;
								var t = step;
								while(t < 1.) {
									var u = 1 - t;
									p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
									var u1 = 1 - t;
									p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
									t += step;
								}
								p[l2++] = nx1;
								p[l2++] = ny1;
								var arr1 = this.tempArr;
								var withMove = false;
								if(withMove == null) {
									withMove = true;
								}
								var l3 = arr1.length;
								var i3 = 2;
								if(withMove) {
									var x_ = arr1[0];
									var y_ = arr1[1];
									var tmp1;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp1 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp1 = true;
										break;
									}
									if(tmp1) {
										this.contour.end(this.width);
									}
									this.x = x_;
									this.y = y_;
									var l4 = this.points.length;
									this.points[l4] = [];
									this.points[l4][0] = x_;
									this.points[l4][1] = y_;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d1 = this.dim[this.dim.length - 1];
									if(x_ < d1.minX) {
										d1.minX = x_;
									}
									if(x_ > d1.maxX) {
										d1.maxX = x_;
									}
									if(y_ < d1.minY) {
										d1.minY = y_;
									}
									if(y_ > d1.maxY) {
										d1.maxY = y_;
									}
									this.contour.reset();
								} else {
									this.lineTo(arr1[0],arr1[1]);
								}
								var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
								var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
								var ox1 = this.x;
								var oy1 = this.y;
								while(i3 < l3) {
									if(this.fill && this.penIsDown) {
										if(i3 > 0 && i3 < l3 - 2) {
											this.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
										}
									}
									this.lineTo(arr1[i3],arr1[i3 + 1]);
									i3 += 2;
								}
								if(this.fill && this.penIsDown) {
									var tmp2;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp2 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp2 = true;
										break;
									}
									if(tmp2) {
										this.contour.end(this.width);
									}
									this.x = ox1;
									this.y = oy1;
									var l5 = this.points.length;
									this.points[l5] = [];
									this.points[l5][0] = ox1;
									this.points[l5][1] = oy1;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d2 = this.dim[this.dim.length - 1];
									if(ox1 < d2.minX) {
										d2.minX = ox1;
									}
									if(ox1 > d2.maxX) {
										d2.maxX = ox1;
									}
									if(oy1 < d2.minY) {
										d2.minY = oy1;
									}
									if(oy1 > d2.maxY) {
										d2.maxY = oy1;
									}
									this.contour.reset();
									this.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
								}
								this.x = nx1;
								this.y = ny1;
							} else {
								var tmp3;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp3 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp3 = true;
									break;
								}
								if(tmp3) {
									this.contour.end(this.width);
								}
								this.x = nx1;
								this.y = ny1;
								var l6 = this.points.length;
								this.points[l6] = [];
								this.points[l6][0] = nx1;
								this.points[l6][1] = ny1;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d3 = this.dim[this.dim.length - 1];
								if(nx1 < d3.minX) {
									d3.minX = nx1;
								}
								if(nx1 > d3.maxX) {
									d3.maxX = nx1;
								}
								if(ny1 < d3.minY) {
									d3.minY = ny1;
								}
								if(ny1 > d3.maxY) {
									d3.maxY = ny1;
								}
								this.contour.reset();
							}
						}
						j += 3;
						break;
					case "ARC_SIDES":
						var radius2 = v[j];
						var degrees1 = v[j + 1];
						var sides = v[j + 2];
						if(sides == null) {
							sides = 24;
						}
						if(this.turtleHistoryOn) {
							if(sides == 24) {
								this.historyAdd("ARC");
								this.historyParameters.push(radius2);
								this.historyParameters.push(degrees1);
							} else {
								this.historyAdd("ARC_SIDES");
								this.historyParameters.push(radius2);
								this.historyParameters.push(degrees1);
								this.historyParameters.push(sides);
							}
						}
						if(radius2 != 0) {
							if(this.repeatCommands) {
								if(sides == 24) {
									this.turtleCommands.push("ARC");
									this.turtleParameters.push(radius2);
									this.turtleParameters.push(degrees1);
								} else {
									this.turtleCommands.push("ARC_SIDES");
									this.turtleParameters.push(radius2);
									this.turtleParameters.push(degrees1);
									this.turtleParameters.push(sides);
								}
							} else {
								var beta1 = degrees1 * Math.PI / 180 / sides;
								var alpha1 = (Math.PI - beta1) / 2;
								var rotate1 = -(Math.PI / 2 - alpha1);
								var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
								var ox2 = this.x;
								var oy2 = this.y;
								var arr2 = [];
								arr2.push(this.x);
								arr2.push(this.y);
								var _g5 = 0;
								while(_g5 < 48) {
									var i4 = _g5++;
									this.rotation += rotate1;
									var wasHistoryOn2 = this.turtleHistoryOn;
									this.turtleHistoryOn = false;
									if(this.turtleHistoryOn) {
										this.historyAdd("FORWARD");
										this.historyParameters.push(baseLength1);
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("FORWARD");
										this.turtleParameters.push(baseLength1);
									} else {
										var nx2 = this.x + baseLength1 * Math.cos(this.rotation);
										var ny2 = this.y + baseLength1 * Math.sin(this.rotation);
										if(this.penIsDown) {
											this.lastDistance = baseLength1;
											this.lineTo(nx2,ny2);
										} else {
											var tmp4;
											switch(this.endLine) {
											case 0:case 1:case 6:case 9:case 12:case 15:case 18:
												tmp4 = false;
												break;
											case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
												tmp4 = true;
												break;
											}
											if(tmp4) {
												this.contour.end(this.width);
											}
											this.x = nx2;
											this.y = ny2;
											var l7 = this.points.length;
											this.points[l7] = [];
											this.points[l7][0] = nx2;
											this.points[l7][1] = ny2;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d4 = this.dim[this.dim.length - 1];
											if(nx2 < d4.minX) {
												d4.minX = nx2;
											}
											if(nx2 > d4.maxX) {
												d4.maxX = nx2;
											}
											if(ny2 < d4.minY) {
												d4.minY = ny2;
											}
											if(ny2 > d4.maxY) {
												d4.maxY = ny2;
											}
											this.contour.reset();
										}
									}
									this.turtleHistoryOn = wasHistoryOn2;
									if(this.fill) {
										arr2.push(this.x);
										arr2.push(this.y);
									}
								}
								if(this.fill) {
									var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
									var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
									var l8 = arr2.length;
									var i5 = 2;
									var lx1 = 0.;
									var ly1 = 0.;
									this.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
									while(i5 < l8) {
										if(i5 > 2) {
											this.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
										}
										lx1 = arr2[i5];
										ly1 = arr2[i5 + 1];
										i5 += 2;
									}
								}
								arr2.length = 0;
							}
						}
						j += 3;
						break;
					case "BACKWARD":
						var distance1 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("BACKWARD");
							this.historyParameters.push(distance1);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("BACKWARD");
							this.turtleParameters.push(distance1);
						} else {
							var nx3 = this.x + distance1 * Math.cos(this.rotation + Math.PI);
							var ny3 = this.y + distance1 * Math.sin(this.rotation + Math.PI);
							if(this.penIsDown) {
								this.lineTo(nx3,ny3);
							} else {
								var tmp5;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp5 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp5 = true;
									break;
								}
								if(tmp5) {
									this.contour.end(this.width);
								}
								this.x = nx3;
								this.y = ny3;
								var l9 = this.points.length;
								this.points[l9] = [];
								this.points[l9][0] = nx3;
								this.points[l9][1] = ny3;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d5 = this.dim[this.dim.length - 1];
								if(nx3 < d5.minX) {
									d5.minX = nx3;
								}
								if(nx3 > d5.maxX) {
									d5.maxX = nx3;
								}
								if(ny3 < d5.minY) {
									d5.minY = ny3;
								}
								if(ny3 > d5.maxY) {
									d5.maxY = ny3;
								}
								this.contour.reset();
							}
						}
						++j;
						break;
					case "BEGIN_REPEAT":
						break;
					case "BLACK":
						if(this.turtleHistoryOn) {
							this.historyAdd("BLACK");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("BLACK");
						} else {
							this.pen.currentColor = -16777216;
						}
						break;
					case "BLUE":
						if(this.turtleHistoryOn) {
							this.historyAdd("BLUE");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("BLUE");
						} else {
							this.pen.currentColor = -16776961;
						}
						break;
					case "BROWN":
						if(this.turtleHistoryOn) {
							this.historyAdd("BROWN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("BROWN");
						} else {
							this.pen.currentColor = -6594501;
						}
						break;
					case "CIRCLE":
						var radius3 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("CIRCLE");
							this.historyParameters.push(radius3);
						}
						if(radius3 != 0) {
							if(this.repeatCommands) {
								this.turtleCommands.push("CIRCLE");
								this.turtleParameters.push(radius3);
							} else {
								var beta2 = 2 * Math.PI / 24;
								var alpha2 = (Math.PI - beta2) / 2;
								var rotate2 = -(Math.PI / 2 - alpha2);
								var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
								var ox3 = this.x;
								var oy3 = this.y;
								var arr3 = [];
								var _g6 = 0;
								while(_g6 < 48) {
									var i6 = _g6++;
									this.rotation += rotate2;
									var wasHistoryOn3 = this.turtleHistoryOn;
									this.turtleHistoryOn = false;
									if(this.turtleHistoryOn) {
										this.historyAdd("FORWARD");
										this.historyParameters.push(baseLength2);
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("FORWARD");
										this.turtleParameters.push(baseLength2);
									} else {
										var nx4 = this.x + baseLength2 * Math.cos(this.rotation);
										var ny4 = this.y + baseLength2 * Math.sin(this.rotation);
										if(this.penIsDown) {
											this.lastDistance = baseLength2;
											this.lineTo(nx4,ny4);
										} else {
											var tmp6;
											switch(this.endLine) {
											case 0:case 1:case 6:case 9:case 12:case 15:case 18:
												tmp6 = false;
												break;
											case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
												tmp6 = true;
												break;
											}
											if(tmp6) {
												this.contour.end(this.width);
											}
											this.x = nx4;
											this.y = ny4;
											var l10 = this.points.length;
											this.points[l10] = [];
											this.points[l10][0] = nx4;
											this.points[l10][1] = ny4;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d6 = this.dim[this.dim.length - 1];
											if(nx4 < d6.minX) {
												d6.minX = nx4;
											}
											if(nx4 > d6.maxX) {
												d6.maxX = nx4;
											}
											if(ny4 < d6.minY) {
												d6.minY = ny4;
											}
											if(ny4 > d6.maxY) {
												d6.maxY = ny4;
											}
											this.contour.reset();
										}
									}
									this.turtleHistoryOn = wasHistoryOn3;
									if(this.fill) {
										arr3.push(this.x);
										arr3.push(this.y);
									}
								}
								if(this.fill) {
									var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
									var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
									var l11 = arr3.length;
									var i7 = 2;
									var lx2 = 0.;
									var ly2 = 0.;
									while(i7 < l11) {
										if(i7 > 2) {
											this.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
										}
										lx2 = arr3[i7];
										ly2 = arr3[i7 + 1];
										i7 += 2;
									}
								}
								arr3.length = 0;
							}
						}
						++j;
						break;
					case "CIRCLE_SIDES":
						var radius4 = v[j];
						var sides1 = v[j + 1];
						if(sides1 == null) {
							sides1 = 24;
						}
						if(this.turtleHistoryOn) {
							if(sides1 == 24) {
								this.historyAdd("CIRCLE");
								this.historyParameters.push(radius4);
							} else {
								this.historyAdd("CIRCLE_SIDES");
								this.historyParameters.push(radius4);
								this.historyParameters.push(sides1);
							}
						}
						if(radius4 != 0) {
							if(this.repeatCommands) {
								if(sides1 == 24) {
									this.turtleCommands.push("CIRCLE");
									this.turtleParameters.push(radius4);
								} else {
									this.turtleCommands.push("CIRCLE_SIDES");
									this.turtleParameters.push(radius4);
									this.turtleParameters.push(sides1);
								}
							} else {
								var beta3 = 2 * Math.PI / sides1;
								var alpha3 = (Math.PI - beta3) / 2;
								var rotate3 = -(Math.PI / 2 - alpha3);
								var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
								var ox4 = this.x;
								var oy4 = this.y;
								var arr4 = [];
								var _g7 = 0;
								while(_g7 < 48) {
									var i8 = _g7++;
									this.rotation += rotate3;
									var wasHistoryOn4 = this.turtleHistoryOn;
									this.turtleHistoryOn = false;
									if(this.turtleHistoryOn) {
										this.historyAdd("FORWARD");
										this.historyParameters.push(baseLength3);
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("FORWARD");
										this.turtleParameters.push(baseLength3);
									} else {
										var nx5 = this.x + baseLength3 * Math.cos(this.rotation);
										var ny5 = this.y + baseLength3 * Math.sin(this.rotation);
										if(this.penIsDown) {
											this.lastDistance = baseLength3;
											this.lineTo(nx5,ny5);
										} else {
											var tmp7;
											switch(this.endLine) {
											case 0:case 1:case 6:case 9:case 12:case 15:case 18:
												tmp7 = false;
												break;
											case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
												tmp7 = true;
												break;
											}
											if(tmp7) {
												this.contour.end(this.width);
											}
											this.x = nx5;
											this.y = ny5;
											var l12 = this.points.length;
											this.points[l12] = [];
											this.points[l12][0] = nx5;
											this.points[l12][1] = ny5;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d7 = this.dim[this.dim.length - 1];
											if(nx5 < d7.minX) {
												d7.minX = nx5;
											}
											if(nx5 > d7.maxX) {
												d7.maxX = nx5;
											}
											if(ny5 < d7.minY) {
												d7.minY = ny5;
											}
											if(ny5 > d7.maxY) {
												d7.maxY = ny5;
											}
											this.contour.reset();
										}
									}
									this.turtleHistoryOn = wasHistoryOn4;
									if(this.fill) {
										arr4.push(this.x);
										arr4.push(this.y);
									}
								}
								if(this.fill) {
									var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
									var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
									var l13 = arr4.length;
									var i9 = 2;
									var lx3 = 0.;
									var ly3 = 0.;
									while(i9 < l13) {
										if(i9 > 2) {
											this.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
										}
										lx3 = arr4[i9];
										ly3 = arr4[i9 + 1];
										i9 += 2;
									}
								}
								arr4.length = 0;
							}
						}
						j += 2;
						break;
					case "CYAN":
						if(this.turtleHistoryOn) {
							this.historyAdd("CYAN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("CYAN");
						} else {
							this.pen.currentColor = -16711681;
						}
						break;
					case "DARKISH_BLUE":
						if(this.turtleHistoryOn) {
							this.historyAdd("DARKISH_BLUE");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("DARKISH_BLUE");
						} else {
							this.pen.currentColor = -8864837;
						}
						break;
					case "DARK_GREEN":
						if(this.turtleHistoryOn) {
							this.historyAdd("DARK_GREEN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("DARK_GREEN");
						} else {
							this.pen.currentColor = -10182080;
						}
						break;
					case "EAST":
						if(this.turtleHistoryOn) {
							this.historyAdd("WEST");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("EAST");
						} else {
							this.rotation = Math.PI;
						}
						break;
					case "END_REPEAT":
						break;
					case "FILL_OFF":
						if(this.turtleHistoryOn) {
							this.historyAdd("FILL_OFF");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FILL_OFF");
						} else {
							this.fill = false;
						}
						break;
					case "FILL_ON":
						if(this.turtleHistoryOn) {
							this.historyAdd("FILL_ON");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FILL_ON");
						} else {
							this.fill = true;
						}
						break;
					case "FORWARD":
						var distance3 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("FORWARD");
							this.historyParameters.push(distance3);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FORWARD");
							this.turtleParameters.push(distance3);
						} else {
							var nx6 = this.x + distance3 * Math.cos(this.rotation);
							var ny6 = this.y + distance3 * Math.sin(this.rotation);
							if(this.penIsDown) {
								this.lastDistance = distance3;
								this.lineTo(nx6,ny6);
							} else {
								var tmp8;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp8 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp8 = true;
									break;
								}
								if(tmp8) {
									this.contour.end(this.width);
								}
								this.x = nx6;
								this.y = ny6;
								var l14 = this.points.length;
								this.points[l14] = [];
								this.points[l14][0] = nx6;
								this.points[l14][1] = ny6;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d8 = this.dim[this.dim.length - 1];
								if(nx6 < d8.minX) {
									d8.minX = nx6;
								}
								if(nx6 > d8.maxX) {
									d8.maxX = nx6;
								}
								if(ny6 < d8.minY) {
									d8.minY = ny6;
								}
								if(ny6 > d8.maxY) {
									d8.maxY = ny6;
								}
								this.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_CHANGE":
						var deltaDistance = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("FORWARD_CHANGE");
							this.historyParameters.push(deltaDistance);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FORWARD_CHANGE");
							this.turtleParameters.push(deltaDistance);
						} else {
							var distance4 = this.lastDistance + deltaDistance;
							var nx7 = this.x + distance4 * Math.cos(this.rotation);
							var ny7 = this.y + distance4 * Math.sin(this.rotation);
							if(this.penIsDown) {
								this.lastDistance = distance4 + deltaDistance;
								this.lineTo(nx7,ny7);
							} else {
								var tmp9;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp9 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp9 = true;
									break;
								}
								if(tmp9) {
									this.contour.end(this.width);
								}
								this.x = nx7;
								this.y = ny7;
								var l15 = this.points.length;
								this.points[l15] = [];
								this.points[l15][0] = nx7;
								this.points[l15][1] = ny7;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d9 = this.dim[this.dim.length - 1];
								if(nx7 < d9.minX) {
									d9.minX = nx7;
								}
								if(nx7 > d9.maxX) {
									d9.maxX = nx7;
								}
								if(ny7 < d9.minY) {
									d9.minY = ny7;
								}
								if(ny7 > d9.maxY) {
									d9.maxY = ny7;
								}
								this.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_FACTOR":
						var factor = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("FORWARD_FACTOR");
							this.historyParameters.push(factor);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FORWARD_FACTOR");
							this.turtleParameters.push(factor);
						} else {
							var distance5 = this.lastDistance * factor;
							var nx8 = this.x + distance5 * Math.cos(this.rotation);
							var ny8 = this.y + distance5 * Math.sin(this.rotation);
							if(this.penIsDown) {
								this.lastDistance = distance5;
								this.lineTo(nx8,ny8);
							} else {
								var tmp10;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp10 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp10 = true;
									break;
								}
								if(tmp10) {
									this.contour.end(this.width);
								}
								this.x = nx8;
								this.y = ny8;
								var l16 = this.points.length;
								this.points[l16] = [];
								this.points[l16][0] = nx8;
								this.points[l16][1] = ny8;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d10 = this.dim[this.dim.length - 1];
								if(nx8 < d10.minX) {
									d10.minX = nx8;
								}
								if(nx8 > d10.maxX) {
									d10.maxX = nx8;
								}
								if(ny8 < d10.minY) {
									d10.minY = ny8;
								}
								if(ny8 > d10.maxY) {
									d10.maxY = ny8;
								}
								this.contour.reset();
							}
						}
						++j;
						break;
					case "GREEN":
						if(this.turtleHistoryOn) {
							this.historyAdd("GREEN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("GREEN");
						} else {
							this.pen.currentColor = -16711936;
						}
						break;
					case "GREY":
						if(this.turtleHistoryOn) {
							this.historyAdd("GREY");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("GREY");
						} else {
							this.pen.currentColor = -4737097;
						}
						break;
					case "LEFT":
						var degrees2 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("LEFT");
							this.historyParameters.push(degrees2);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("LEFT");
							this.turtleParameters.push(degrees2);
						} else {
							this.rotation -= degrees2 * Math.PI / 180;
						}
						++j;
						break;
					case "LIGHT_BROWN":
						if(this.turtleHistoryOn) {
							this.historyAdd("LIGHT_BROWN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("LIGHT_BROWN");
						} else {
							this.pen.currentColor = -3831790;
						}
						break;
					case "LINE_STYLE":
						var thickness = v[j];
						var color = v[j + 1];
						if(this.turtleHistoryOn) {
							this.historyAdd("LINE_STYLE");
							this.historyParameters.push(thickness);
							this.historyParameters.push(color);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("LINE_STYLE");
							this.historyParameters.push(thickness);
							this.historyParameters.push(color);
						} else {
							this.width = thickness;
							this.pen.currentColor = color | 0;
						}
						j += 2;
						break;
					case "MAGENTA":
						if(this.turtleHistoryOn) {
							this.historyAdd("MAGENTA");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("MAGENTA");
						} else {
							this.pen.currentColor = -65281;
						}
						break;
					case "MOVE_PEN":
						var distance6 = v[j];
						if(this.repeatCommands) {
							this.turtleCommands.push("MOVE_PEN");
							this.turtleParameters.push(distance6);
						} else if(this.penIsDown) {
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_UP");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_UP");
							} else {
								this.penIsDown = false;
							}
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD");
								this.historyParameters.push(distance6);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD");
								this.turtleParameters.push(distance6);
							} else {
								var nx9 = this.x + distance6 * Math.cos(this.rotation);
								var ny9 = this.y + distance6 * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = distance6;
									this.lineTo(nx9,ny9);
								} else {
									var tmp11;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp11 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp11 = true;
										break;
									}
									if(tmp11) {
										this.contour.end(this.width);
									}
									this.x = nx9;
									this.y = ny9;
									var l17 = this.points.length;
									this.points[l17] = [];
									this.points[l17][0] = nx9;
									this.points[l17][1] = ny9;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d11 = this.dim[this.dim.length - 1];
									if(nx9 < d11.minX) {
										d11.minX = nx9;
									}
									if(nx9 > d11.maxX) {
										d11.maxX = nx9;
									}
									if(ny9 < d11.minY) {
										d11.minY = ny9;
									}
									if(ny9 > d11.maxY) {
										d11.maxY = ny9;
									}
									this.contour.reset();
								}
							}
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_DOWN");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_DOWN");
							} else {
								this.penIsDown = true;
							}
						} else {
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD");
								this.historyParameters.push(distance6);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD");
								this.turtleParameters.push(distance6);
							} else {
								var nx10 = this.x + distance6 * Math.cos(this.rotation);
								var ny10 = this.y + distance6 * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = distance6;
									this.lineTo(nx10,ny10);
								} else {
									var tmp12;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp12 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp12 = true;
										break;
									}
									if(tmp12) {
										this.contour.end(this.width);
									}
									this.x = nx10;
									this.y = ny10;
									var l18 = this.points.length;
									this.points[l18] = [];
									this.points[l18][0] = nx10;
									this.points[l18][1] = ny10;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d12 = this.dim[this.dim.length - 1];
									if(nx10 < d12.minX) {
										d12.minX = nx10;
									}
									if(nx10 > d12.maxX) {
										d12.maxX = nx10;
									}
									if(ny10 < d12.minY) {
										d12.minY = ny10;
									}
									if(ny10 > d12.maxY) {
										d12.maxY = ny10;
									}
									this.contour.reset();
								}
							}
						}
						++j;
						break;
					case "NORTH":
						if(this.turtleHistoryOn) {
							this.historyAdd("NORTH");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("NORTH");
						} else {
							this.rotation = -Math.PI / 2;
						}
						break;
					case "ORANGE":
						if(this.turtleHistoryOn) {
							this.historyAdd("ORANGE");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("ORANGE");
						} else {
							this.pen.currentColor = -23808;
						}
						break;
					case "PEN_COLOR":
						var r = v[j];
						var g = v[j + 1];
						var b = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_COLOR");
							this.historyParameters.push(r);
							this.historyParameters.push(g);
							this.historyParameters.push(b);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_COLOR");
							this.turtleParameters.push(r);
							this.turtleParameters.push(g);
							this.turtleParameters.push(b);
						} else {
							this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_B":
						var r1 = v[j];
						var g1 = v[j + 1];
						var b1 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_COLOR_B");
							this.historyParameters.push(r1);
							this.historyParameters.push(g1);
							this.historyParameters.push(b1);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_COLOR_B");
							this.turtleParameters.push(r1);
							this.turtleParameters.push(g1);
							this.turtleParameters.push(b1);
						} else {
							this.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_C":
						var r2 = v[j];
						var g2 = v[j + 1];
						var b2 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_COLOR_C");
							this.historyParameters.push(r2);
							this.historyParameters.push(g2);
							this.historyParameters.push(b2);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_COLOR_C");
							this.turtleParameters.push(r2);
							this.turtleParameters.push(g2);
							this.turtleParameters.push(b2);
						} else {
							this.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE":
						var r3 = v[j];
						var g3 = v[j + 1];
						var b3 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_COLOR_CHANGE");
							this.historyParameters.push(r3);
							this.historyParameters.push(g3);
							this.historyParameters.push(b3);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_COLOR_CHANGE");
							this.turtleParameters.push(r3);
							this.turtleParameters.push(g3);
							this.turtleParameters.push(b3);
						} else {
							var c = this.pen.currentColor;
							var r0 = (c >> 16 & 255) / 255;
							var g0 = (c >> 8 & 255) / 255;
							var b0 = (c & 255) / 255;
							this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_B":
						var r4 = v[j];
						var g4 = v[j + 1];
						var b4 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_COLOR_CHANGE_B");
							this.historyParameters.push(r4);
							this.historyParameters.push(g4);
							this.historyParameters.push(b4);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_COLOR_CHANGE_B");
							this.turtleParameters.push(r4);
							this.turtleParameters.push(g4);
							this.turtleParameters.push(b4);
						} else {
							var c1 = this.pen.colorB;
							var r01 = (c1 >> 16 & 255) / 255;
							var g01 = (c1 >> 8 & 255) / 255;
							var b01 = (c1 & 255) / 255;
							this.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_C":
						var r5 = v[j];
						var g5 = v[j + 1];
						var b5 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_COLOR_CHANGE_C");
							this.historyParameters.push(r5);
							this.historyParameters.push(g5);
							this.historyParameters.push(b5);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_COLOR_CHANGE_C");
							this.turtleParameters.push(r5);
							this.turtleParameters.push(g5);
							this.turtleParameters.push(b5);
						} else {
							var c2 = this.pen.colorC;
							var r02 = (c2 >> 16 & 255) / 255;
							var g02 = (c2 >> 8 & 255) / 255;
							var b02 = (c2 & 255) / 255;
							this.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
						}
						j += 3;
						break;
					case "PEN_DOWN":
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_DOWN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_DOWN");
						} else {
							this.penIsDown = true;
						}
						break;
					case "PEN_SIZE":
						var w = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_SIZE");
							this.historyParameters.push(w);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_SIZE");
							this.turtleParameters.push(w);
						} else {
							this.width = w;
						}
						++j;
						break;
					case "PEN_SIZE_CHANGE":
						var dw = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_SIZE_CHANGE");
							this.historyParameters.push(dw);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_SIZE_CHANGE");
							this.turtleParameters.push(dw);
						} else {
							this.width += dw;
						}
						++j;
						break;
					case "PEN_SIZE_FACTOR":
						var factor1 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_SIZE_FACTOR");
							this.historyParameters.push(factor1);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_SIZE_FACTOR");
							this.turtleParameters.push(factor1);
						} else {
							this.width *= factor1;
						}
						++j;
						break;
					case "PEN_UP":
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_UP");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_UP");
						} else {
							this.penIsDown = false;
						}
						break;
					case "PLUM":
						if(this.turtleHistoryOn) {
							this.historyAdd("PLUM");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PLUM");
						} else {
							this.pen.currentColor = -7310896;
						}
						break;
					case "RED":
						if(this.turtleHistoryOn) {
							this.historyAdd("RED");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("RED");
						} else {
							this.pen.currentColor = -65536;
						}
						break;
					case "RIGHT":
						var degrees3 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("RIGHT");
							this.historyParameters.push(degrees3);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("RIGHT");
							this.turtleParameters.push(degrees3);
						} else {
							this.rotation += degrees3 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_ANGLE":
						var degrees4 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("SET_ANGLE");
							this.historyParameters.push(degrees4);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("SET_ANGLE");
							this.turtleParameters.push(degrees4);
						} else {
							this.rotation = -Math.PI / 2;
							this.rotation += degrees4 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_POSITION":
						var x2 = v[j];
						var y2 = v[j + 1];
						if(this.turtleHistoryOn) {
							this.historyAdd("SET_POSITION");
							this.historyParameters.push(x2);
							this.historyParameters.push(y2);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("SET_POSITION");
							this.turtleParameters.push(x2);
							this.turtleParameters.push(y2);
						} else {
							var tmp13;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp13 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp13 = true;
								break;
							}
							if(tmp13) {
								this.contour.end(this.width);
							}
							this.x = x2;
							this.y = y2;
							var l19 = this.points.length;
							this.points[l19] = [];
							this.points[l19][0] = x2;
							this.points[l19][1] = y2;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d13 = this.dim[this.dim.length - 1];
							if(x2 < d13.minX) {
								d13.minX = x2;
							}
							if(x2 > d13.maxX) {
								d13.maxX = x2;
							}
							if(y2 < d13.minY) {
								d13.minY = y2;
							}
							if(y2 > d13.maxY) {
								d13.maxY = y2;
							}
							this.contour.reset();
						}
						j += 2;
						break;
					case "SOUTH":
						if(this.turtleHistoryOn) {
							this.historyAdd("SOUTH");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("SOUTH");
						} else {
							this.rotation = Math.PI / 2;
						}
						break;
					case "TAN":
						if(this.turtleHistoryOn) {
							this.historyAdd("TAN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("TAN");
						} else {
							this.pen.currentColor = -27273;
						}
						break;
					case "TRIANGLE_ARCH":
						var distance7 = v[j];
						var distance21 = v[j + 1];
						var radius5 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("TRIANGLE_ARCH");
							this.historyParameters.push(distance7);
							this.historyParameters.push(distance21);
							this.historyParameters.push(radius5);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("TRIANGLE_ARCH");
							this.turtleParameters.push(distance7);
							this.turtleParameters.push(distance21);
							this.turtleParameters.push(radius5);
						} else {
							var nx11 = this.x + distance7 * Math.cos(this.rotation);
							var ny11 = this.y + distance7 * Math.sin(this.rotation);
							if(this.penIsDown) {
								var thruX1 = this.x + distance21 * Math.cos(this.rotation) - radius5 * Math.cos(this.rotation + Math.PI / 2);
								var thruY1 = this.y + distance21 * Math.sin(this.rotation) - radius5 * Math.sin(this.rotation + Math.PI / 2);
								if(this.fill) {
									this.pen.triangle2DFill(this.x,this.y,thruX1,thruY1,nx11,ny11);
								}
								this.lineTo(thruX1,thruY1);
								this.lineTo(nx11,ny11);
								if(this.fill) {
									this.lineTo(this.x,this.y);
								}
								var tmp14;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp14 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp14 = true;
									break;
								}
								if(tmp14) {
									this.contour.end(this.width);
								}
								this.x = nx11;
								this.y = ny11;
								var l20 = this.points.length;
								this.points[l20] = [];
								this.points[l20][0] = nx11;
								this.points[l20][1] = ny11;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d14 = this.dim[this.dim.length - 1];
								if(nx11 < d14.minX) {
									d14.minX = nx11;
								}
								if(nx11 > d14.maxX) {
									d14.maxX = nx11;
								}
								if(ny11 < d14.minY) {
									d14.minY = ny11;
								}
								if(ny11 > d14.maxY) {
									d14.maxY = ny11;
								}
								this.contour.reset();
							} else {
								var tmp15;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp15 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp15 = true;
									break;
								}
								if(tmp15) {
									this.contour.end(this.width);
								}
								this.x = nx11;
								this.y = ny11;
								var l21 = this.points.length;
								this.points[l21] = [];
								this.points[l21][0] = nx11;
								this.points[l21][1] = ny11;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d15 = this.dim[this.dim.length - 1];
								if(nx11 < d15.minX) {
									d15.minX = nx11;
								}
								if(nx11 > d15.maxX) {
									d15.maxX = nx11;
								}
								if(ny11 < d15.minY) {
									d15.minY = ny11;
								}
								if(ny11 > d15.maxY) {
									d15.maxY = ny11;
								}
								this.contour.reset();
							}
						}
						j += 3;
						break;
					case "WEST":
						if(this.turtleHistoryOn) {
							this.historyAdd("WEST");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("WEST");
						} else {
							this.rotation = 0;
						}
						break;
					case "WHITE":
						if(this.turtleHistoryOn) {
							this.historyAdd("WHITE");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("WHITE");
						} else {
							this.pen.currentColor = -1;
						}
						break;
					case "YELLOW":
						if(this.turtleHistoryOn) {
							this.historyAdd("YELLOW");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("YELLOW");
						} else {
							this.pen.currentColor = -256;
						}
						break;
					}
				}
				j = 0;
			}
			this.turtleHistoryOn = wasHistoryOn;
			this.turtleCommands.length = 0;
			this.turtleParameters.length = 0;
		}
		if(repeatCount_ > 0) {
			this.repeatCount = Math.round(repeatCount_);
			this.repeatCommands = true;
			this.turtleCommands.length = 0;
			this.turtleParameters.length = 0;
		}
		return this;
	}
	,loop: function(repeatCount_) {
		if(this.turtleHistoryOn) {
			this.historyAdd("BEGIN_REPEAT");
			this.historyParameters.push(Math.round(repeatCount_));
		}
		if(this.repeatCommands == true) {
			this.repeatCommands = false;
			if(this.turtleHistoryOn) {
				this.historyAdd("END_REPEAT");
			}
			var wasHistoryOn = this.turtleHistoryOn;
			this.turtleHistoryOn = false;
			var v = this.turtleParameters;
			var j = 0;
			var _g = 0;
			var _g1 = this.repeatCount;
			while(_g < _g1) {
				var k = _g++;
				var _g2 = 0;
				var _g3 = this.turtleCommands.length;
				while(_g2 < _g3) {
					var i = _g2++;
					var command = this.turtleCommands[i];
					switch(command) {
					case "ARC":
						var radius = v[j];
						var degrees = v[j + 1];
						if(this.turtleHistoryOn) {
							this.historyAdd("ARC");
							this.historyParameters.push(radius);
							this.historyParameters.push(degrees);
						}
						if(radius != 0) {
							if(this.repeatCommands) {
								this.turtleCommands.push("ARC");
								this.turtleParameters.push(radius);
								this.turtleParameters.push(degrees);
							} else {
								var beta = degrees * Math.PI / 180 / 24;
								var alpha = (Math.PI - beta) / 2;
								var rotate = -(Math.PI / 2 - alpha);
								var baseLength = 0.5 * radius * Math.sin(beta / 2);
								var ox = this.x;
								var oy = this.y;
								var arr = [];
								arr.push(this.x);
								arr.push(this.y);
								var _g4 = 0;
								while(_g4 < 48) {
									var i1 = _g4++;
									this.rotation += rotate;
									var wasHistoryOn1 = this.turtleHistoryOn;
									this.turtleHistoryOn = false;
									if(this.turtleHistoryOn) {
										this.historyAdd("FORWARD");
										this.historyParameters.push(baseLength);
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("FORWARD");
										this.turtleParameters.push(baseLength);
									} else {
										var nx = this.x + baseLength * Math.cos(this.rotation);
										var ny = this.y + baseLength * Math.sin(this.rotation);
										if(this.penIsDown) {
											this.lastDistance = baseLength;
											this.lineTo(nx,ny);
										} else {
											var tmp;
											switch(this.endLine) {
											case 0:case 1:case 6:case 9:case 12:case 15:case 18:
												tmp = false;
												break;
											case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
												tmp = true;
												break;
											}
											if(tmp) {
												this.contour.end(this.width);
											}
											this.x = nx;
											this.y = ny;
											var l = this.points.length;
											this.points[l] = [];
											this.points[l][0] = nx;
											this.points[l][1] = ny;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d = this.dim[this.dim.length - 1];
											if(nx < d.minX) {
												d.minX = nx;
											}
											if(nx > d.maxX) {
												d.maxX = nx;
											}
											if(ny < d.minY) {
												d.minY = ny;
											}
											if(ny > d.maxY) {
												d.maxY = ny;
											}
											this.contour.reset();
										}
									}
									this.turtleHistoryOn = wasHistoryOn1;
									if(this.fill) {
										arr.push(this.x);
										arr.push(this.y);
									}
								}
								if(this.fill) {
									var cx = (ox + arr[arr.length - 2]) / 2;
									var cy = (oy + arr[arr.length - 1]) / 2;
									var l1 = arr.length;
									var i2 = 2;
									var lx = 0.;
									var ly = 0.;
									this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
									while(i2 < l1) {
										if(i2 > 2) {
											this.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
										}
										lx = arr[i2];
										ly = arr[i2 + 1];
										i2 += 2;
									}
								}
								arr.length = 0;
							}
						}
						j += 2;
						break;
					case "ARCH_BEZIER":
						var distance = v[j];
						var distance2 = v[j + 1];
						var radius1 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("ARCH_BEZIER");
							this.historyParameters.push(distance);
							this.historyParameters.push(distance2);
							this.historyParameters.push(radius1);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("ARCH_BEZIER");
							this.turtleParameters.push(distance);
							this.turtleParameters.push(distance2);
							this.turtleParameters.push(radius1);
						} else {
							var nx1 = this.x + distance * Math.cos(this.rotation);
							var ny1 = this.y + distance * Math.sin(this.rotation);
							if(this.penIsDown) {
								var thruX = this.x + distance2 * Math.cos(this.rotation) - radius1 * Math.cos(this.rotation + Math.PI / 2);
								var thruY = this.y + distance2 * Math.sin(this.rotation) - radius1 * Math.sin(this.rotation + Math.PI / 2);
								var newx = 2 * thruX - 0.5 * (this.x + nx1);
								var newy = 2 * thruY - 0.5 * (this.y + ny1);
								this.tempArr = [];
								var p = this.tempArr;
								var ax = this.x;
								var ay = this.y;
								var x = ax - newx;
								var y = ay - newy;
								var x1 = newx - nx1;
								var y1 = newy - ny1;
								var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
								if(approxDistance == 0) {
									approxDistance = 0.000001;
								}
								var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
								var l2 = p.length;
								p[l2++] = ax;
								p[l2++] = ay;
								var t = step;
								while(t < 1.) {
									var u = 1 - t;
									p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
									var u1 = 1 - t;
									p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
									t += step;
								}
								p[l2++] = nx1;
								p[l2++] = ny1;
								var arr1 = this.tempArr;
								var withMove = false;
								if(withMove == null) {
									withMove = true;
								}
								var l3 = arr1.length;
								var i3 = 2;
								if(withMove) {
									var x_ = arr1[0];
									var y_ = arr1[1];
									var tmp1;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp1 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp1 = true;
										break;
									}
									if(tmp1) {
										this.contour.end(this.width);
									}
									this.x = x_;
									this.y = y_;
									var l4 = this.points.length;
									this.points[l4] = [];
									this.points[l4][0] = x_;
									this.points[l4][1] = y_;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d1 = this.dim[this.dim.length - 1];
									if(x_ < d1.minX) {
										d1.minX = x_;
									}
									if(x_ > d1.maxX) {
										d1.maxX = x_;
									}
									if(y_ < d1.minY) {
										d1.minY = y_;
									}
									if(y_ > d1.maxY) {
										d1.maxY = y_;
									}
									this.contour.reset();
								} else {
									this.lineTo(arr1[0],arr1[1]);
								}
								var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
								var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
								var ox1 = this.x;
								var oy1 = this.y;
								while(i3 < l3) {
									if(this.fill && this.penIsDown) {
										if(i3 > 0 && i3 < l3 - 2) {
											this.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
										}
									}
									this.lineTo(arr1[i3],arr1[i3 + 1]);
									i3 += 2;
								}
								if(this.fill && this.penIsDown) {
									var tmp2;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp2 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp2 = true;
										break;
									}
									if(tmp2) {
										this.contour.end(this.width);
									}
									this.x = ox1;
									this.y = oy1;
									var l5 = this.points.length;
									this.points[l5] = [];
									this.points[l5][0] = ox1;
									this.points[l5][1] = oy1;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d2 = this.dim[this.dim.length - 1];
									if(ox1 < d2.minX) {
										d2.minX = ox1;
									}
									if(ox1 > d2.maxX) {
										d2.maxX = ox1;
									}
									if(oy1 < d2.minY) {
										d2.minY = oy1;
									}
									if(oy1 > d2.maxY) {
										d2.maxY = oy1;
									}
									this.contour.reset();
									this.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
								}
								this.x = nx1;
								this.y = ny1;
							} else {
								var tmp3;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp3 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp3 = true;
									break;
								}
								if(tmp3) {
									this.contour.end(this.width);
								}
								this.x = nx1;
								this.y = ny1;
								var l6 = this.points.length;
								this.points[l6] = [];
								this.points[l6][0] = nx1;
								this.points[l6][1] = ny1;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d3 = this.dim[this.dim.length - 1];
								if(nx1 < d3.minX) {
									d3.minX = nx1;
								}
								if(nx1 > d3.maxX) {
									d3.maxX = nx1;
								}
								if(ny1 < d3.minY) {
									d3.minY = ny1;
								}
								if(ny1 > d3.maxY) {
									d3.maxY = ny1;
								}
								this.contour.reset();
							}
						}
						j += 3;
						break;
					case "ARC_SIDES":
						var radius2 = v[j];
						var degrees1 = v[j + 1];
						var sides = v[j + 2];
						if(sides == null) {
							sides = 24;
						}
						if(this.turtleHistoryOn) {
							if(sides == 24) {
								this.historyAdd("ARC");
								this.historyParameters.push(radius2);
								this.historyParameters.push(degrees1);
							} else {
								this.historyAdd("ARC_SIDES");
								this.historyParameters.push(radius2);
								this.historyParameters.push(degrees1);
								this.historyParameters.push(sides);
							}
						}
						if(radius2 != 0) {
							if(this.repeatCommands) {
								if(sides == 24) {
									this.turtleCommands.push("ARC");
									this.turtleParameters.push(radius2);
									this.turtleParameters.push(degrees1);
								} else {
									this.turtleCommands.push("ARC_SIDES");
									this.turtleParameters.push(radius2);
									this.turtleParameters.push(degrees1);
									this.turtleParameters.push(sides);
								}
							} else {
								var beta1 = degrees1 * Math.PI / 180 / sides;
								var alpha1 = (Math.PI - beta1) / 2;
								var rotate1 = -(Math.PI / 2 - alpha1);
								var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
								var ox2 = this.x;
								var oy2 = this.y;
								var arr2 = [];
								arr2.push(this.x);
								arr2.push(this.y);
								var _g5 = 0;
								while(_g5 < 48) {
									var i4 = _g5++;
									this.rotation += rotate1;
									var wasHistoryOn2 = this.turtleHistoryOn;
									this.turtleHistoryOn = false;
									if(this.turtleHistoryOn) {
										this.historyAdd("FORWARD");
										this.historyParameters.push(baseLength1);
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("FORWARD");
										this.turtleParameters.push(baseLength1);
									} else {
										var nx2 = this.x + baseLength1 * Math.cos(this.rotation);
										var ny2 = this.y + baseLength1 * Math.sin(this.rotation);
										if(this.penIsDown) {
											this.lastDistance = baseLength1;
											this.lineTo(nx2,ny2);
										} else {
											var tmp4;
											switch(this.endLine) {
											case 0:case 1:case 6:case 9:case 12:case 15:case 18:
												tmp4 = false;
												break;
											case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
												tmp4 = true;
												break;
											}
											if(tmp4) {
												this.contour.end(this.width);
											}
											this.x = nx2;
											this.y = ny2;
											var l7 = this.points.length;
											this.points[l7] = [];
											this.points[l7][0] = nx2;
											this.points[l7][1] = ny2;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d4 = this.dim[this.dim.length - 1];
											if(nx2 < d4.minX) {
												d4.minX = nx2;
											}
											if(nx2 > d4.maxX) {
												d4.maxX = nx2;
											}
											if(ny2 < d4.minY) {
												d4.minY = ny2;
											}
											if(ny2 > d4.maxY) {
												d4.maxY = ny2;
											}
											this.contour.reset();
										}
									}
									this.turtleHistoryOn = wasHistoryOn2;
									if(this.fill) {
										arr2.push(this.x);
										arr2.push(this.y);
									}
								}
								if(this.fill) {
									var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
									var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
									var l8 = arr2.length;
									var i5 = 2;
									var lx1 = 0.;
									var ly1 = 0.;
									this.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
									while(i5 < l8) {
										if(i5 > 2) {
											this.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
										}
										lx1 = arr2[i5];
										ly1 = arr2[i5 + 1];
										i5 += 2;
									}
								}
								arr2.length = 0;
							}
						}
						j += 3;
						break;
					case "BACKWARD":
						var distance1 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("BACKWARD");
							this.historyParameters.push(distance1);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("BACKWARD");
							this.turtleParameters.push(distance1);
						} else {
							var nx3 = this.x + distance1 * Math.cos(this.rotation + Math.PI);
							var ny3 = this.y + distance1 * Math.sin(this.rotation + Math.PI);
							if(this.penIsDown) {
								this.lineTo(nx3,ny3);
							} else {
								var tmp5;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp5 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp5 = true;
									break;
								}
								if(tmp5) {
									this.contour.end(this.width);
								}
								this.x = nx3;
								this.y = ny3;
								var l9 = this.points.length;
								this.points[l9] = [];
								this.points[l9][0] = nx3;
								this.points[l9][1] = ny3;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d5 = this.dim[this.dim.length - 1];
								if(nx3 < d5.minX) {
									d5.minX = nx3;
								}
								if(nx3 > d5.maxX) {
									d5.maxX = nx3;
								}
								if(ny3 < d5.minY) {
									d5.minY = ny3;
								}
								if(ny3 > d5.maxY) {
									d5.maxY = ny3;
								}
								this.contour.reset();
							}
						}
						++j;
						break;
					case "BEGIN_REPEAT":
						break;
					case "BLACK":
						if(this.turtleHistoryOn) {
							this.historyAdd("BLACK");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("BLACK");
						} else {
							this.pen.currentColor = -16777216;
						}
						break;
					case "BLUE":
						if(this.turtleHistoryOn) {
							this.historyAdd("BLUE");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("BLUE");
						} else {
							this.pen.currentColor = -16776961;
						}
						break;
					case "BROWN":
						if(this.turtleHistoryOn) {
							this.historyAdd("BROWN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("BROWN");
						} else {
							this.pen.currentColor = -6594501;
						}
						break;
					case "CIRCLE":
						var radius3 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("CIRCLE");
							this.historyParameters.push(radius3);
						}
						if(radius3 != 0) {
							if(this.repeatCommands) {
								this.turtleCommands.push("CIRCLE");
								this.turtleParameters.push(radius3);
							} else {
								var beta2 = 2 * Math.PI / 24;
								var alpha2 = (Math.PI - beta2) / 2;
								var rotate2 = -(Math.PI / 2 - alpha2);
								var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
								var ox3 = this.x;
								var oy3 = this.y;
								var arr3 = [];
								var _g6 = 0;
								while(_g6 < 48) {
									var i6 = _g6++;
									this.rotation += rotate2;
									var wasHistoryOn3 = this.turtleHistoryOn;
									this.turtleHistoryOn = false;
									if(this.turtleHistoryOn) {
										this.historyAdd("FORWARD");
										this.historyParameters.push(baseLength2);
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("FORWARD");
										this.turtleParameters.push(baseLength2);
									} else {
										var nx4 = this.x + baseLength2 * Math.cos(this.rotation);
										var ny4 = this.y + baseLength2 * Math.sin(this.rotation);
										if(this.penIsDown) {
											this.lastDistance = baseLength2;
											this.lineTo(nx4,ny4);
										} else {
											var tmp6;
											switch(this.endLine) {
											case 0:case 1:case 6:case 9:case 12:case 15:case 18:
												tmp6 = false;
												break;
											case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
												tmp6 = true;
												break;
											}
											if(tmp6) {
												this.contour.end(this.width);
											}
											this.x = nx4;
											this.y = ny4;
											var l10 = this.points.length;
											this.points[l10] = [];
											this.points[l10][0] = nx4;
											this.points[l10][1] = ny4;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d6 = this.dim[this.dim.length - 1];
											if(nx4 < d6.minX) {
												d6.minX = nx4;
											}
											if(nx4 > d6.maxX) {
												d6.maxX = nx4;
											}
											if(ny4 < d6.minY) {
												d6.minY = ny4;
											}
											if(ny4 > d6.maxY) {
												d6.maxY = ny4;
											}
											this.contour.reset();
										}
									}
									this.turtleHistoryOn = wasHistoryOn3;
									if(this.fill) {
										arr3.push(this.x);
										arr3.push(this.y);
									}
								}
								if(this.fill) {
									var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
									var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
									var l11 = arr3.length;
									var i7 = 2;
									var lx2 = 0.;
									var ly2 = 0.;
									while(i7 < l11) {
										if(i7 > 2) {
											this.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
										}
										lx2 = arr3[i7];
										ly2 = arr3[i7 + 1];
										i7 += 2;
									}
								}
								arr3.length = 0;
							}
						}
						++j;
						break;
					case "CIRCLE_SIDES":
						var radius4 = v[j];
						var sides1 = v[j + 1];
						if(sides1 == null) {
							sides1 = 24;
						}
						if(this.turtleHistoryOn) {
							if(sides1 == 24) {
								this.historyAdd("CIRCLE");
								this.historyParameters.push(radius4);
							} else {
								this.historyAdd("CIRCLE_SIDES");
								this.historyParameters.push(radius4);
								this.historyParameters.push(sides1);
							}
						}
						if(radius4 != 0) {
							if(this.repeatCommands) {
								if(sides1 == 24) {
									this.turtleCommands.push("CIRCLE");
									this.turtleParameters.push(radius4);
								} else {
									this.turtleCommands.push("CIRCLE_SIDES");
									this.turtleParameters.push(radius4);
									this.turtleParameters.push(sides1);
								}
							} else {
								var beta3 = 2 * Math.PI / sides1;
								var alpha3 = (Math.PI - beta3) / 2;
								var rotate3 = -(Math.PI / 2 - alpha3);
								var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
								var ox4 = this.x;
								var oy4 = this.y;
								var arr4 = [];
								var _g7 = 0;
								while(_g7 < 48) {
									var i8 = _g7++;
									this.rotation += rotate3;
									var wasHistoryOn4 = this.turtleHistoryOn;
									this.turtleHistoryOn = false;
									if(this.turtleHistoryOn) {
										this.historyAdd("FORWARD");
										this.historyParameters.push(baseLength3);
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("FORWARD");
										this.turtleParameters.push(baseLength3);
									} else {
										var nx5 = this.x + baseLength3 * Math.cos(this.rotation);
										var ny5 = this.y + baseLength3 * Math.sin(this.rotation);
										if(this.penIsDown) {
											this.lastDistance = baseLength3;
											this.lineTo(nx5,ny5);
										} else {
											var tmp7;
											switch(this.endLine) {
											case 0:case 1:case 6:case 9:case 12:case 15:case 18:
												tmp7 = false;
												break;
											case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
												tmp7 = true;
												break;
											}
											if(tmp7) {
												this.contour.end(this.width);
											}
											this.x = nx5;
											this.y = ny5;
											var l12 = this.points.length;
											this.points[l12] = [];
											this.points[l12][0] = nx5;
											this.points[l12][1] = ny5;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d7 = this.dim[this.dim.length - 1];
											if(nx5 < d7.minX) {
												d7.minX = nx5;
											}
											if(nx5 > d7.maxX) {
												d7.maxX = nx5;
											}
											if(ny5 < d7.minY) {
												d7.minY = ny5;
											}
											if(ny5 > d7.maxY) {
												d7.maxY = ny5;
											}
											this.contour.reset();
										}
									}
									this.turtleHistoryOn = wasHistoryOn4;
									if(this.fill) {
										arr4.push(this.x);
										arr4.push(this.y);
									}
								}
								if(this.fill) {
									var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
									var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
									var l13 = arr4.length;
									var i9 = 2;
									var lx3 = 0.;
									var ly3 = 0.;
									while(i9 < l13) {
										if(i9 > 2) {
											this.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
										}
										lx3 = arr4[i9];
										ly3 = arr4[i9 + 1];
										i9 += 2;
									}
								}
								arr4.length = 0;
							}
						}
						j += 2;
						break;
					case "CYAN":
						if(this.turtleHistoryOn) {
							this.historyAdd("CYAN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("CYAN");
						} else {
							this.pen.currentColor = -16711681;
						}
						break;
					case "DARKISH_BLUE":
						if(this.turtleHistoryOn) {
							this.historyAdd("DARKISH_BLUE");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("DARKISH_BLUE");
						} else {
							this.pen.currentColor = -8864837;
						}
						break;
					case "DARK_GREEN":
						if(this.turtleHistoryOn) {
							this.historyAdd("DARK_GREEN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("DARK_GREEN");
						} else {
							this.pen.currentColor = -10182080;
						}
						break;
					case "EAST":
						if(this.turtleHistoryOn) {
							this.historyAdd("WEST");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("EAST");
						} else {
							this.rotation = Math.PI;
						}
						break;
					case "END_REPEAT":
						break;
					case "FILL_OFF":
						if(this.turtleHistoryOn) {
							this.historyAdd("FILL_OFF");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FILL_OFF");
						} else {
							this.fill = false;
						}
						break;
					case "FILL_ON":
						if(this.turtleHistoryOn) {
							this.historyAdd("FILL_ON");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FILL_ON");
						} else {
							this.fill = true;
						}
						break;
					case "FORWARD":
						var distance3 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("FORWARD");
							this.historyParameters.push(distance3);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FORWARD");
							this.turtleParameters.push(distance3);
						} else {
							var nx6 = this.x + distance3 * Math.cos(this.rotation);
							var ny6 = this.y + distance3 * Math.sin(this.rotation);
							if(this.penIsDown) {
								this.lastDistance = distance3;
								this.lineTo(nx6,ny6);
							} else {
								var tmp8;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp8 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp8 = true;
									break;
								}
								if(tmp8) {
									this.contour.end(this.width);
								}
								this.x = nx6;
								this.y = ny6;
								var l14 = this.points.length;
								this.points[l14] = [];
								this.points[l14][0] = nx6;
								this.points[l14][1] = ny6;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d8 = this.dim[this.dim.length - 1];
								if(nx6 < d8.minX) {
									d8.minX = nx6;
								}
								if(nx6 > d8.maxX) {
									d8.maxX = nx6;
								}
								if(ny6 < d8.minY) {
									d8.minY = ny6;
								}
								if(ny6 > d8.maxY) {
									d8.maxY = ny6;
								}
								this.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_CHANGE":
						var deltaDistance = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("FORWARD_CHANGE");
							this.historyParameters.push(deltaDistance);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FORWARD_CHANGE");
							this.turtleParameters.push(deltaDistance);
						} else {
							var distance4 = this.lastDistance + deltaDistance;
							var nx7 = this.x + distance4 * Math.cos(this.rotation);
							var ny7 = this.y + distance4 * Math.sin(this.rotation);
							if(this.penIsDown) {
								this.lastDistance = distance4 + deltaDistance;
								this.lineTo(nx7,ny7);
							} else {
								var tmp9;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp9 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp9 = true;
									break;
								}
								if(tmp9) {
									this.contour.end(this.width);
								}
								this.x = nx7;
								this.y = ny7;
								var l15 = this.points.length;
								this.points[l15] = [];
								this.points[l15][0] = nx7;
								this.points[l15][1] = ny7;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d9 = this.dim[this.dim.length - 1];
								if(nx7 < d9.minX) {
									d9.minX = nx7;
								}
								if(nx7 > d9.maxX) {
									d9.maxX = nx7;
								}
								if(ny7 < d9.minY) {
									d9.minY = ny7;
								}
								if(ny7 > d9.maxY) {
									d9.maxY = ny7;
								}
								this.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_FACTOR":
						var factor = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("FORWARD_FACTOR");
							this.historyParameters.push(factor);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FORWARD_FACTOR");
							this.turtleParameters.push(factor);
						} else {
							var distance5 = this.lastDistance * factor;
							var nx8 = this.x + distance5 * Math.cos(this.rotation);
							var ny8 = this.y + distance5 * Math.sin(this.rotation);
							if(this.penIsDown) {
								this.lastDistance = distance5;
								this.lineTo(nx8,ny8);
							} else {
								var tmp10;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp10 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp10 = true;
									break;
								}
								if(tmp10) {
									this.contour.end(this.width);
								}
								this.x = nx8;
								this.y = ny8;
								var l16 = this.points.length;
								this.points[l16] = [];
								this.points[l16][0] = nx8;
								this.points[l16][1] = ny8;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d10 = this.dim[this.dim.length - 1];
								if(nx8 < d10.minX) {
									d10.minX = nx8;
								}
								if(nx8 > d10.maxX) {
									d10.maxX = nx8;
								}
								if(ny8 < d10.minY) {
									d10.minY = ny8;
								}
								if(ny8 > d10.maxY) {
									d10.maxY = ny8;
								}
								this.contour.reset();
							}
						}
						++j;
						break;
					case "GREEN":
						if(this.turtleHistoryOn) {
							this.historyAdd("GREEN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("GREEN");
						} else {
							this.pen.currentColor = -16711936;
						}
						break;
					case "GREY":
						if(this.turtleHistoryOn) {
							this.historyAdd("GREY");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("GREY");
						} else {
							this.pen.currentColor = -4737097;
						}
						break;
					case "LEFT":
						var degrees2 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("LEFT");
							this.historyParameters.push(degrees2);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("LEFT");
							this.turtleParameters.push(degrees2);
						} else {
							this.rotation -= degrees2 * Math.PI / 180;
						}
						++j;
						break;
					case "LIGHT_BROWN":
						if(this.turtleHistoryOn) {
							this.historyAdd("LIGHT_BROWN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("LIGHT_BROWN");
						} else {
							this.pen.currentColor = -3831790;
						}
						break;
					case "LINE_STYLE":
						var thickness = v[j];
						var color = v[j + 1];
						if(this.turtleHistoryOn) {
							this.historyAdd("LINE_STYLE");
							this.historyParameters.push(thickness);
							this.historyParameters.push(color);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("LINE_STYLE");
							this.historyParameters.push(thickness);
							this.historyParameters.push(color);
						} else {
							this.width = thickness;
							this.pen.currentColor = color | 0;
						}
						j += 2;
						break;
					case "MAGENTA":
						if(this.turtleHistoryOn) {
							this.historyAdd("MAGENTA");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("MAGENTA");
						} else {
							this.pen.currentColor = -65281;
						}
						break;
					case "MOVE_PEN":
						var distance6 = v[j];
						if(this.repeatCommands) {
							this.turtleCommands.push("MOVE_PEN");
							this.turtleParameters.push(distance6);
						} else if(this.penIsDown) {
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_UP");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_UP");
							} else {
								this.penIsDown = false;
							}
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD");
								this.historyParameters.push(distance6);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD");
								this.turtleParameters.push(distance6);
							} else {
								var nx9 = this.x + distance6 * Math.cos(this.rotation);
								var ny9 = this.y + distance6 * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = distance6;
									this.lineTo(nx9,ny9);
								} else {
									var tmp11;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp11 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp11 = true;
										break;
									}
									if(tmp11) {
										this.contour.end(this.width);
									}
									this.x = nx9;
									this.y = ny9;
									var l17 = this.points.length;
									this.points[l17] = [];
									this.points[l17][0] = nx9;
									this.points[l17][1] = ny9;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d11 = this.dim[this.dim.length - 1];
									if(nx9 < d11.minX) {
										d11.minX = nx9;
									}
									if(nx9 > d11.maxX) {
										d11.maxX = nx9;
									}
									if(ny9 < d11.minY) {
										d11.minY = ny9;
									}
									if(ny9 > d11.maxY) {
										d11.maxY = ny9;
									}
									this.contour.reset();
								}
							}
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_DOWN");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_DOWN");
							} else {
								this.penIsDown = true;
							}
						} else {
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD");
								this.historyParameters.push(distance6);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD");
								this.turtleParameters.push(distance6);
							} else {
								var nx10 = this.x + distance6 * Math.cos(this.rotation);
								var ny10 = this.y + distance6 * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = distance6;
									this.lineTo(nx10,ny10);
								} else {
									var tmp12;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp12 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp12 = true;
										break;
									}
									if(tmp12) {
										this.contour.end(this.width);
									}
									this.x = nx10;
									this.y = ny10;
									var l18 = this.points.length;
									this.points[l18] = [];
									this.points[l18][0] = nx10;
									this.points[l18][1] = ny10;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d12 = this.dim[this.dim.length - 1];
									if(nx10 < d12.minX) {
										d12.minX = nx10;
									}
									if(nx10 > d12.maxX) {
										d12.maxX = nx10;
									}
									if(ny10 < d12.minY) {
										d12.minY = ny10;
									}
									if(ny10 > d12.maxY) {
										d12.maxY = ny10;
									}
									this.contour.reset();
								}
							}
						}
						++j;
						break;
					case "NORTH":
						if(this.turtleHistoryOn) {
							this.historyAdd("NORTH");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("NORTH");
						} else {
							this.rotation = -Math.PI / 2;
						}
						break;
					case "ORANGE":
						if(this.turtleHistoryOn) {
							this.historyAdd("ORANGE");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("ORANGE");
						} else {
							this.pen.currentColor = -23808;
						}
						break;
					case "PEN_COLOR":
						var r = v[j];
						var g = v[j + 1];
						var b = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_COLOR");
							this.historyParameters.push(r);
							this.historyParameters.push(g);
							this.historyParameters.push(b);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_COLOR");
							this.turtleParameters.push(r);
							this.turtleParameters.push(g);
							this.turtleParameters.push(b);
						} else {
							this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_B":
						var r1 = v[j];
						var g1 = v[j + 1];
						var b1 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_COLOR_B");
							this.historyParameters.push(r1);
							this.historyParameters.push(g1);
							this.historyParameters.push(b1);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_COLOR_B");
							this.turtleParameters.push(r1);
							this.turtleParameters.push(g1);
							this.turtleParameters.push(b1);
						} else {
							this.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_C":
						var r2 = v[j];
						var g2 = v[j + 1];
						var b2 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_COLOR_C");
							this.historyParameters.push(r2);
							this.historyParameters.push(g2);
							this.historyParameters.push(b2);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_COLOR_C");
							this.turtleParameters.push(r2);
							this.turtleParameters.push(g2);
							this.turtleParameters.push(b2);
						} else {
							this.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE":
						var r3 = v[j];
						var g3 = v[j + 1];
						var b3 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_COLOR_CHANGE");
							this.historyParameters.push(r3);
							this.historyParameters.push(g3);
							this.historyParameters.push(b3);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_COLOR_CHANGE");
							this.turtleParameters.push(r3);
							this.turtleParameters.push(g3);
							this.turtleParameters.push(b3);
						} else {
							var c = this.pen.currentColor;
							var r0 = (c >> 16 & 255) / 255;
							var g0 = (c >> 8 & 255) / 255;
							var b0 = (c & 255) / 255;
							this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_B":
						var r4 = v[j];
						var g4 = v[j + 1];
						var b4 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_COLOR_CHANGE_B");
							this.historyParameters.push(r4);
							this.historyParameters.push(g4);
							this.historyParameters.push(b4);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_COLOR_CHANGE_B");
							this.turtleParameters.push(r4);
							this.turtleParameters.push(g4);
							this.turtleParameters.push(b4);
						} else {
							var c1 = this.pen.colorB;
							var r01 = (c1 >> 16 & 255) / 255;
							var g01 = (c1 >> 8 & 255) / 255;
							var b01 = (c1 & 255) / 255;
							this.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_C":
						var r5 = v[j];
						var g5 = v[j + 1];
						var b5 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_COLOR_CHANGE_C");
							this.historyParameters.push(r5);
							this.historyParameters.push(g5);
							this.historyParameters.push(b5);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_COLOR_CHANGE_C");
							this.turtleParameters.push(r5);
							this.turtleParameters.push(g5);
							this.turtleParameters.push(b5);
						} else {
							var c2 = this.pen.colorC;
							var r02 = (c2 >> 16 & 255) / 255;
							var g02 = (c2 >> 8 & 255) / 255;
							var b02 = (c2 & 255) / 255;
							this.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
						}
						j += 3;
						break;
					case "PEN_DOWN":
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_DOWN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_DOWN");
						} else {
							this.penIsDown = true;
						}
						break;
					case "PEN_SIZE":
						var w = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_SIZE");
							this.historyParameters.push(w);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_SIZE");
							this.turtleParameters.push(w);
						} else {
							this.width = w;
						}
						++j;
						break;
					case "PEN_SIZE_CHANGE":
						var dw = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_SIZE_CHANGE");
							this.historyParameters.push(dw);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_SIZE_CHANGE");
							this.turtleParameters.push(dw);
						} else {
							this.width += dw;
						}
						++j;
						break;
					case "PEN_SIZE_FACTOR":
						var factor1 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_SIZE_FACTOR");
							this.historyParameters.push(factor1);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_SIZE_FACTOR");
							this.turtleParameters.push(factor1);
						} else {
							this.width *= factor1;
						}
						++j;
						break;
					case "PEN_UP":
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_UP");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_UP");
						} else {
							this.penIsDown = false;
						}
						break;
					case "PLUM":
						if(this.turtleHistoryOn) {
							this.historyAdd("PLUM");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PLUM");
						} else {
							this.pen.currentColor = -7310896;
						}
						break;
					case "RED":
						if(this.turtleHistoryOn) {
							this.historyAdd("RED");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("RED");
						} else {
							this.pen.currentColor = -65536;
						}
						break;
					case "RIGHT":
						var degrees3 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("RIGHT");
							this.historyParameters.push(degrees3);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("RIGHT");
							this.turtleParameters.push(degrees3);
						} else {
							this.rotation += degrees3 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_ANGLE":
						var degrees4 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("SET_ANGLE");
							this.historyParameters.push(degrees4);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("SET_ANGLE");
							this.turtleParameters.push(degrees4);
						} else {
							this.rotation = -Math.PI / 2;
							this.rotation += degrees4 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_POSITION":
						var x2 = v[j];
						var y2 = v[j + 1];
						if(this.turtleHistoryOn) {
							this.historyAdd("SET_POSITION");
							this.historyParameters.push(x2);
							this.historyParameters.push(y2);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("SET_POSITION");
							this.turtleParameters.push(x2);
							this.turtleParameters.push(y2);
						} else {
							var tmp13;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp13 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp13 = true;
								break;
							}
							if(tmp13) {
								this.contour.end(this.width);
							}
							this.x = x2;
							this.y = y2;
							var l19 = this.points.length;
							this.points[l19] = [];
							this.points[l19][0] = x2;
							this.points[l19][1] = y2;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d13 = this.dim[this.dim.length - 1];
							if(x2 < d13.minX) {
								d13.minX = x2;
							}
							if(x2 > d13.maxX) {
								d13.maxX = x2;
							}
							if(y2 < d13.minY) {
								d13.minY = y2;
							}
							if(y2 > d13.maxY) {
								d13.maxY = y2;
							}
							this.contour.reset();
						}
						j += 2;
						break;
					case "SOUTH":
						if(this.turtleHistoryOn) {
							this.historyAdd("SOUTH");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("SOUTH");
						} else {
							this.rotation = Math.PI / 2;
						}
						break;
					case "TAN":
						if(this.turtleHistoryOn) {
							this.historyAdd("TAN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("TAN");
						} else {
							this.pen.currentColor = -27273;
						}
						break;
					case "TRIANGLE_ARCH":
						var distance7 = v[j];
						var distance21 = v[j + 1];
						var radius5 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("TRIANGLE_ARCH");
							this.historyParameters.push(distance7);
							this.historyParameters.push(distance21);
							this.historyParameters.push(radius5);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("TRIANGLE_ARCH");
							this.turtleParameters.push(distance7);
							this.turtleParameters.push(distance21);
							this.turtleParameters.push(radius5);
						} else {
							var nx11 = this.x + distance7 * Math.cos(this.rotation);
							var ny11 = this.y + distance7 * Math.sin(this.rotation);
							if(this.penIsDown) {
								var thruX1 = this.x + distance21 * Math.cos(this.rotation) - radius5 * Math.cos(this.rotation + Math.PI / 2);
								var thruY1 = this.y + distance21 * Math.sin(this.rotation) - radius5 * Math.sin(this.rotation + Math.PI / 2);
								if(this.fill) {
									this.pen.triangle2DFill(this.x,this.y,thruX1,thruY1,nx11,ny11);
								}
								this.lineTo(thruX1,thruY1);
								this.lineTo(nx11,ny11);
								if(this.fill) {
									this.lineTo(this.x,this.y);
								}
								var tmp14;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp14 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp14 = true;
									break;
								}
								if(tmp14) {
									this.contour.end(this.width);
								}
								this.x = nx11;
								this.y = ny11;
								var l20 = this.points.length;
								this.points[l20] = [];
								this.points[l20][0] = nx11;
								this.points[l20][1] = ny11;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d14 = this.dim[this.dim.length - 1];
								if(nx11 < d14.minX) {
									d14.minX = nx11;
								}
								if(nx11 > d14.maxX) {
									d14.maxX = nx11;
								}
								if(ny11 < d14.minY) {
									d14.minY = ny11;
								}
								if(ny11 > d14.maxY) {
									d14.maxY = ny11;
								}
								this.contour.reset();
							} else {
								var tmp15;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp15 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp15 = true;
									break;
								}
								if(tmp15) {
									this.contour.end(this.width);
								}
								this.x = nx11;
								this.y = ny11;
								var l21 = this.points.length;
								this.points[l21] = [];
								this.points[l21][0] = nx11;
								this.points[l21][1] = ny11;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d15 = this.dim[this.dim.length - 1];
								if(nx11 < d15.minX) {
									d15.minX = nx11;
								}
								if(nx11 > d15.maxX) {
									d15.maxX = nx11;
								}
								if(ny11 < d15.minY) {
									d15.minY = ny11;
								}
								if(ny11 > d15.maxY) {
									d15.maxY = ny11;
								}
								this.contour.reset();
							}
						}
						j += 3;
						break;
					case "WEST":
						if(this.turtleHistoryOn) {
							this.historyAdd("WEST");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("WEST");
						} else {
							this.rotation = 0;
						}
						break;
					case "WHITE":
						if(this.turtleHistoryOn) {
							this.historyAdd("WHITE");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("WHITE");
						} else {
							this.pen.currentColor = -1;
						}
						break;
					case "YELLOW":
						if(this.turtleHistoryOn) {
							this.historyAdd("YELLOW");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("YELLOW");
						} else {
							this.pen.currentColor = -256;
						}
						break;
					}
				}
				j = 0;
			}
			this.turtleHistoryOn = wasHistoryOn;
			this.turtleCommands.length = 0;
			this.turtleParameters.length = 0;
		}
		if(repeatCount_ > 0) {
			this.repeatCount = Math.round(repeatCount_);
			this.repeatCommands = true;
			this.turtleCommands.length = 0;
			this.turtleParameters.length = 0;
		}
		return this;
	}
	,beginRepeat: function(repeatCount_) {
		if(this.turtleHistoryOn) {
			this.historyAdd("BEGIN_REPEAT");
			this.historyParameters.push(Math.round(repeatCount_));
		}
		if(this.repeatCommands == true) {
			this.repeatCommands = false;
			if(this.turtleHistoryOn) {
				this.historyAdd("END_REPEAT");
			}
			var wasHistoryOn = this.turtleHistoryOn;
			this.turtleHistoryOn = false;
			var v = this.turtleParameters;
			var j = 0;
			var _g = 0;
			var _g1 = this.repeatCount;
			while(_g < _g1) {
				var k = _g++;
				var _g2 = 0;
				var _g3 = this.turtleCommands.length;
				while(_g2 < _g3) {
					var i = _g2++;
					var command = this.turtleCommands[i];
					switch(command) {
					case "ARC":
						var radius = v[j];
						var degrees = v[j + 1];
						if(this.turtleHistoryOn) {
							this.historyAdd("ARC");
							this.historyParameters.push(radius);
							this.historyParameters.push(degrees);
						}
						if(radius != 0) {
							if(this.repeatCommands) {
								this.turtleCommands.push("ARC");
								this.turtleParameters.push(radius);
								this.turtleParameters.push(degrees);
							} else {
								var beta = degrees * Math.PI / 180 / 24;
								var alpha = (Math.PI - beta) / 2;
								var rotate = -(Math.PI / 2 - alpha);
								var baseLength = 0.5 * radius * Math.sin(beta / 2);
								var ox = this.x;
								var oy = this.y;
								var arr = [];
								arr.push(this.x);
								arr.push(this.y);
								var _g4 = 0;
								while(_g4 < 48) {
									var i1 = _g4++;
									this.rotation += rotate;
									var wasHistoryOn1 = this.turtleHistoryOn;
									this.turtleHistoryOn = false;
									if(this.turtleHistoryOn) {
										this.historyAdd("FORWARD");
										this.historyParameters.push(baseLength);
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("FORWARD");
										this.turtleParameters.push(baseLength);
									} else {
										var nx = this.x + baseLength * Math.cos(this.rotation);
										var ny = this.y + baseLength * Math.sin(this.rotation);
										if(this.penIsDown) {
											this.lastDistance = baseLength;
											this.lineTo(nx,ny);
										} else {
											var tmp;
											switch(this.endLine) {
											case 0:case 1:case 6:case 9:case 12:case 15:case 18:
												tmp = false;
												break;
											case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
												tmp = true;
												break;
											}
											if(tmp) {
												this.contour.end(this.width);
											}
											this.x = nx;
											this.y = ny;
											var l = this.points.length;
											this.points[l] = [];
											this.points[l][0] = nx;
											this.points[l][1] = ny;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d = this.dim[this.dim.length - 1];
											if(nx < d.minX) {
												d.minX = nx;
											}
											if(nx > d.maxX) {
												d.maxX = nx;
											}
											if(ny < d.minY) {
												d.minY = ny;
											}
											if(ny > d.maxY) {
												d.maxY = ny;
											}
											this.contour.reset();
										}
									}
									this.turtleHistoryOn = wasHistoryOn1;
									if(this.fill) {
										arr.push(this.x);
										arr.push(this.y);
									}
								}
								if(this.fill) {
									var cx = (ox + arr[arr.length - 2]) / 2;
									var cy = (oy + arr[arr.length - 1]) / 2;
									var l1 = arr.length;
									var i2 = 2;
									var lx = 0.;
									var ly = 0.;
									this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
									while(i2 < l1) {
										if(i2 > 2) {
											this.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
										}
										lx = arr[i2];
										ly = arr[i2 + 1];
										i2 += 2;
									}
								}
								arr.length = 0;
							}
						}
						j += 2;
						break;
					case "ARCH_BEZIER":
						var distance = v[j];
						var distance2 = v[j + 1];
						var radius1 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("ARCH_BEZIER");
							this.historyParameters.push(distance);
							this.historyParameters.push(distance2);
							this.historyParameters.push(radius1);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("ARCH_BEZIER");
							this.turtleParameters.push(distance);
							this.turtleParameters.push(distance2);
							this.turtleParameters.push(radius1);
						} else {
							var nx1 = this.x + distance * Math.cos(this.rotation);
							var ny1 = this.y + distance * Math.sin(this.rotation);
							if(this.penIsDown) {
								var thruX = this.x + distance2 * Math.cos(this.rotation) - radius1 * Math.cos(this.rotation + Math.PI / 2);
								var thruY = this.y + distance2 * Math.sin(this.rotation) - radius1 * Math.sin(this.rotation + Math.PI / 2);
								var newx = 2 * thruX - 0.5 * (this.x + nx1);
								var newy = 2 * thruY - 0.5 * (this.y + ny1);
								this.tempArr = [];
								var p = this.tempArr;
								var ax = this.x;
								var ay = this.y;
								var x = ax - newx;
								var y = ay - newy;
								var x1 = newx - nx1;
								var y1 = newy - ny1;
								var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
								if(approxDistance == 0) {
									approxDistance = 0.000001;
								}
								var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
								var l2 = p.length;
								p[l2++] = ax;
								p[l2++] = ay;
								var t = step;
								while(t < 1.) {
									var u = 1 - t;
									p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
									var u1 = 1 - t;
									p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
									t += step;
								}
								p[l2++] = nx1;
								p[l2++] = ny1;
								var arr1 = this.tempArr;
								var withMove = false;
								if(withMove == null) {
									withMove = true;
								}
								var l3 = arr1.length;
								var i3 = 2;
								if(withMove) {
									var x_ = arr1[0];
									var y_ = arr1[1];
									var tmp1;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp1 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp1 = true;
										break;
									}
									if(tmp1) {
										this.contour.end(this.width);
									}
									this.x = x_;
									this.y = y_;
									var l4 = this.points.length;
									this.points[l4] = [];
									this.points[l4][0] = x_;
									this.points[l4][1] = y_;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d1 = this.dim[this.dim.length - 1];
									if(x_ < d1.minX) {
										d1.minX = x_;
									}
									if(x_ > d1.maxX) {
										d1.maxX = x_;
									}
									if(y_ < d1.minY) {
										d1.minY = y_;
									}
									if(y_ > d1.maxY) {
										d1.maxY = y_;
									}
									this.contour.reset();
								} else {
									this.lineTo(arr1[0],arr1[1]);
								}
								var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
								var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
								var ox1 = this.x;
								var oy1 = this.y;
								while(i3 < l3) {
									if(this.fill && this.penIsDown) {
										if(i3 > 0 && i3 < l3 - 2) {
											this.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
										}
									}
									this.lineTo(arr1[i3],arr1[i3 + 1]);
									i3 += 2;
								}
								if(this.fill && this.penIsDown) {
									var tmp2;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp2 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp2 = true;
										break;
									}
									if(tmp2) {
										this.contour.end(this.width);
									}
									this.x = ox1;
									this.y = oy1;
									var l5 = this.points.length;
									this.points[l5] = [];
									this.points[l5][0] = ox1;
									this.points[l5][1] = oy1;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d2 = this.dim[this.dim.length - 1];
									if(ox1 < d2.minX) {
										d2.minX = ox1;
									}
									if(ox1 > d2.maxX) {
										d2.maxX = ox1;
									}
									if(oy1 < d2.minY) {
										d2.minY = oy1;
									}
									if(oy1 > d2.maxY) {
										d2.maxY = oy1;
									}
									this.contour.reset();
									this.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
								}
								this.x = nx1;
								this.y = ny1;
							} else {
								var tmp3;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp3 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp3 = true;
									break;
								}
								if(tmp3) {
									this.contour.end(this.width);
								}
								this.x = nx1;
								this.y = ny1;
								var l6 = this.points.length;
								this.points[l6] = [];
								this.points[l6][0] = nx1;
								this.points[l6][1] = ny1;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d3 = this.dim[this.dim.length - 1];
								if(nx1 < d3.minX) {
									d3.minX = nx1;
								}
								if(nx1 > d3.maxX) {
									d3.maxX = nx1;
								}
								if(ny1 < d3.minY) {
									d3.minY = ny1;
								}
								if(ny1 > d3.maxY) {
									d3.maxY = ny1;
								}
								this.contour.reset();
							}
						}
						j += 3;
						break;
					case "ARC_SIDES":
						var radius2 = v[j];
						var degrees1 = v[j + 1];
						var sides = v[j + 2];
						if(sides == null) {
							sides = 24;
						}
						if(this.turtleHistoryOn) {
							if(sides == 24) {
								this.historyAdd("ARC");
								this.historyParameters.push(radius2);
								this.historyParameters.push(degrees1);
							} else {
								this.historyAdd("ARC_SIDES");
								this.historyParameters.push(radius2);
								this.historyParameters.push(degrees1);
								this.historyParameters.push(sides);
							}
						}
						if(radius2 != 0) {
							if(this.repeatCommands) {
								if(sides == 24) {
									this.turtleCommands.push("ARC");
									this.turtleParameters.push(radius2);
									this.turtleParameters.push(degrees1);
								} else {
									this.turtleCommands.push("ARC_SIDES");
									this.turtleParameters.push(radius2);
									this.turtleParameters.push(degrees1);
									this.turtleParameters.push(sides);
								}
							} else {
								var beta1 = degrees1 * Math.PI / 180 / sides;
								var alpha1 = (Math.PI - beta1) / 2;
								var rotate1 = -(Math.PI / 2 - alpha1);
								var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
								var ox2 = this.x;
								var oy2 = this.y;
								var arr2 = [];
								arr2.push(this.x);
								arr2.push(this.y);
								var _g5 = 0;
								while(_g5 < 48) {
									var i4 = _g5++;
									this.rotation += rotate1;
									var wasHistoryOn2 = this.turtleHistoryOn;
									this.turtleHistoryOn = false;
									if(this.turtleHistoryOn) {
										this.historyAdd("FORWARD");
										this.historyParameters.push(baseLength1);
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("FORWARD");
										this.turtleParameters.push(baseLength1);
									} else {
										var nx2 = this.x + baseLength1 * Math.cos(this.rotation);
										var ny2 = this.y + baseLength1 * Math.sin(this.rotation);
										if(this.penIsDown) {
											this.lastDistance = baseLength1;
											this.lineTo(nx2,ny2);
										} else {
											var tmp4;
											switch(this.endLine) {
											case 0:case 1:case 6:case 9:case 12:case 15:case 18:
												tmp4 = false;
												break;
											case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
												tmp4 = true;
												break;
											}
											if(tmp4) {
												this.contour.end(this.width);
											}
											this.x = nx2;
											this.y = ny2;
											var l7 = this.points.length;
											this.points[l7] = [];
											this.points[l7][0] = nx2;
											this.points[l7][1] = ny2;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d4 = this.dim[this.dim.length - 1];
											if(nx2 < d4.minX) {
												d4.minX = nx2;
											}
											if(nx2 > d4.maxX) {
												d4.maxX = nx2;
											}
											if(ny2 < d4.minY) {
												d4.minY = ny2;
											}
											if(ny2 > d4.maxY) {
												d4.maxY = ny2;
											}
											this.contour.reset();
										}
									}
									this.turtleHistoryOn = wasHistoryOn2;
									if(this.fill) {
										arr2.push(this.x);
										arr2.push(this.y);
									}
								}
								if(this.fill) {
									var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
									var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
									var l8 = arr2.length;
									var i5 = 2;
									var lx1 = 0.;
									var ly1 = 0.;
									this.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
									while(i5 < l8) {
										if(i5 > 2) {
											this.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
										}
										lx1 = arr2[i5];
										ly1 = arr2[i5 + 1];
										i5 += 2;
									}
								}
								arr2.length = 0;
							}
						}
						j += 3;
						break;
					case "BACKWARD":
						var distance1 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("BACKWARD");
							this.historyParameters.push(distance1);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("BACKWARD");
							this.turtleParameters.push(distance1);
						} else {
							var nx3 = this.x + distance1 * Math.cos(this.rotation + Math.PI);
							var ny3 = this.y + distance1 * Math.sin(this.rotation + Math.PI);
							if(this.penIsDown) {
								this.lineTo(nx3,ny3);
							} else {
								var tmp5;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp5 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp5 = true;
									break;
								}
								if(tmp5) {
									this.contour.end(this.width);
								}
								this.x = nx3;
								this.y = ny3;
								var l9 = this.points.length;
								this.points[l9] = [];
								this.points[l9][0] = nx3;
								this.points[l9][1] = ny3;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d5 = this.dim[this.dim.length - 1];
								if(nx3 < d5.minX) {
									d5.minX = nx3;
								}
								if(nx3 > d5.maxX) {
									d5.maxX = nx3;
								}
								if(ny3 < d5.minY) {
									d5.minY = ny3;
								}
								if(ny3 > d5.maxY) {
									d5.maxY = ny3;
								}
								this.contour.reset();
							}
						}
						++j;
						break;
					case "BEGIN_REPEAT":
						break;
					case "BLACK":
						if(this.turtleHistoryOn) {
							this.historyAdd("BLACK");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("BLACK");
						} else {
							this.pen.currentColor = -16777216;
						}
						break;
					case "BLUE":
						if(this.turtleHistoryOn) {
							this.historyAdd("BLUE");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("BLUE");
						} else {
							this.pen.currentColor = -16776961;
						}
						break;
					case "BROWN":
						if(this.turtleHistoryOn) {
							this.historyAdd("BROWN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("BROWN");
						} else {
							this.pen.currentColor = -6594501;
						}
						break;
					case "CIRCLE":
						var radius3 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("CIRCLE");
							this.historyParameters.push(radius3);
						}
						if(radius3 != 0) {
							if(this.repeatCommands) {
								this.turtleCommands.push("CIRCLE");
								this.turtleParameters.push(radius3);
							} else {
								var beta2 = 2 * Math.PI / 24;
								var alpha2 = (Math.PI - beta2) / 2;
								var rotate2 = -(Math.PI / 2 - alpha2);
								var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
								var ox3 = this.x;
								var oy3 = this.y;
								var arr3 = [];
								var _g6 = 0;
								while(_g6 < 48) {
									var i6 = _g6++;
									this.rotation += rotate2;
									var wasHistoryOn3 = this.turtleHistoryOn;
									this.turtleHistoryOn = false;
									if(this.turtleHistoryOn) {
										this.historyAdd("FORWARD");
										this.historyParameters.push(baseLength2);
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("FORWARD");
										this.turtleParameters.push(baseLength2);
									} else {
										var nx4 = this.x + baseLength2 * Math.cos(this.rotation);
										var ny4 = this.y + baseLength2 * Math.sin(this.rotation);
										if(this.penIsDown) {
											this.lastDistance = baseLength2;
											this.lineTo(nx4,ny4);
										} else {
											var tmp6;
											switch(this.endLine) {
											case 0:case 1:case 6:case 9:case 12:case 15:case 18:
												tmp6 = false;
												break;
											case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
												tmp6 = true;
												break;
											}
											if(tmp6) {
												this.contour.end(this.width);
											}
											this.x = nx4;
											this.y = ny4;
											var l10 = this.points.length;
											this.points[l10] = [];
											this.points[l10][0] = nx4;
											this.points[l10][1] = ny4;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d6 = this.dim[this.dim.length - 1];
											if(nx4 < d6.minX) {
												d6.minX = nx4;
											}
											if(nx4 > d6.maxX) {
												d6.maxX = nx4;
											}
											if(ny4 < d6.minY) {
												d6.minY = ny4;
											}
											if(ny4 > d6.maxY) {
												d6.maxY = ny4;
											}
											this.contour.reset();
										}
									}
									this.turtleHistoryOn = wasHistoryOn3;
									if(this.fill) {
										arr3.push(this.x);
										arr3.push(this.y);
									}
								}
								if(this.fill) {
									var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
									var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
									var l11 = arr3.length;
									var i7 = 2;
									var lx2 = 0.;
									var ly2 = 0.;
									while(i7 < l11) {
										if(i7 > 2) {
											this.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
										}
										lx2 = arr3[i7];
										ly2 = arr3[i7 + 1];
										i7 += 2;
									}
								}
								arr3.length = 0;
							}
						}
						++j;
						break;
					case "CIRCLE_SIDES":
						var radius4 = v[j];
						var sides1 = v[j + 1];
						if(sides1 == null) {
							sides1 = 24;
						}
						if(this.turtleHistoryOn) {
							if(sides1 == 24) {
								this.historyAdd("CIRCLE");
								this.historyParameters.push(radius4);
							} else {
								this.historyAdd("CIRCLE_SIDES");
								this.historyParameters.push(radius4);
								this.historyParameters.push(sides1);
							}
						}
						if(radius4 != 0) {
							if(this.repeatCommands) {
								if(sides1 == 24) {
									this.turtleCommands.push("CIRCLE");
									this.turtleParameters.push(radius4);
								} else {
									this.turtleCommands.push("CIRCLE_SIDES");
									this.turtleParameters.push(radius4);
									this.turtleParameters.push(sides1);
								}
							} else {
								var beta3 = 2 * Math.PI / sides1;
								var alpha3 = (Math.PI - beta3) / 2;
								var rotate3 = -(Math.PI / 2 - alpha3);
								var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
								var ox4 = this.x;
								var oy4 = this.y;
								var arr4 = [];
								var _g7 = 0;
								while(_g7 < 48) {
									var i8 = _g7++;
									this.rotation += rotate3;
									var wasHistoryOn4 = this.turtleHistoryOn;
									this.turtleHistoryOn = false;
									if(this.turtleHistoryOn) {
										this.historyAdd("FORWARD");
										this.historyParameters.push(baseLength3);
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("FORWARD");
										this.turtleParameters.push(baseLength3);
									} else {
										var nx5 = this.x + baseLength3 * Math.cos(this.rotation);
										var ny5 = this.y + baseLength3 * Math.sin(this.rotation);
										if(this.penIsDown) {
											this.lastDistance = baseLength3;
											this.lineTo(nx5,ny5);
										} else {
											var tmp7;
											switch(this.endLine) {
											case 0:case 1:case 6:case 9:case 12:case 15:case 18:
												tmp7 = false;
												break;
											case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
												tmp7 = true;
												break;
											}
											if(tmp7) {
												this.contour.end(this.width);
											}
											this.x = nx5;
											this.y = ny5;
											var l12 = this.points.length;
											this.points[l12] = [];
											this.points[l12][0] = nx5;
											this.points[l12][1] = ny5;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d7 = this.dim[this.dim.length - 1];
											if(nx5 < d7.minX) {
												d7.minX = nx5;
											}
											if(nx5 > d7.maxX) {
												d7.maxX = nx5;
											}
											if(ny5 < d7.minY) {
												d7.minY = ny5;
											}
											if(ny5 > d7.maxY) {
												d7.maxY = ny5;
											}
											this.contour.reset();
										}
									}
									this.turtleHistoryOn = wasHistoryOn4;
									if(this.fill) {
										arr4.push(this.x);
										arr4.push(this.y);
									}
								}
								if(this.fill) {
									var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
									var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
									var l13 = arr4.length;
									var i9 = 2;
									var lx3 = 0.;
									var ly3 = 0.;
									while(i9 < l13) {
										if(i9 > 2) {
											this.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
										}
										lx3 = arr4[i9];
										ly3 = arr4[i9 + 1];
										i9 += 2;
									}
								}
								arr4.length = 0;
							}
						}
						j += 2;
						break;
					case "CYAN":
						if(this.turtleHistoryOn) {
							this.historyAdd("CYAN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("CYAN");
						} else {
							this.pen.currentColor = -16711681;
						}
						break;
					case "DARKISH_BLUE":
						if(this.turtleHistoryOn) {
							this.historyAdd("DARKISH_BLUE");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("DARKISH_BLUE");
						} else {
							this.pen.currentColor = -8864837;
						}
						break;
					case "DARK_GREEN":
						if(this.turtleHistoryOn) {
							this.historyAdd("DARK_GREEN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("DARK_GREEN");
						} else {
							this.pen.currentColor = -10182080;
						}
						break;
					case "EAST":
						if(this.turtleHistoryOn) {
							this.historyAdd("WEST");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("EAST");
						} else {
							this.rotation = Math.PI;
						}
						break;
					case "END_REPEAT":
						break;
					case "FILL_OFF":
						if(this.turtleHistoryOn) {
							this.historyAdd("FILL_OFF");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FILL_OFF");
						} else {
							this.fill = false;
						}
						break;
					case "FILL_ON":
						if(this.turtleHistoryOn) {
							this.historyAdd("FILL_ON");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FILL_ON");
						} else {
							this.fill = true;
						}
						break;
					case "FORWARD":
						var distance3 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("FORWARD");
							this.historyParameters.push(distance3);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FORWARD");
							this.turtleParameters.push(distance3);
						} else {
							var nx6 = this.x + distance3 * Math.cos(this.rotation);
							var ny6 = this.y + distance3 * Math.sin(this.rotation);
							if(this.penIsDown) {
								this.lastDistance = distance3;
								this.lineTo(nx6,ny6);
							} else {
								var tmp8;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp8 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp8 = true;
									break;
								}
								if(tmp8) {
									this.contour.end(this.width);
								}
								this.x = nx6;
								this.y = ny6;
								var l14 = this.points.length;
								this.points[l14] = [];
								this.points[l14][0] = nx6;
								this.points[l14][1] = ny6;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d8 = this.dim[this.dim.length - 1];
								if(nx6 < d8.minX) {
									d8.minX = nx6;
								}
								if(nx6 > d8.maxX) {
									d8.maxX = nx6;
								}
								if(ny6 < d8.minY) {
									d8.minY = ny6;
								}
								if(ny6 > d8.maxY) {
									d8.maxY = ny6;
								}
								this.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_CHANGE":
						var deltaDistance = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("FORWARD_CHANGE");
							this.historyParameters.push(deltaDistance);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FORWARD_CHANGE");
							this.turtleParameters.push(deltaDistance);
						} else {
							var distance4 = this.lastDistance + deltaDistance;
							var nx7 = this.x + distance4 * Math.cos(this.rotation);
							var ny7 = this.y + distance4 * Math.sin(this.rotation);
							if(this.penIsDown) {
								this.lastDistance = distance4 + deltaDistance;
								this.lineTo(nx7,ny7);
							} else {
								var tmp9;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp9 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp9 = true;
									break;
								}
								if(tmp9) {
									this.contour.end(this.width);
								}
								this.x = nx7;
								this.y = ny7;
								var l15 = this.points.length;
								this.points[l15] = [];
								this.points[l15][0] = nx7;
								this.points[l15][1] = ny7;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d9 = this.dim[this.dim.length - 1];
								if(nx7 < d9.minX) {
									d9.minX = nx7;
								}
								if(nx7 > d9.maxX) {
									d9.maxX = nx7;
								}
								if(ny7 < d9.minY) {
									d9.minY = ny7;
								}
								if(ny7 > d9.maxY) {
									d9.maxY = ny7;
								}
								this.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_FACTOR":
						var factor = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("FORWARD_FACTOR");
							this.historyParameters.push(factor);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FORWARD_FACTOR");
							this.turtleParameters.push(factor);
						} else {
							var distance5 = this.lastDistance * factor;
							var nx8 = this.x + distance5 * Math.cos(this.rotation);
							var ny8 = this.y + distance5 * Math.sin(this.rotation);
							if(this.penIsDown) {
								this.lastDistance = distance5;
								this.lineTo(nx8,ny8);
							} else {
								var tmp10;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp10 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp10 = true;
									break;
								}
								if(tmp10) {
									this.contour.end(this.width);
								}
								this.x = nx8;
								this.y = ny8;
								var l16 = this.points.length;
								this.points[l16] = [];
								this.points[l16][0] = nx8;
								this.points[l16][1] = ny8;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d10 = this.dim[this.dim.length - 1];
								if(nx8 < d10.minX) {
									d10.minX = nx8;
								}
								if(nx8 > d10.maxX) {
									d10.maxX = nx8;
								}
								if(ny8 < d10.minY) {
									d10.minY = ny8;
								}
								if(ny8 > d10.maxY) {
									d10.maxY = ny8;
								}
								this.contour.reset();
							}
						}
						++j;
						break;
					case "GREEN":
						if(this.turtleHistoryOn) {
							this.historyAdd("GREEN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("GREEN");
						} else {
							this.pen.currentColor = -16711936;
						}
						break;
					case "GREY":
						if(this.turtleHistoryOn) {
							this.historyAdd("GREY");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("GREY");
						} else {
							this.pen.currentColor = -4737097;
						}
						break;
					case "LEFT":
						var degrees2 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("LEFT");
							this.historyParameters.push(degrees2);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("LEFT");
							this.turtleParameters.push(degrees2);
						} else {
							this.rotation -= degrees2 * Math.PI / 180;
						}
						++j;
						break;
					case "LIGHT_BROWN":
						if(this.turtleHistoryOn) {
							this.historyAdd("LIGHT_BROWN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("LIGHT_BROWN");
						} else {
							this.pen.currentColor = -3831790;
						}
						break;
					case "LINE_STYLE":
						var thickness = v[j];
						var color = v[j + 1];
						if(this.turtleHistoryOn) {
							this.historyAdd("LINE_STYLE");
							this.historyParameters.push(thickness);
							this.historyParameters.push(color);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("LINE_STYLE");
							this.historyParameters.push(thickness);
							this.historyParameters.push(color);
						} else {
							this.width = thickness;
							this.pen.currentColor = color | 0;
						}
						j += 2;
						break;
					case "MAGENTA":
						if(this.turtleHistoryOn) {
							this.historyAdd("MAGENTA");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("MAGENTA");
						} else {
							this.pen.currentColor = -65281;
						}
						break;
					case "MOVE_PEN":
						var distance6 = v[j];
						if(this.repeatCommands) {
							this.turtleCommands.push("MOVE_PEN");
							this.turtleParameters.push(distance6);
						} else if(this.penIsDown) {
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_UP");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_UP");
							} else {
								this.penIsDown = false;
							}
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD");
								this.historyParameters.push(distance6);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD");
								this.turtleParameters.push(distance6);
							} else {
								var nx9 = this.x + distance6 * Math.cos(this.rotation);
								var ny9 = this.y + distance6 * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = distance6;
									this.lineTo(nx9,ny9);
								} else {
									var tmp11;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp11 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp11 = true;
										break;
									}
									if(tmp11) {
										this.contour.end(this.width);
									}
									this.x = nx9;
									this.y = ny9;
									var l17 = this.points.length;
									this.points[l17] = [];
									this.points[l17][0] = nx9;
									this.points[l17][1] = ny9;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d11 = this.dim[this.dim.length - 1];
									if(nx9 < d11.minX) {
										d11.minX = nx9;
									}
									if(nx9 > d11.maxX) {
										d11.maxX = nx9;
									}
									if(ny9 < d11.minY) {
										d11.minY = ny9;
									}
									if(ny9 > d11.maxY) {
										d11.maxY = ny9;
									}
									this.contour.reset();
								}
							}
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_DOWN");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_DOWN");
							} else {
								this.penIsDown = true;
							}
						} else {
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD");
								this.historyParameters.push(distance6);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD");
								this.turtleParameters.push(distance6);
							} else {
								var nx10 = this.x + distance6 * Math.cos(this.rotation);
								var ny10 = this.y + distance6 * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = distance6;
									this.lineTo(nx10,ny10);
								} else {
									var tmp12;
									switch(this.endLine) {
									case 0:case 1:case 6:case 9:case 12:case 15:case 18:
										tmp12 = false;
										break;
									case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
										tmp12 = true;
										break;
									}
									if(tmp12) {
										this.contour.end(this.width);
									}
									this.x = nx10;
									this.y = ny10;
									var l18 = this.points.length;
									this.points[l18] = [];
									this.points[l18][0] = nx10;
									this.points[l18][1] = ny10;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d12 = this.dim[this.dim.length - 1];
									if(nx10 < d12.minX) {
										d12.minX = nx10;
									}
									if(nx10 > d12.maxX) {
										d12.maxX = nx10;
									}
									if(ny10 < d12.minY) {
										d12.minY = ny10;
									}
									if(ny10 > d12.maxY) {
										d12.maxY = ny10;
									}
									this.contour.reset();
								}
							}
						}
						++j;
						break;
					case "NORTH":
						if(this.turtleHistoryOn) {
							this.historyAdd("NORTH");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("NORTH");
						} else {
							this.rotation = -Math.PI / 2;
						}
						break;
					case "ORANGE":
						if(this.turtleHistoryOn) {
							this.historyAdd("ORANGE");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("ORANGE");
						} else {
							this.pen.currentColor = -23808;
						}
						break;
					case "PEN_COLOR":
						var r = v[j];
						var g = v[j + 1];
						var b = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_COLOR");
							this.historyParameters.push(r);
							this.historyParameters.push(g);
							this.historyParameters.push(b);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_COLOR");
							this.turtleParameters.push(r);
							this.turtleParameters.push(g);
							this.turtleParameters.push(b);
						} else {
							this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_B":
						var r1 = v[j];
						var g1 = v[j + 1];
						var b1 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_COLOR_B");
							this.historyParameters.push(r1);
							this.historyParameters.push(g1);
							this.historyParameters.push(b1);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_COLOR_B");
							this.turtleParameters.push(r1);
							this.turtleParameters.push(g1);
							this.turtleParameters.push(b1);
						} else {
							this.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_C":
						var r2 = v[j];
						var g2 = v[j + 1];
						var b2 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_COLOR_C");
							this.historyParameters.push(r2);
							this.historyParameters.push(g2);
							this.historyParameters.push(b2);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_COLOR_C");
							this.turtleParameters.push(r2);
							this.turtleParameters.push(g2);
							this.turtleParameters.push(b2);
						} else {
							this.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE":
						var r3 = v[j];
						var g3 = v[j + 1];
						var b3 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_COLOR_CHANGE");
							this.historyParameters.push(r3);
							this.historyParameters.push(g3);
							this.historyParameters.push(b3);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_COLOR_CHANGE");
							this.turtleParameters.push(r3);
							this.turtleParameters.push(g3);
							this.turtleParameters.push(b3);
						} else {
							var c = this.pen.currentColor;
							var r0 = (c >> 16 & 255) / 255;
							var g0 = (c >> 8 & 255) / 255;
							var b0 = (c & 255) / 255;
							this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_B":
						var r4 = v[j];
						var g4 = v[j + 1];
						var b4 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_COLOR_CHANGE_B");
							this.historyParameters.push(r4);
							this.historyParameters.push(g4);
							this.historyParameters.push(b4);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_COLOR_CHANGE_B");
							this.turtleParameters.push(r4);
							this.turtleParameters.push(g4);
							this.turtleParameters.push(b4);
						} else {
							var c1 = this.pen.colorB;
							var r01 = (c1 >> 16 & 255) / 255;
							var g01 = (c1 >> 8 & 255) / 255;
							var b01 = (c1 & 255) / 255;
							this.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_C":
						var r5 = v[j];
						var g5 = v[j + 1];
						var b5 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_COLOR_CHANGE_C");
							this.historyParameters.push(r5);
							this.historyParameters.push(g5);
							this.historyParameters.push(b5);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_COLOR_CHANGE_C");
							this.turtleParameters.push(r5);
							this.turtleParameters.push(g5);
							this.turtleParameters.push(b5);
						} else {
							var c2 = this.pen.colorC;
							var r02 = (c2 >> 16 & 255) / 255;
							var g02 = (c2 >> 8 & 255) / 255;
							var b02 = (c2 & 255) / 255;
							this.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
						}
						j += 3;
						break;
					case "PEN_DOWN":
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_DOWN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_DOWN");
						} else {
							this.penIsDown = true;
						}
						break;
					case "PEN_SIZE":
						var w = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_SIZE");
							this.historyParameters.push(w);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_SIZE");
							this.turtleParameters.push(w);
						} else {
							this.width = w;
						}
						++j;
						break;
					case "PEN_SIZE_CHANGE":
						var dw = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_SIZE_CHANGE");
							this.historyParameters.push(dw);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_SIZE_CHANGE");
							this.turtleParameters.push(dw);
						} else {
							this.width += dw;
						}
						++j;
						break;
					case "PEN_SIZE_FACTOR":
						var factor1 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_SIZE_FACTOR");
							this.historyParameters.push(factor1);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_SIZE_FACTOR");
							this.turtleParameters.push(factor1);
						} else {
							this.width *= factor1;
						}
						++j;
						break;
					case "PEN_UP":
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_UP");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_UP");
						} else {
							this.penIsDown = false;
						}
						break;
					case "PLUM":
						if(this.turtleHistoryOn) {
							this.historyAdd("PLUM");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PLUM");
						} else {
							this.pen.currentColor = -7310896;
						}
						break;
					case "RED":
						if(this.turtleHistoryOn) {
							this.historyAdd("RED");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("RED");
						} else {
							this.pen.currentColor = -65536;
						}
						break;
					case "RIGHT":
						var degrees3 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("RIGHT");
							this.historyParameters.push(degrees3);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("RIGHT");
							this.turtleParameters.push(degrees3);
						} else {
							this.rotation += degrees3 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_ANGLE":
						var degrees4 = v[j];
						if(this.turtleHistoryOn) {
							this.historyAdd("SET_ANGLE");
							this.historyParameters.push(degrees4);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("SET_ANGLE");
							this.turtleParameters.push(degrees4);
						} else {
							this.rotation = -Math.PI / 2;
							this.rotation += degrees4 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_POSITION":
						var x2 = v[j];
						var y2 = v[j + 1];
						if(this.turtleHistoryOn) {
							this.historyAdd("SET_POSITION");
							this.historyParameters.push(x2);
							this.historyParameters.push(y2);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("SET_POSITION");
							this.turtleParameters.push(x2);
							this.turtleParameters.push(y2);
						} else {
							var tmp13;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp13 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp13 = true;
								break;
							}
							if(tmp13) {
								this.contour.end(this.width);
							}
							this.x = x2;
							this.y = y2;
							var l19 = this.points.length;
							this.points[l19] = [];
							this.points[l19][0] = x2;
							this.points[l19][1] = y2;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d13 = this.dim[this.dim.length - 1];
							if(x2 < d13.minX) {
								d13.minX = x2;
							}
							if(x2 > d13.maxX) {
								d13.maxX = x2;
							}
							if(y2 < d13.minY) {
								d13.minY = y2;
							}
							if(y2 > d13.maxY) {
								d13.maxY = y2;
							}
							this.contour.reset();
						}
						j += 2;
						break;
					case "SOUTH":
						if(this.turtleHistoryOn) {
							this.historyAdd("SOUTH");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("SOUTH");
						} else {
							this.rotation = Math.PI / 2;
						}
						break;
					case "TAN":
						if(this.turtleHistoryOn) {
							this.historyAdd("TAN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("TAN");
						} else {
							this.pen.currentColor = -27273;
						}
						break;
					case "TRIANGLE_ARCH":
						var distance7 = v[j];
						var distance21 = v[j + 1];
						var radius5 = v[j + 2];
						if(this.turtleHistoryOn) {
							this.historyAdd("TRIANGLE_ARCH");
							this.historyParameters.push(distance7);
							this.historyParameters.push(distance21);
							this.historyParameters.push(radius5);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("TRIANGLE_ARCH");
							this.turtleParameters.push(distance7);
							this.turtleParameters.push(distance21);
							this.turtleParameters.push(radius5);
						} else {
							var nx11 = this.x + distance7 * Math.cos(this.rotation);
							var ny11 = this.y + distance7 * Math.sin(this.rotation);
							if(this.penIsDown) {
								var thruX1 = this.x + distance21 * Math.cos(this.rotation) - radius5 * Math.cos(this.rotation + Math.PI / 2);
								var thruY1 = this.y + distance21 * Math.sin(this.rotation) - radius5 * Math.sin(this.rotation + Math.PI / 2);
								if(this.fill) {
									this.pen.triangle2DFill(this.x,this.y,thruX1,thruY1,nx11,ny11);
								}
								this.lineTo(thruX1,thruY1);
								this.lineTo(nx11,ny11);
								if(this.fill) {
									this.lineTo(this.x,this.y);
								}
								var tmp14;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp14 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp14 = true;
									break;
								}
								if(tmp14) {
									this.contour.end(this.width);
								}
								this.x = nx11;
								this.y = ny11;
								var l20 = this.points.length;
								this.points[l20] = [];
								this.points[l20][0] = nx11;
								this.points[l20][1] = ny11;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d14 = this.dim[this.dim.length - 1];
								if(nx11 < d14.minX) {
									d14.minX = nx11;
								}
								if(nx11 > d14.maxX) {
									d14.maxX = nx11;
								}
								if(ny11 < d14.minY) {
									d14.minY = ny11;
								}
								if(ny11 > d14.maxY) {
									d14.maxY = ny11;
								}
								this.contour.reset();
							} else {
								var tmp15;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp15 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp15 = true;
									break;
								}
								if(tmp15) {
									this.contour.end(this.width);
								}
								this.x = nx11;
								this.y = ny11;
								var l21 = this.points.length;
								this.points[l21] = [];
								this.points[l21][0] = nx11;
								this.points[l21][1] = ny11;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d15 = this.dim[this.dim.length - 1];
								if(nx11 < d15.minX) {
									d15.minX = nx11;
								}
								if(nx11 > d15.maxX) {
									d15.maxX = nx11;
								}
								if(ny11 < d15.minY) {
									d15.minY = ny11;
								}
								if(ny11 > d15.maxY) {
									d15.maxY = ny11;
								}
								this.contour.reset();
							}
						}
						j += 3;
						break;
					case "WEST":
						if(this.turtleHistoryOn) {
							this.historyAdd("WEST");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("WEST");
						} else {
							this.rotation = 0;
						}
						break;
					case "WHITE":
						if(this.turtleHistoryOn) {
							this.historyAdd("WHITE");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("WHITE");
						} else {
							this.pen.currentColor = -1;
						}
						break;
					case "YELLOW":
						if(this.turtleHistoryOn) {
							this.historyAdd("YELLOW");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("YELLOW");
						} else {
							this.pen.currentColor = -256;
						}
						break;
					}
				}
				j = 0;
			}
			this.turtleHistoryOn = wasHistoryOn;
			this.turtleCommands.length = 0;
			this.turtleParameters.length = 0;
		}
		if(repeatCount_ > 0) {
			this.repeatCount = Math.round(repeatCount_);
			this.repeatCommands = true;
			this.turtleCommands.length = 0;
			this.turtleParameters.length = 0;
		}
		return this;
	}
	,loopEnd: function() {
		this.repeatCommands = false;
		if(this.turtleHistoryOn) {
			this.historyAdd("END_REPEAT");
		}
		var wasHistoryOn = this.turtleHistoryOn;
		this.turtleHistoryOn = false;
		var v = this.turtleParameters;
		var j = 0;
		var _g = 0;
		var _g1 = this.repeatCount;
		while(_g < _g1) {
			var k = _g++;
			var _g2 = 0;
			var _g3 = this.turtleCommands.length;
			while(_g2 < _g3) {
				var i = _g2++;
				var command = this.turtleCommands[i];
				switch(command) {
				case "ARC":
					var radius = v[j];
					var degrees = v[j + 1];
					if(this.turtleHistoryOn) {
						this.historyAdd("ARC");
						this.historyParameters.push(radius);
						this.historyParameters.push(degrees);
					}
					if(radius != 0) {
						if(this.repeatCommands) {
							this.turtleCommands.push("ARC");
							this.turtleParameters.push(radius);
							this.turtleParameters.push(degrees);
						} else {
							var beta = degrees * Math.PI / 180 / 24;
							var alpha = (Math.PI - beta) / 2;
							var rotate = -(Math.PI / 2 - alpha);
							var baseLength = 0.5 * radius * Math.sin(beta / 2);
							var ox = this.x;
							var oy = this.y;
							var arr = [];
							arr.push(this.x);
							arr.push(this.y);
							var _g4 = 0;
							while(_g4 < 48) {
								var i1 = _g4++;
								this.rotation += rotate;
								var wasHistoryOn1 = this.turtleHistoryOn;
								this.turtleHistoryOn = false;
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD");
									this.historyParameters.push(baseLength);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD");
									this.turtleParameters.push(baseLength);
								} else {
									var nx = this.x + baseLength * Math.cos(this.rotation);
									var ny = this.y + baseLength * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = baseLength;
										this.lineTo(nx,ny);
									} else {
										var tmp;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp = true;
											break;
										}
										if(tmp) {
											this.contour.end(this.width);
										}
										this.x = nx;
										this.y = ny;
										var l = this.points.length;
										this.points[l] = [];
										this.points[l][0] = nx;
										this.points[l][1] = ny;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d = this.dim[this.dim.length - 1];
										if(nx < d.minX) {
											d.minX = nx;
										}
										if(nx > d.maxX) {
											d.maxX = nx;
										}
										if(ny < d.minY) {
											d.minY = ny;
										}
										if(ny > d.maxY) {
											d.maxY = ny;
										}
										this.contour.reset();
									}
								}
								this.turtleHistoryOn = wasHistoryOn1;
								if(this.fill) {
									arr.push(this.x);
									arr.push(this.y);
								}
							}
							if(this.fill) {
								var cx = (ox + arr[arr.length - 2]) / 2;
								var cy = (oy + arr[arr.length - 1]) / 2;
								var l1 = arr.length;
								var i2 = 2;
								var lx = 0.;
								var ly = 0.;
								this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
								while(i2 < l1) {
									if(i2 > 2) {
										this.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
									}
									lx = arr[i2];
									ly = arr[i2 + 1];
									i2 += 2;
								}
							}
							arr.length = 0;
						}
					}
					j += 2;
					break;
				case "ARCH_BEZIER":
					var distance = v[j];
					var distance2 = v[j + 1];
					var radius1 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("ARCH_BEZIER");
						this.historyParameters.push(distance);
						this.historyParameters.push(distance2);
						this.historyParameters.push(radius1);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("ARCH_BEZIER");
						this.turtleParameters.push(distance);
						this.turtleParameters.push(distance2);
						this.turtleParameters.push(radius1);
					} else {
						var nx1 = this.x + distance * Math.cos(this.rotation);
						var ny1 = this.y + distance * Math.sin(this.rotation);
						if(this.penIsDown) {
							var thruX = this.x + distance2 * Math.cos(this.rotation) - radius1 * Math.cos(this.rotation + Math.PI / 2);
							var thruY = this.y + distance2 * Math.sin(this.rotation) - radius1 * Math.sin(this.rotation + Math.PI / 2);
							var newx = 2 * thruX - 0.5 * (this.x + nx1);
							var newy = 2 * thruY - 0.5 * (this.y + ny1);
							this.tempArr = [];
							var p = this.tempArr;
							var ax = this.x;
							var ay = this.y;
							var x = ax - newx;
							var y = ay - newy;
							var x1 = newx - nx1;
							var y1 = newy - ny1;
							var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
							if(approxDistance == 0) {
								approxDistance = 0.000001;
							}
							var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
							var l2 = p.length;
							p[l2++] = ax;
							p[l2++] = ay;
							var t = step;
							while(t < 1.) {
								var u = 1 - t;
								p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
								var u1 = 1 - t;
								p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
								t += step;
							}
							p[l2++] = nx1;
							p[l2++] = ny1;
							var arr1 = this.tempArr;
							var withMove = false;
							if(withMove == null) {
								withMove = true;
							}
							var l3 = arr1.length;
							var i3 = 2;
							if(withMove) {
								var x_ = arr1[0];
								var y_ = arr1[1];
								var tmp1;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp1 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp1 = true;
									break;
								}
								if(tmp1) {
									this.contour.end(this.width);
								}
								this.x = x_;
								this.y = y_;
								var l4 = this.points.length;
								this.points[l4] = [];
								this.points[l4][0] = x_;
								this.points[l4][1] = y_;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d1 = this.dim[this.dim.length - 1];
								if(x_ < d1.minX) {
									d1.minX = x_;
								}
								if(x_ > d1.maxX) {
									d1.maxX = x_;
								}
								if(y_ < d1.minY) {
									d1.minY = y_;
								}
								if(y_ > d1.maxY) {
									d1.maxY = y_;
								}
								this.contour.reset();
							} else {
								this.lineTo(arr1[0],arr1[1]);
							}
							var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
							var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
							var ox1 = this.x;
							var oy1 = this.y;
							while(i3 < l3) {
								if(this.fill && this.penIsDown) {
									if(i3 > 0 && i3 < l3 - 2) {
										this.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
									}
								}
								this.lineTo(arr1[i3],arr1[i3 + 1]);
								i3 += 2;
							}
							if(this.fill && this.penIsDown) {
								var tmp2;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp2 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp2 = true;
									break;
								}
								if(tmp2) {
									this.contour.end(this.width);
								}
								this.x = ox1;
								this.y = oy1;
								var l5 = this.points.length;
								this.points[l5] = [];
								this.points[l5][0] = ox1;
								this.points[l5][1] = oy1;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d2 = this.dim[this.dim.length - 1];
								if(ox1 < d2.minX) {
									d2.minX = ox1;
								}
								if(ox1 > d2.maxX) {
									d2.maxX = ox1;
								}
								if(oy1 < d2.minY) {
									d2.minY = oy1;
								}
								if(oy1 > d2.maxY) {
									d2.maxY = oy1;
								}
								this.contour.reset();
								this.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
							}
							this.x = nx1;
							this.y = ny1;
						} else {
							var tmp3;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp3 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp3 = true;
								break;
							}
							if(tmp3) {
								this.contour.end(this.width);
							}
							this.x = nx1;
							this.y = ny1;
							var l6 = this.points.length;
							this.points[l6] = [];
							this.points[l6][0] = nx1;
							this.points[l6][1] = ny1;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d3 = this.dim[this.dim.length - 1];
							if(nx1 < d3.minX) {
								d3.minX = nx1;
							}
							if(nx1 > d3.maxX) {
								d3.maxX = nx1;
							}
							if(ny1 < d3.minY) {
								d3.minY = ny1;
							}
							if(ny1 > d3.maxY) {
								d3.maxY = ny1;
							}
							this.contour.reset();
						}
					}
					j += 3;
					break;
				case "ARC_SIDES":
					var radius2 = v[j];
					var degrees1 = v[j + 1];
					var sides = v[j + 2];
					if(sides == null) {
						sides = 24;
					}
					if(this.turtleHistoryOn) {
						if(sides == 24) {
							this.historyAdd("ARC");
							this.historyParameters.push(radius2);
							this.historyParameters.push(degrees1);
						} else {
							this.historyAdd("ARC_SIDES");
							this.historyParameters.push(radius2);
							this.historyParameters.push(degrees1);
							this.historyParameters.push(sides);
						}
					}
					if(radius2 != 0) {
						if(this.repeatCommands) {
							if(sides == 24) {
								this.turtleCommands.push("ARC");
								this.turtleParameters.push(radius2);
								this.turtleParameters.push(degrees1);
							} else {
								this.turtleCommands.push("ARC_SIDES");
								this.turtleParameters.push(radius2);
								this.turtleParameters.push(degrees1);
								this.turtleParameters.push(sides);
							}
						} else {
							var beta1 = degrees1 * Math.PI / 180 / sides;
							var alpha1 = (Math.PI - beta1) / 2;
							var rotate1 = -(Math.PI / 2 - alpha1);
							var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
							var ox2 = this.x;
							var oy2 = this.y;
							var arr2 = [];
							arr2.push(this.x);
							arr2.push(this.y);
							var _g5 = 0;
							while(_g5 < 48) {
								var i4 = _g5++;
								this.rotation += rotate1;
								var wasHistoryOn2 = this.turtleHistoryOn;
								this.turtleHistoryOn = false;
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD");
									this.historyParameters.push(baseLength1);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD");
									this.turtleParameters.push(baseLength1);
								} else {
									var nx2 = this.x + baseLength1 * Math.cos(this.rotation);
									var ny2 = this.y + baseLength1 * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = baseLength1;
										this.lineTo(nx2,ny2);
									} else {
										var tmp4;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp4 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp4 = true;
											break;
										}
										if(tmp4) {
											this.contour.end(this.width);
										}
										this.x = nx2;
										this.y = ny2;
										var l7 = this.points.length;
										this.points[l7] = [];
										this.points[l7][0] = nx2;
										this.points[l7][1] = ny2;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d4 = this.dim[this.dim.length - 1];
										if(nx2 < d4.minX) {
											d4.minX = nx2;
										}
										if(nx2 > d4.maxX) {
											d4.maxX = nx2;
										}
										if(ny2 < d4.minY) {
											d4.minY = ny2;
										}
										if(ny2 > d4.maxY) {
											d4.maxY = ny2;
										}
										this.contour.reset();
									}
								}
								this.turtleHistoryOn = wasHistoryOn2;
								if(this.fill) {
									arr2.push(this.x);
									arr2.push(this.y);
								}
							}
							if(this.fill) {
								var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
								var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
								var l8 = arr2.length;
								var i5 = 2;
								var lx1 = 0.;
								var ly1 = 0.;
								this.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
								while(i5 < l8) {
									if(i5 > 2) {
										this.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
									}
									lx1 = arr2[i5];
									ly1 = arr2[i5 + 1];
									i5 += 2;
								}
							}
							arr2.length = 0;
						}
					}
					j += 3;
					break;
				case "BACKWARD":
					var distance1 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("BACKWARD");
						this.historyParameters.push(distance1);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("BACKWARD");
						this.turtleParameters.push(distance1);
					} else {
						var nx3 = this.x + distance1 * Math.cos(this.rotation + Math.PI);
						var ny3 = this.y + distance1 * Math.sin(this.rotation + Math.PI);
						if(this.penIsDown) {
							this.lineTo(nx3,ny3);
						} else {
							var tmp5;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp5 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp5 = true;
								break;
							}
							if(tmp5) {
								this.contour.end(this.width);
							}
							this.x = nx3;
							this.y = ny3;
							var l9 = this.points.length;
							this.points[l9] = [];
							this.points[l9][0] = nx3;
							this.points[l9][1] = ny3;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d5 = this.dim[this.dim.length - 1];
							if(nx3 < d5.minX) {
								d5.minX = nx3;
							}
							if(nx3 > d5.maxX) {
								d5.maxX = nx3;
							}
							if(ny3 < d5.minY) {
								d5.minY = ny3;
							}
							if(ny3 > d5.maxY) {
								d5.maxY = ny3;
							}
							this.contour.reset();
						}
					}
					++j;
					break;
				case "BEGIN_REPEAT":
					break;
				case "BLACK":
					if(this.turtleHistoryOn) {
						this.historyAdd("BLACK");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("BLACK");
					} else {
						this.pen.currentColor = -16777216;
					}
					break;
				case "BLUE":
					if(this.turtleHistoryOn) {
						this.historyAdd("BLUE");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("BLUE");
					} else {
						this.pen.currentColor = -16776961;
					}
					break;
				case "BROWN":
					if(this.turtleHistoryOn) {
						this.historyAdd("BROWN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("BROWN");
					} else {
						this.pen.currentColor = -6594501;
					}
					break;
				case "CIRCLE":
					var radius3 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("CIRCLE");
						this.historyParameters.push(radius3);
					}
					if(radius3 != 0) {
						if(this.repeatCommands) {
							this.turtleCommands.push("CIRCLE");
							this.turtleParameters.push(radius3);
						} else {
							var beta2 = 2 * Math.PI / 24;
							var alpha2 = (Math.PI - beta2) / 2;
							var rotate2 = -(Math.PI / 2 - alpha2);
							var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
							var ox3 = this.x;
							var oy3 = this.y;
							var arr3 = [];
							var _g6 = 0;
							while(_g6 < 48) {
								var i6 = _g6++;
								this.rotation += rotate2;
								var wasHistoryOn3 = this.turtleHistoryOn;
								this.turtleHistoryOn = false;
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD");
									this.historyParameters.push(baseLength2);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD");
									this.turtleParameters.push(baseLength2);
								} else {
									var nx4 = this.x + baseLength2 * Math.cos(this.rotation);
									var ny4 = this.y + baseLength2 * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = baseLength2;
										this.lineTo(nx4,ny4);
									} else {
										var tmp6;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp6 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp6 = true;
											break;
										}
										if(tmp6) {
											this.contour.end(this.width);
										}
										this.x = nx4;
										this.y = ny4;
										var l10 = this.points.length;
										this.points[l10] = [];
										this.points[l10][0] = nx4;
										this.points[l10][1] = ny4;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d6 = this.dim[this.dim.length - 1];
										if(nx4 < d6.minX) {
											d6.minX = nx4;
										}
										if(nx4 > d6.maxX) {
											d6.maxX = nx4;
										}
										if(ny4 < d6.minY) {
											d6.minY = ny4;
										}
										if(ny4 > d6.maxY) {
											d6.maxY = ny4;
										}
										this.contour.reset();
									}
								}
								this.turtleHistoryOn = wasHistoryOn3;
								if(this.fill) {
									arr3.push(this.x);
									arr3.push(this.y);
								}
							}
							if(this.fill) {
								var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
								var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
								var l11 = arr3.length;
								var i7 = 2;
								var lx2 = 0.;
								var ly2 = 0.;
								while(i7 < l11) {
									if(i7 > 2) {
										this.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
									}
									lx2 = arr3[i7];
									ly2 = arr3[i7 + 1];
									i7 += 2;
								}
							}
							arr3.length = 0;
						}
					}
					++j;
					break;
				case "CIRCLE_SIDES":
					var radius4 = v[j];
					var sides1 = v[j + 1];
					if(sides1 == null) {
						sides1 = 24;
					}
					if(this.turtleHistoryOn) {
						if(sides1 == 24) {
							this.historyAdd("CIRCLE");
							this.historyParameters.push(radius4);
						} else {
							this.historyAdd("CIRCLE_SIDES");
							this.historyParameters.push(radius4);
							this.historyParameters.push(sides1);
						}
					}
					if(radius4 != 0) {
						if(this.repeatCommands) {
							if(sides1 == 24) {
								this.turtleCommands.push("CIRCLE");
								this.turtleParameters.push(radius4);
							} else {
								this.turtleCommands.push("CIRCLE_SIDES");
								this.turtleParameters.push(radius4);
								this.turtleParameters.push(sides1);
							}
						} else {
							var beta3 = 2 * Math.PI / sides1;
							var alpha3 = (Math.PI - beta3) / 2;
							var rotate3 = -(Math.PI / 2 - alpha3);
							var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
							var ox4 = this.x;
							var oy4 = this.y;
							var arr4 = [];
							var _g7 = 0;
							while(_g7 < 48) {
								var i8 = _g7++;
								this.rotation += rotate3;
								var wasHistoryOn4 = this.turtleHistoryOn;
								this.turtleHistoryOn = false;
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD");
									this.historyParameters.push(baseLength3);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD");
									this.turtleParameters.push(baseLength3);
								} else {
									var nx5 = this.x + baseLength3 * Math.cos(this.rotation);
									var ny5 = this.y + baseLength3 * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = baseLength3;
										this.lineTo(nx5,ny5);
									} else {
										var tmp7;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp7 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp7 = true;
											break;
										}
										if(tmp7) {
											this.contour.end(this.width);
										}
										this.x = nx5;
										this.y = ny5;
										var l12 = this.points.length;
										this.points[l12] = [];
										this.points[l12][0] = nx5;
										this.points[l12][1] = ny5;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d7 = this.dim[this.dim.length - 1];
										if(nx5 < d7.minX) {
											d7.minX = nx5;
										}
										if(nx5 > d7.maxX) {
											d7.maxX = nx5;
										}
										if(ny5 < d7.minY) {
											d7.minY = ny5;
										}
										if(ny5 > d7.maxY) {
											d7.maxY = ny5;
										}
										this.contour.reset();
									}
								}
								this.turtleHistoryOn = wasHistoryOn4;
								if(this.fill) {
									arr4.push(this.x);
									arr4.push(this.y);
								}
							}
							if(this.fill) {
								var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
								var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
								var l13 = arr4.length;
								var i9 = 2;
								var lx3 = 0.;
								var ly3 = 0.;
								while(i9 < l13) {
									if(i9 > 2) {
										this.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
									}
									lx3 = arr4[i9];
									ly3 = arr4[i9 + 1];
									i9 += 2;
								}
							}
							arr4.length = 0;
						}
					}
					j += 2;
					break;
				case "CYAN":
					if(this.turtleHistoryOn) {
						this.historyAdd("CYAN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("CYAN");
					} else {
						this.pen.currentColor = -16711681;
					}
					break;
				case "DARKISH_BLUE":
					if(this.turtleHistoryOn) {
						this.historyAdd("DARKISH_BLUE");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("DARKISH_BLUE");
					} else {
						this.pen.currentColor = -8864837;
					}
					break;
				case "DARK_GREEN":
					if(this.turtleHistoryOn) {
						this.historyAdd("DARK_GREEN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("DARK_GREEN");
					} else {
						this.pen.currentColor = -10182080;
					}
					break;
				case "EAST":
					if(this.turtleHistoryOn) {
						this.historyAdd("WEST");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("EAST");
					} else {
						this.rotation = Math.PI;
					}
					break;
				case "END_REPEAT":
					break;
				case "FILL_OFF":
					if(this.turtleHistoryOn) {
						this.historyAdd("FILL_OFF");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FILL_OFF");
					} else {
						this.fill = false;
					}
					break;
				case "FILL_ON":
					if(this.turtleHistoryOn) {
						this.historyAdd("FILL_ON");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FILL_ON");
					} else {
						this.fill = true;
					}
					break;
				case "FORWARD":
					var distance3 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("FORWARD");
						this.historyParameters.push(distance3);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FORWARD");
						this.turtleParameters.push(distance3);
					} else {
						var nx6 = this.x + distance3 * Math.cos(this.rotation);
						var ny6 = this.y + distance3 * Math.sin(this.rotation);
						if(this.penIsDown) {
							this.lastDistance = distance3;
							this.lineTo(nx6,ny6);
						} else {
							var tmp8;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp8 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp8 = true;
								break;
							}
							if(tmp8) {
								this.contour.end(this.width);
							}
							this.x = nx6;
							this.y = ny6;
							var l14 = this.points.length;
							this.points[l14] = [];
							this.points[l14][0] = nx6;
							this.points[l14][1] = ny6;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d8 = this.dim[this.dim.length - 1];
							if(nx6 < d8.minX) {
								d8.minX = nx6;
							}
							if(nx6 > d8.maxX) {
								d8.maxX = nx6;
							}
							if(ny6 < d8.minY) {
								d8.minY = ny6;
							}
							if(ny6 > d8.maxY) {
								d8.maxY = ny6;
							}
							this.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_CHANGE":
					var deltaDistance = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("FORWARD_CHANGE");
						this.historyParameters.push(deltaDistance);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FORWARD_CHANGE");
						this.turtleParameters.push(deltaDistance);
					} else {
						var distance4 = this.lastDistance + deltaDistance;
						var nx7 = this.x + distance4 * Math.cos(this.rotation);
						var ny7 = this.y + distance4 * Math.sin(this.rotation);
						if(this.penIsDown) {
							this.lastDistance = distance4 + deltaDistance;
							this.lineTo(nx7,ny7);
						} else {
							var tmp9;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp9 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp9 = true;
								break;
							}
							if(tmp9) {
								this.contour.end(this.width);
							}
							this.x = nx7;
							this.y = ny7;
							var l15 = this.points.length;
							this.points[l15] = [];
							this.points[l15][0] = nx7;
							this.points[l15][1] = ny7;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d9 = this.dim[this.dim.length - 1];
							if(nx7 < d9.minX) {
								d9.minX = nx7;
							}
							if(nx7 > d9.maxX) {
								d9.maxX = nx7;
							}
							if(ny7 < d9.minY) {
								d9.minY = ny7;
							}
							if(ny7 > d9.maxY) {
								d9.maxY = ny7;
							}
							this.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_FACTOR":
					var factor = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("FORWARD_FACTOR");
						this.historyParameters.push(factor);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FORWARD_FACTOR");
						this.turtleParameters.push(factor);
					} else {
						var distance5 = this.lastDistance * factor;
						var nx8 = this.x + distance5 * Math.cos(this.rotation);
						var ny8 = this.y + distance5 * Math.sin(this.rotation);
						if(this.penIsDown) {
							this.lastDistance = distance5;
							this.lineTo(nx8,ny8);
						} else {
							var tmp10;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp10 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp10 = true;
								break;
							}
							if(tmp10) {
								this.contour.end(this.width);
							}
							this.x = nx8;
							this.y = ny8;
							var l16 = this.points.length;
							this.points[l16] = [];
							this.points[l16][0] = nx8;
							this.points[l16][1] = ny8;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d10 = this.dim[this.dim.length - 1];
							if(nx8 < d10.minX) {
								d10.minX = nx8;
							}
							if(nx8 > d10.maxX) {
								d10.maxX = nx8;
							}
							if(ny8 < d10.minY) {
								d10.minY = ny8;
							}
							if(ny8 > d10.maxY) {
								d10.maxY = ny8;
							}
							this.contour.reset();
						}
					}
					++j;
					break;
				case "GREEN":
					if(this.turtleHistoryOn) {
						this.historyAdd("GREEN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("GREEN");
					} else {
						this.pen.currentColor = -16711936;
					}
					break;
				case "GREY":
					if(this.turtleHistoryOn) {
						this.historyAdd("GREY");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("GREY");
					} else {
						this.pen.currentColor = -4737097;
					}
					break;
				case "LEFT":
					var degrees2 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("LEFT");
						this.historyParameters.push(degrees2);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("LEFT");
						this.turtleParameters.push(degrees2);
					} else {
						this.rotation -= degrees2 * Math.PI / 180;
					}
					++j;
					break;
				case "LIGHT_BROWN":
					if(this.turtleHistoryOn) {
						this.historyAdd("LIGHT_BROWN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("LIGHT_BROWN");
					} else {
						this.pen.currentColor = -3831790;
					}
					break;
				case "LINE_STYLE":
					var thickness = v[j];
					var color = v[j + 1];
					if(this.turtleHistoryOn) {
						this.historyAdd("LINE_STYLE");
						this.historyParameters.push(thickness);
						this.historyParameters.push(color);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("LINE_STYLE");
						this.historyParameters.push(thickness);
						this.historyParameters.push(color);
					} else {
						this.width = thickness;
						this.pen.currentColor = color | 0;
					}
					j += 2;
					break;
				case "MAGENTA":
					if(this.turtleHistoryOn) {
						this.historyAdd("MAGENTA");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("MAGENTA");
					} else {
						this.pen.currentColor = -65281;
					}
					break;
				case "MOVE_PEN":
					var distance6 = v[j];
					if(this.repeatCommands) {
						this.turtleCommands.push("MOVE_PEN");
						this.turtleParameters.push(distance6);
					} else if(this.penIsDown) {
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_UP");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_UP");
						} else {
							this.penIsDown = false;
						}
						if(this.turtleHistoryOn) {
							this.historyAdd("FORWARD");
							this.historyParameters.push(distance6);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FORWARD");
							this.turtleParameters.push(distance6);
						} else {
							var nx9 = this.x + distance6 * Math.cos(this.rotation);
							var ny9 = this.y + distance6 * Math.sin(this.rotation);
							if(this.penIsDown) {
								this.lastDistance = distance6;
								this.lineTo(nx9,ny9);
							} else {
								var tmp11;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp11 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp11 = true;
									break;
								}
								if(tmp11) {
									this.contour.end(this.width);
								}
								this.x = nx9;
								this.y = ny9;
								var l17 = this.points.length;
								this.points[l17] = [];
								this.points[l17][0] = nx9;
								this.points[l17][1] = ny9;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d11 = this.dim[this.dim.length - 1];
								if(nx9 < d11.minX) {
									d11.minX = nx9;
								}
								if(nx9 > d11.maxX) {
									d11.maxX = nx9;
								}
								if(ny9 < d11.minY) {
									d11.minY = ny9;
								}
								if(ny9 > d11.maxY) {
									d11.maxY = ny9;
								}
								this.contour.reset();
							}
						}
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_DOWN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_DOWN");
						} else {
							this.penIsDown = true;
						}
					} else {
						if(this.turtleHistoryOn) {
							this.historyAdd("FORWARD");
							this.historyParameters.push(distance6);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FORWARD");
							this.turtleParameters.push(distance6);
						} else {
							var nx10 = this.x + distance6 * Math.cos(this.rotation);
							var ny10 = this.y + distance6 * Math.sin(this.rotation);
							if(this.penIsDown) {
								this.lastDistance = distance6;
								this.lineTo(nx10,ny10);
							} else {
								var tmp12;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp12 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp12 = true;
									break;
								}
								if(tmp12) {
									this.contour.end(this.width);
								}
								this.x = nx10;
								this.y = ny10;
								var l18 = this.points.length;
								this.points[l18] = [];
								this.points[l18][0] = nx10;
								this.points[l18][1] = ny10;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d12 = this.dim[this.dim.length - 1];
								if(nx10 < d12.minX) {
									d12.minX = nx10;
								}
								if(nx10 > d12.maxX) {
									d12.maxX = nx10;
								}
								if(ny10 < d12.minY) {
									d12.minY = ny10;
								}
								if(ny10 > d12.maxY) {
									d12.maxY = ny10;
								}
								this.contour.reset();
							}
						}
					}
					++j;
					break;
				case "NORTH":
					if(this.turtleHistoryOn) {
						this.historyAdd("NORTH");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("NORTH");
					} else {
						this.rotation = -Math.PI / 2;
					}
					break;
				case "ORANGE":
					if(this.turtleHistoryOn) {
						this.historyAdd("ORANGE");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("ORANGE");
					} else {
						this.pen.currentColor = -23808;
					}
					break;
				case "PEN_COLOR":
					var r = v[j];
					var g = v[j + 1];
					var b = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_COLOR");
						this.historyParameters.push(r);
						this.historyParameters.push(g);
						this.historyParameters.push(b);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_COLOR");
						this.turtleParameters.push(r);
						this.turtleParameters.push(g);
						this.turtleParameters.push(b);
					} else {
						this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_B":
					var r1 = v[j];
					var g1 = v[j + 1];
					var b1 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_COLOR_B");
						this.historyParameters.push(r1);
						this.historyParameters.push(g1);
						this.historyParameters.push(b1);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_COLOR_B");
						this.turtleParameters.push(r1);
						this.turtleParameters.push(g1);
						this.turtleParameters.push(b1);
					} else {
						this.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_C":
					var r2 = v[j];
					var g2 = v[j + 1];
					var b2 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_COLOR_C");
						this.historyParameters.push(r2);
						this.historyParameters.push(g2);
						this.historyParameters.push(b2);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_COLOR_C");
						this.turtleParameters.push(r2);
						this.turtleParameters.push(g2);
						this.turtleParameters.push(b2);
					} else {
						this.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE":
					var r3 = v[j];
					var g3 = v[j + 1];
					var b3 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_COLOR_CHANGE");
						this.historyParameters.push(r3);
						this.historyParameters.push(g3);
						this.historyParameters.push(b3);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_COLOR_CHANGE");
						this.turtleParameters.push(r3);
						this.turtleParameters.push(g3);
						this.turtleParameters.push(b3);
					} else {
						var c = this.pen.currentColor;
						var r0 = (c >> 16 & 255) / 255;
						var g0 = (c >> 8 & 255) / 255;
						var b0 = (c & 255) / 255;
						this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_B":
					var r4 = v[j];
					var g4 = v[j + 1];
					var b4 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_COLOR_CHANGE_B");
						this.historyParameters.push(r4);
						this.historyParameters.push(g4);
						this.historyParameters.push(b4);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_COLOR_CHANGE_B");
						this.turtleParameters.push(r4);
						this.turtleParameters.push(g4);
						this.turtleParameters.push(b4);
					} else {
						var c1 = this.pen.colorB;
						var r01 = (c1 >> 16 & 255) / 255;
						var g01 = (c1 >> 8 & 255) / 255;
						var b01 = (c1 & 255) / 255;
						this.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_C":
					var r5 = v[j];
					var g5 = v[j + 1];
					var b5 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_COLOR_CHANGE_C");
						this.historyParameters.push(r5);
						this.historyParameters.push(g5);
						this.historyParameters.push(b5);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_COLOR_CHANGE_C");
						this.turtleParameters.push(r5);
						this.turtleParameters.push(g5);
						this.turtleParameters.push(b5);
					} else {
						var c2 = this.pen.colorC;
						var r02 = (c2 >> 16 & 255) / 255;
						var g02 = (c2 >> 8 & 255) / 255;
						var b02 = (c2 & 255) / 255;
						this.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
					}
					j += 3;
					break;
				case "PEN_DOWN":
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_DOWN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_DOWN");
					} else {
						this.penIsDown = true;
					}
					break;
				case "PEN_SIZE":
					var w = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_SIZE");
						this.historyParameters.push(w);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_SIZE");
						this.turtleParameters.push(w);
					} else {
						this.width = w;
					}
					++j;
					break;
				case "PEN_SIZE_CHANGE":
					var dw = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_SIZE_CHANGE");
						this.historyParameters.push(dw);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_SIZE_CHANGE");
						this.turtleParameters.push(dw);
					} else {
						this.width += dw;
					}
					++j;
					break;
				case "PEN_SIZE_FACTOR":
					var factor1 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_SIZE_FACTOR");
						this.historyParameters.push(factor1);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_SIZE_FACTOR");
						this.turtleParameters.push(factor1);
					} else {
						this.width *= factor1;
					}
					++j;
					break;
				case "PEN_UP":
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_UP");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_UP");
					} else {
						this.penIsDown = false;
					}
					break;
				case "PLUM":
					if(this.turtleHistoryOn) {
						this.historyAdd("PLUM");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PLUM");
					} else {
						this.pen.currentColor = -7310896;
					}
					break;
				case "RED":
					if(this.turtleHistoryOn) {
						this.historyAdd("RED");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("RED");
					} else {
						this.pen.currentColor = -65536;
					}
					break;
				case "RIGHT":
					var degrees3 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("RIGHT");
						this.historyParameters.push(degrees3);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("RIGHT");
						this.turtleParameters.push(degrees3);
					} else {
						this.rotation += degrees3 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_ANGLE":
					var degrees4 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("SET_ANGLE");
						this.historyParameters.push(degrees4);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("SET_ANGLE");
						this.turtleParameters.push(degrees4);
					} else {
						this.rotation = -Math.PI / 2;
						this.rotation += degrees4 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_POSITION":
					var x2 = v[j];
					var y2 = v[j + 1];
					if(this.turtleHistoryOn) {
						this.historyAdd("SET_POSITION");
						this.historyParameters.push(x2);
						this.historyParameters.push(y2);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("SET_POSITION");
						this.turtleParameters.push(x2);
						this.turtleParameters.push(y2);
					} else {
						var tmp13;
						switch(this.endLine) {
						case 0:case 1:case 6:case 9:case 12:case 15:case 18:
							tmp13 = false;
							break;
						case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
							tmp13 = true;
							break;
						}
						if(tmp13) {
							this.contour.end(this.width);
						}
						this.x = x2;
						this.y = y2;
						var l19 = this.points.length;
						this.points[l19] = [];
						this.points[l19][0] = x2;
						this.points[l19][1] = y2;
						this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
						this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
						this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d13 = this.dim[this.dim.length - 1];
						if(x2 < d13.minX) {
							d13.minX = x2;
						}
						if(x2 > d13.maxX) {
							d13.maxX = x2;
						}
						if(y2 < d13.minY) {
							d13.minY = y2;
						}
						if(y2 > d13.maxY) {
							d13.maxY = y2;
						}
						this.contour.reset();
					}
					j += 2;
					break;
				case "SOUTH":
					if(this.turtleHistoryOn) {
						this.historyAdd("SOUTH");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("SOUTH");
					} else {
						this.rotation = Math.PI / 2;
					}
					break;
				case "TAN":
					if(this.turtleHistoryOn) {
						this.historyAdd("TAN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("TAN");
					} else {
						this.pen.currentColor = -27273;
					}
					break;
				case "TRIANGLE_ARCH":
					var distance7 = v[j];
					var distance21 = v[j + 1];
					var radius5 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("TRIANGLE_ARCH");
						this.historyParameters.push(distance7);
						this.historyParameters.push(distance21);
						this.historyParameters.push(radius5);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("TRIANGLE_ARCH");
						this.turtleParameters.push(distance7);
						this.turtleParameters.push(distance21);
						this.turtleParameters.push(radius5);
					} else {
						var nx11 = this.x + distance7 * Math.cos(this.rotation);
						var ny11 = this.y + distance7 * Math.sin(this.rotation);
						if(this.penIsDown) {
							var thruX1 = this.x + distance21 * Math.cos(this.rotation) - radius5 * Math.cos(this.rotation + Math.PI / 2);
							var thruY1 = this.y + distance21 * Math.sin(this.rotation) - radius5 * Math.sin(this.rotation + Math.PI / 2);
							if(this.fill) {
								this.pen.triangle2DFill(this.x,this.y,thruX1,thruY1,nx11,ny11);
							}
							this.lineTo(thruX1,thruY1);
							this.lineTo(nx11,ny11);
							if(this.fill) {
								this.lineTo(this.x,this.y);
							}
							var tmp14;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp14 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp14 = true;
								break;
							}
							if(tmp14) {
								this.contour.end(this.width);
							}
							this.x = nx11;
							this.y = ny11;
							var l20 = this.points.length;
							this.points[l20] = [];
							this.points[l20][0] = nx11;
							this.points[l20][1] = ny11;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d14 = this.dim[this.dim.length - 1];
							if(nx11 < d14.minX) {
								d14.minX = nx11;
							}
							if(nx11 > d14.maxX) {
								d14.maxX = nx11;
							}
							if(ny11 < d14.minY) {
								d14.minY = ny11;
							}
							if(ny11 > d14.maxY) {
								d14.maxY = ny11;
							}
							this.contour.reset();
						} else {
							var tmp15;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp15 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp15 = true;
								break;
							}
							if(tmp15) {
								this.contour.end(this.width);
							}
							this.x = nx11;
							this.y = ny11;
							var l21 = this.points.length;
							this.points[l21] = [];
							this.points[l21][0] = nx11;
							this.points[l21][1] = ny11;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d15 = this.dim[this.dim.length - 1];
							if(nx11 < d15.minX) {
								d15.minX = nx11;
							}
							if(nx11 > d15.maxX) {
								d15.maxX = nx11;
							}
							if(ny11 < d15.minY) {
								d15.minY = ny11;
							}
							if(ny11 > d15.maxY) {
								d15.maxY = ny11;
							}
							this.contour.reset();
						}
					}
					j += 3;
					break;
				case "WEST":
					if(this.turtleHistoryOn) {
						this.historyAdd("WEST");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("WEST");
					} else {
						this.rotation = 0;
					}
					break;
				case "WHITE":
					if(this.turtleHistoryOn) {
						this.historyAdd("WHITE");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("WHITE");
					} else {
						this.pen.currentColor = -1;
					}
					break;
				case "YELLOW":
					if(this.turtleHistoryOn) {
						this.historyAdd("YELLOW");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("YELLOW");
					} else {
						this.pen.currentColor = -256;
					}
					break;
				}
			}
			j = 0;
		}
		this.turtleHistoryOn = wasHistoryOn;
		this.turtleCommands.length = 0;
		this.turtleParameters.length = 0;
		return this;
	}
	,repeatEnd: function() {
		this.repeatCommands = false;
		if(this.turtleHistoryOn) {
			this.historyAdd("END_REPEAT");
		}
		var wasHistoryOn = this.turtleHistoryOn;
		this.turtleHistoryOn = false;
		var v = this.turtleParameters;
		var j = 0;
		var _g = 0;
		var _g1 = this.repeatCount;
		while(_g < _g1) {
			var k = _g++;
			var _g2 = 0;
			var _g3 = this.turtleCommands.length;
			while(_g2 < _g3) {
				var i = _g2++;
				var command = this.turtleCommands[i];
				switch(command) {
				case "ARC":
					var radius = v[j];
					var degrees = v[j + 1];
					if(this.turtleHistoryOn) {
						this.historyAdd("ARC");
						this.historyParameters.push(radius);
						this.historyParameters.push(degrees);
					}
					if(radius != 0) {
						if(this.repeatCommands) {
							this.turtleCommands.push("ARC");
							this.turtleParameters.push(radius);
							this.turtleParameters.push(degrees);
						} else {
							var beta = degrees * Math.PI / 180 / 24;
							var alpha = (Math.PI - beta) / 2;
							var rotate = -(Math.PI / 2 - alpha);
							var baseLength = 0.5 * radius * Math.sin(beta / 2);
							var ox = this.x;
							var oy = this.y;
							var arr = [];
							arr.push(this.x);
							arr.push(this.y);
							var _g4 = 0;
							while(_g4 < 48) {
								var i1 = _g4++;
								this.rotation += rotate;
								var wasHistoryOn1 = this.turtleHistoryOn;
								this.turtleHistoryOn = false;
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD");
									this.historyParameters.push(baseLength);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD");
									this.turtleParameters.push(baseLength);
								} else {
									var nx = this.x + baseLength * Math.cos(this.rotation);
									var ny = this.y + baseLength * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = baseLength;
										this.lineTo(nx,ny);
									} else {
										var tmp;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp = true;
											break;
										}
										if(tmp) {
											this.contour.end(this.width);
										}
										this.x = nx;
										this.y = ny;
										var l = this.points.length;
										this.points[l] = [];
										this.points[l][0] = nx;
										this.points[l][1] = ny;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d = this.dim[this.dim.length - 1];
										if(nx < d.minX) {
											d.minX = nx;
										}
										if(nx > d.maxX) {
											d.maxX = nx;
										}
										if(ny < d.minY) {
											d.minY = ny;
										}
										if(ny > d.maxY) {
											d.maxY = ny;
										}
										this.contour.reset();
									}
								}
								this.turtleHistoryOn = wasHistoryOn1;
								if(this.fill) {
									arr.push(this.x);
									arr.push(this.y);
								}
							}
							if(this.fill) {
								var cx = (ox + arr[arr.length - 2]) / 2;
								var cy = (oy + arr[arr.length - 1]) / 2;
								var l1 = arr.length;
								var i2 = 2;
								var lx = 0.;
								var ly = 0.;
								this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
								while(i2 < l1) {
									if(i2 > 2) {
										this.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
									}
									lx = arr[i2];
									ly = arr[i2 + 1];
									i2 += 2;
								}
							}
							arr.length = 0;
						}
					}
					j += 2;
					break;
				case "ARCH_BEZIER":
					var distance = v[j];
					var distance2 = v[j + 1];
					var radius1 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("ARCH_BEZIER");
						this.historyParameters.push(distance);
						this.historyParameters.push(distance2);
						this.historyParameters.push(radius1);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("ARCH_BEZIER");
						this.turtleParameters.push(distance);
						this.turtleParameters.push(distance2);
						this.turtleParameters.push(radius1);
					} else {
						var nx1 = this.x + distance * Math.cos(this.rotation);
						var ny1 = this.y + distance * Math.sin(this.rotation);
						if(this.penIsDown) {
							var thruX = this.x + distance2 * Math.cos(this.rotation) - radius1 * Math.cos(this.rotation + Math.PI / 2);
							var thruY = this.y + distance2 * Math.sin(this.rotation) - radius1 * Math.sin(this.rotation + Math.PI / 2);
							var newx = 2 * thruX - 0.5 * (this.x + nx1);
							var newy = 2 * thruY - 0.5 * (this.y + ny1);
							this.tempArr = [];
							var p = this.tempArr;
							var ax = this.x;
							var ay = this.y;
							var x = ax - newx;
							var y = ay - newy;
							var x1 = newx - nx1;
							var y1 = newy - ny1;
							var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
							if(approxDistance == 0) {
								approxDistance = 0.000001;
							}
							var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
							var l2 = p.length;
							p[l2++] = ax;
							p[l2++] = ay;
							var t = step;
							while(t < 1.) {
								var u = 1 - t;
								p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
								var u1 = 1 - t;
								p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
								t += step;
							}
							p[l2++] = nx1;
							p[l2++] = ny1;
							var arr1 = this.tempArr;
							var withMove = false;
							if(withMove == null) {
								withMove = true;
							}
							var l3 = arr1.length;
							var i3 = 2;
							if(withMove) {
								var x_ = arr1[0];
								var y_ = arr1[1];
								var tmp1;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp1 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp1 = true;
									break;
								}
								if(tmp1) {
									this.contour.end(this.width);
								}
								this.x = x_;
								this.y = y_;
								var l4 = this.points.length;
								this.points[l4] = [];
								this.points[l4][0] = x_;
								this.points[l4][1] = y_;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d1 = this.dim[this.dim.length - 1];
								if(x_ < d1.minX) {
									d1.minX = x_;
								}
								if(x_ > d1.maxX) {
									d1.maxX = x_;
								}
								if(y_ < d1.minY) {
									d1.minY = y_;
								}
								if(y_ > d1.maxY) {
									d1.maxY = y_;
								}
								this.contour.reset();
							} else {
								this.lineTo(arr1[0],arr1[1]);
							}
							var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
							var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
							var ox1 = this.x;
							var oy1 = this.y;
							while(i3 < l3) {
								if(this.fill && this.penIsDown) {
									if(i3 > 0 && i3 < l3 - 2) {
										this.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
									}
								}
								this.lineTo(arr1[i3],arr1[i3 + 1]);
								i3 += 2;
							}
							if(this.fill && this.penIsDown) {
								var tmp2;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp2 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp2 = true;
									break;
								}
								if(tmp2) {
									this.contour.end(this.width);
								}
								this.x = ox1;
								this.y = oy1;
								var l5 = this.points.length;
								this.points[l5] = [];
								this.points[l5][0] = ox1;
								this.points[l5][1] = oy1;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d2 = this.dim[this.dim.length - 1];
								if(ox1 < d2.minX) {
									d2.minX = ox1;
								}
								if(ox1 > d2.maxX) {
									d2.maxX = ox1;
								}
								if(oy1 < d2.minY) {
									d2.minY = oy1;
								}
								if(oy1 > d2.maxY) {
									d2.maxY = oy1;
								}
								this.contour.reset();
								this.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
							}
							this.x = nx1;
							this.y = ny1;
						} else {
							var tmp3;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp3 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp3 = true;
								break;
							}
							if(tmp3) {
								this.contour.end(this.width);
							}
							this.x = nx1;
							this.y = ny1;
							var l6 = this.points.length;
							this.points[l6] = [];
							this.points[l6][0] = nx1;
							this.points[l6][1] = ny1;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d3 = this.dim[this.dim.length - 1];
							if(nx1 < d3.minX) {
								d3.minX = nx1;
							}
							if(nx1 > d3.maxX) {
								d3.maxX = nx1;
							}
							if(ny1 < d3.minY) {
								d3.minY = ny1;
							}
							if(ny1 > d3.maxY) {
								d3.maxY = ny1;
							}
							this.contour.reset();
						}
					}
					j += 3;
					break;
				case "ARC_SIDES":
					var radius2 = v[j];
					var degrees1 = v[j + 1];
					var sides = v[j + 2];
					if(sides == null) {
						sides = 24;
					}
					if(this.turtleHistoryOn) {
						if(sides == 24) {
							this.historyAdd("ARC");
							this.historyParameters.push(radius2);
							this.historyParameters.push(degrees1);
						} else {
							this.historyAdd("ARC_SIDES");
							this.historyParameters.push(radius2);
							this.historyParameters.push(degrees1);
							this.historyParameters.push(sides);
						}
					}
					if(radius2 != 0) {
						if(this.repeatCommands) {
							if(sides == 24) {
								this.turtleCommands.push("ARC");
								this.turtleParameters.push(radius2);
								this.turtleParameters.push(degrees1);
							} else {
								this.turtleCommands.push("ARC_SIDES");
								this.turtleParameters.push(radius2);
								this.turtleParameters.push(degrees1);
								this.turtleParameters.push(sides);
							}
						} else {
							var beta1 = degrees1 * Math.PI / 180 / sides;
							var alpha1 = (Math.PI - beta1) / 2;
							var rotate1 = -(Math.PI / 2 - alpha1);
							var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
							var ox2 = this.x;
							var oy2 = this.y;
							var arr2 = [];
							arr2.push(this.x);
							arr2.push(this.y);
							var _g5 = 0;
							while(_g5 < 48) {
								var i4 = _g5++;
								this.rotation += rotate1;
								var wasHistoryOn2 = this.turtleHistoryOn;
								this.turtleHistoryOn = false;
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD");
									this.historyParameters.push(baseLength1);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD");
									this.turtleParameters.push(baseLength1);
								} else {
									var nx2 = this.x + baseLength1 * Math.cos(this.rotation);
									var ny2 = this.y + baseLength1 * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = baseLength1;
										this.lineTo(nx2,ny2);
									} else {
										var tmp4;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp4 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp4 = true;
											break;
										}
										if(tmp4) {
											this.contour.end(this.width);
										}
										this.x = nx2;
										this.y = ny2;
										var l7 = this.points.length;
										this.points[l7] = [];
										this.points[l7][0] = nx2;
										this.points[l7][1] = ny2;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d4 = this.dim[this.dim.length - 1];
										if(nx2 < d4.minX) {
											d4.minX = nx2;
										}
										if(nx2 > d4.maxX) {
											d4.maxX = nx2;
										}
										if(ny2 < d4.minY) {
											d4.minY = ny2;
										}
										if(ny2 > d4.maxY) {
											d4.maxY = ny2;
										}
										this.contour.reset();
									}
								}
								this.turtleHistoryOn = wasHistoryOn2;
								if(this.fill) {
									arr2.push(this.x);
									arr2.push(this.y);
								}
							}
							if(this.fill) {
								var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
								var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
								var l8 = arr2.length;
								var i5 = 2;
								var lx1 = 0.;
								var ly1 = 0.;
								this.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
								while(i5 < l8) {
									if(i5 > 2) {
										this.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
									}
									lx1 = arr2[i5];
									ly1 = arr2[i5 + 1];
									i5 += 2;
								}
							}
							arr2.length = 0;
						}
					}
					j += 3;
					break;
				case "BACKWARD":
					var distance1 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("BACKWARD");
						this.historyParameters.push(distance1);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("BACKWARD");
						this.turtleParameters.push(distance1);
					} else {
						var nx3 = this.x + distance1 * Math.cos(this.rotation + Math.PI);
						var ny3 = this.y + distance1 * Math.sin(this.rotation + Math.PI);
						if(this.penIsDown) {
							this.lineTo(nx3,ny3);
						} else {
							var tmp5;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp5 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp5 = true;
								break;
							}
							if(tmp5) {
								this.contour.end(this.width);
							}
							this.x = nx3;
							this.y = ny3;
							var l9 = this.points.length;
							this.points[l9] = [];
							this.points[l9][0] = nx3;
							this.points[l9][1] = ny3;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d5 = this.dim[this.dim.length - 1];
							if(nx3 < d5.minX) {
								d5.minX = nx3;
							}
							if(nx3 > d5.maxX) {
								d5.maxX = nx3;
							}
							if(ny3 < d5.minY) {
								d5.minY = ny3;
							}
							if(ny3 > d5.maxY) {
								d5.maxY = ny3;
							}
							this.contour.reset();
						}
					}
					++j;
					break;
				case "BEGIN_REPEAT":
					break;
				case "BLACK":
					if(this.turtleHistoryOn) {
						this.historyAdd("BLACK");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("BLACK");
					} else {
						this.pen.currentColor = -16777216;
					}
					break;
				case "BLUE":
					if(this.turtleHistoryOn) {
						this.historyAdd("BLUE");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("BLUE");
					} else {
						this.pen.currentColor = -16776961;
					}
					break;
				case "BROWN":
					if(this.turtleHistoryOn) {
						this.historyAdd("BROWN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("BROWN");
					} else {
						this.pen.currentColor = -6594501;
					}
					break;
				case "CIRCLE":
					var radius3 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("CIRCLE");
						this.historyParameters.push(radius3);
					}
					if(radius3 != 0) {
						if(this.repeatCommands) {
							this.turtleCommands.push("CIRCLE");
							this.turtleParameters.push(radius3);
						} else {
							var beta2 = 2 * Math.PI / 24;
							var alpha2 = (Math.PI - beta2) / 2;
							var rotate2 = -(Math.PI / 2 - alpha2);
							var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
							var ox3 = this.x;
							var oy3 = this.y;
							var arr3 = [];
							var _g6 = 0;
							while(_g6 < 48) {
								var i6 = _g6++;
								this.rotation += rotate2;
								var wasHistoryOn3 = this.turtleHistoryOn;
								this.turtleHistoryOn = false;
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD");
									this.historyParameters.push(baseLength2);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD");
									this.turtleParameters.push(baseLength2);
								} else {
									var nx4 = this.x + baseLength2 * Math.cos(this.rotation);
									var ny4 = this.y + baseLength2 * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = baseLength2;
										this.lineTo(nx4,ny4);
									} else {
										var tmp6;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp6 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp6 = true;
											break;
										}
										if(tmp6) {
											this.contour.end(this.width);
										}
										this.x = nx4;
										this.y = ny4;
										var l10 = this.points.length;
										this.points[l10] = [];
										this.points[l10][0] = nx4;
										this.points[l10][1] = ny4;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d6 = this.dim[this.dim.length - 1];
										if(nx4 < d6.minX) {
											d6.minX = nx4;
										}
										if(nx4 > d6.maxX) {
											d6.maxX = nx4;
										}
										if(ny4 < d6.minY) {
											d6.minY = ny4;
										}
										if(ny4 > d6.maxY) {
											d6.maxY = ny4;
										}
										this.contour.reset();
									}
								}
								this.turtleHistoryOn = wasHistoryOn3;
								if(this.fill) {
									arr3.push(this.x);
									arr3.push(this.y);
								}
							}
							if(this.fill) {
								var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
								var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
								var l11 = arr3.length;
								var i7 = 2;
								var lx2 = 0.;
								var ly2 = 0.;
								while(i7 < l11) {
									if(i7 > 2) {
										this.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
									}
									lx2 = arr3[i7];
									ly2 = arr3[i7 + 1];
									i7 += 2;
								}
							}
							arr3.length = 0;
						}
					}
					++j;
					break;
				case "CIRCLE_SIDES":
					var radius4 = v[j];
					var sides1 = v[j + 1];
					if(sides1 == null) {
						sides1 = 24;
					}
					if(this.turtleHistoryOn) {
						if(sides1 == 24) {
							this.historyAdd("CIRCLE");
							this.historyParameters.push(radius4);
						} else {
							this.historyAdd("CIRCLE_SIDES");
							this.historyParameters.push(radius4);
							this.historyParameters.push(sides1);
						}
					}
					if(radius4 != 0) {
						if(this.repeatCommands) {
							if(sides1 == 24) {
								this.turtleCommands.push("CIRCLE");
								this.turtleParameters.push(radius4);
							} else {
								this.turtleCommands.push("CIRCLE_SIDES");
								this.turtleParameters.push(radius4);
								this.turtleParameters.push(sides1);
							}
						} else {
							var beta3 = 2 * Math.PI / sides1;
							var alpha3 = (Math.PI - beta3) / 2;
							var rotate3 = -(Math.PI / 2 - alpha3);
							var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
							var ox4 = this.x;
							var oy4 = this.y;
							var arr4 = [];
							var _g7 = 0;
							while(_g7 < 48) {
								var i8 = _g7++;
								this.rotation += rotate3;
								var wasHistoryOn4 = this.turtleHistoryOn;
								this.turtleHistoryOn = false;
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD");
									this.historyParameters.push(baseLength3);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD");
									this.turtleParameters.push(baseLength3);
								} else {
									var nx5 = this.x + baseLength3 * Math.cos(this.rotation);
									var ny5 = this.y + baseLength3 * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = baseLength3;
										this.lineTo(nx5,ny5);
									} else {
										var tmp7;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp7 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp7 = true;
											break;
										}
										if(tmp7) {
											this.contour.end(this.width);
										}
										this.x = nx5;
										this.y = ny5;
										var l12 = this.points.length;
										this.points[l12] = [];
										this.points[l12][0] = nx5;
										this.points[l12][1] = ny5;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d7 = this.dim[this.dim.length - 1];
										if(nx5 < d7.minX) {
											d7.minX = nx5;
										}
										if(nx5 > d7.maxX) {
											d7.maxX = nx5;
										}
										if(ny5 < d7.minY) {
											d7.minY = ny5;
										}
										if(ny5 > d7.maxY) {
											d7.maxY = ny5;
										}
										this.contour.reset();
									}
								}
								this.turtleHistoryOn = wasHistoryOn4;
								if(this.fill) {
									arr4.push(this.x);
									arr4.push(this.y);
								}
							}
							if(this.fill) {
								var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
								var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
								var l13 = arr4.length;
								var i9 = 2;
								var lx3 = 0.;
								var ly3 = 0.;
								while(i9 < l13) {
									if(i9 > 2) {
										this.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
									}
									lx3 = arr4[i9];
									ly3 = arr4[i9 + 1];
									i9 += 2;
								}
							}
							arr4.length = 0;
						}
					}
					j += 2;
					break;
				case "CYAN":
					if(this.turtleHistoryOn) {
						this.historyAdd("CYAN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("CYAN");
					} else {
						this.pen.currentColor = -16711681;
					}
					break;
				case "DARKISH_BLUE":
					if(this.turtleHistoryOn) {
						this.historyAdd("DARKISH_BLUE");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("DARKISH_BLUE");
					} else {
						this.pen.currentColor = -8864837;
					}
					break;
				case "DARK_GREEN":
					if(this.turtleHistoryOn) {
						this.historyAdd("DARK_GREEN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("DARK_GREEN");
					} else {
						this.pen.currentColor = -10182080;
					}
					break;
				case "EAST":
					if(this.turtleHistoryOn) {
						this.historyAdd("WEST");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("EAST");
					} else {
						this.rotation = Math.PI;
					}
					break;
				case "END_REPEAT":
					break;
				case "FILL_OFF":
					if(this.turtleHistoryOn) {
						this.historyAdd("FILL_OFF");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FILL_OFF");
					} else {
						this.fill = false;
					}
					break;
				case "FILL_ON":
					if(this.turtleHistoryOn) {
						this.historyAdd("FILL_ON");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FILL_ON");
					} else {
						this.fill = true;
					}
					break;
				case "FORWARD":
					var distance3 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("FORWARD");
						this.historyParameters.push(distance3);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FORWARD");
						this.turtleParameters.push(distance3);
					} else {
						var nx6 = this.x + distance3 * Math.cos(this.rotation);
						var ny6 = this.y + distance3 * Math.sin(this.rotation);
						if(this.penIsDown) {
							this.lastDistance = distance3;
							this.lineTo(nx6,ny6);
						} else {
							var tmp8;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp8 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp8 = true;
								break;
							}
							if(tmp8) {
								this.contour.end(this.width);
							}
							this.x = nx6;
							this.y = ny6;
							var l14 = this.points.length;
							this.points[l14] = [];
							this.points[l14][0] = nx6;
							this.points[l14][1] = ny6;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d8 = this.dim[this.dim.length - 1];
							if(nx6 < d8.minX) {
								d8.minX = nx6;
							}
							if(nx6 > d8.maxX) {
								d8.maxX = nx6;
							}
							if(ny6 < d8.minY) {
								d8.minY = ny6;
							}
							if(ny6 > d8.maxY) {
								d8.maxY = ny6;
							}
							this.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_CHANGE":
					var deltaDistance = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("FORWARD_CHANGE");
						this.historyParameters.push(deltaDistance);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FORWARD_CHANGE");
						this.turtleParameters.push(deltaDistance);
					} else {
						var distance4 = this.lastDistance + deltaDistance;
						var nx7 = this.x + distance4 * Math.cos(this.rotation);
						var ny7 = this.y + distance4 * Math.sin(this.rotation);
						if(this.penIsDown) {
							this.lastDistance = distance4 + deltaDistance;
							this.lineTo(nx7,ny7);
						} else {
							var tmp9;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp9 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp9 = true;
								break;
							}
							if(tmp9) {
								this.contour.end(this.width);
							}
							this.x = nx7;
							this.y = ny7;
							var l15 = this.points.length;
							this.points[l15] = [];
							this.points[l15][0] = nx7;
							this.points[l15][1] = ny7;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d9 = this.dim[this.dim.length - 1];
							if(nx7 < d9.minX) {
								d9.minX = nx7;
							}
							if(nx7 > d9.maxX) {
								d9.maxX = nx7;
							}
							if(ny7 < d9.minY) {
								d9.minY = ny7;
							}
							if(ny7 > d9.maxY) {
								d9.maxY = ny7;
							}
							this.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_FACTOR":
					var factor = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("FORWARD_FACTOR");
						this.historyParameters.push(factor);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FORWARD_FACTOR");
						this.turtleParameters.push(factor);
					} else {
						var distance5 = this.lastDistance * factor;
						var nx8 = this.x + distance5 * Math.cos(this.rotation);
						var ny8 = this.y + distance5 * Math.sin(this.rotation);
						if(this.penIsDown) {
							this.lastDistance = distance5;
							this.lineTo(nx8,ny8);
						} else {
							var tmp10;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp10 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp10 = true;
								break;
							}
							if(tmp10) {
								this.contour.end(this.width);
							}
							this.x = nx8;
							this.y = ny8;
							var l16 = this.points.length;
							this.points[l16] = [];
							this.points[l16][0] = nx8;
							this.points[l16][1] = ny8;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d10 = this.dim[this.dim.length - 1];
							if(nx8 < d10.minX) {
								d10.minX = nx8;
							}
							if(nx8 > d10.maxX) {
								d10.maxX = nx8;
							}
							if(ny8 < d10.minY) {
								d10.minY = ny8;
							}
							if(ny8 > d10.maxY) {
								d10.maxY = ny8;
							}
							this.contour.reset();
						}
					}
					++j;
					break;
				case "GREEN":
					if(this.turtleHistoryOn) {
						this.historyAdd("GREEN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("GREEN");
					} else {
						this.pen.currentColor = -16711936;
					}
					break;
				case "GREY":
					if(this.turtleHistoryOn) {
						this.historyAdd("GREY");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("GREY");
					} else {
						this.pen.currentColor = -4737097;
					}
					break;
				case "LEFT":
					var degrees2 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("LEFT");
						this.historyParameters.push(degrees2);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("LEFT");
						this.turtleParameters.push(degrees2);
					} else {
						this.rotation -= degrees2 * Math.PI / 180;
					}
					++j;
					break;
				case "LIGHT_BROWN":
					if(this.turtleHistoryOn) {
						this.historyAdd("LIGHT_BROWN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("LIGHT_BROWN");
					} else {
						this.pen.currentColor = -3831790;
					}
					break;
				case "LINE_STYLE":
					var thickness = v[j];
					var color = v[j + 1];
					if(this.turtleHistoryOn) {
						this.historyAdd("LINE_STYLE");
						this.historyParameters.push(thickness);
						this.historyParameters.push(color);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("LINE_STYLE");
						this.historyParameters.push(thickness);
						this.historyParameters.push(color);
					} else {
						this.width = thickness;
						this.pen.currentColor = color | 0;
					}
					j += 2;
					break;
				case "MAGENTA":
					if(this.turtleHistoryOn) {
						this.historyAdd("MAGENTA");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("MAGENTA");
					} else {
						this.pen.currentColor = -65281;
					}
					break;
				case "MOVE_PEN":
					var distance6 = v[j];
					if(this.repeatCommands) {
						this.turtleCommands.push("MOVE_PEN");
						this.turtleParameters.push(distance6);
					} else if(this.penIsDown) {
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_UP");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_UP");
						} else {
							this.penIsDown = false;
						}
						if(this.turtleHistoryOn) {
							this.historyAdd("FORWARD");
							this.historyParameters.push(distance6);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FORWARD");
							this.turtleParameters.push(distance6);
						} else {
							var nx9 = this.x + distance6 * Math.cos(this.rotation);
							var ny9 = this.y + distance6 * Math.sin(this.rotation);
							if(this.penIsDown) {
								this.lastDistance = distance6;
								this.lineTo(nx9,ny9);
							} else {
								var tmp11;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp11 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp11 = true;
									break;
								}
								if(tmp11) {
									this.contour.end(this.width);
								}
								this.x = nx9;
								this.y = ny9;
								var l17 = this.points.length;
								this.points[l17] = [];
								this.points[l17][0] = nx9;
								this.points[l17][1] = ny9;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d11 = this.dim[this.dim.length - 1];
								if(nx9 < d11.minX) {
									d11.minX = nx9;
								}
								if(nx9 > d11.maxX) {
									d11.maxX = nx9;
								}
								if(ny9 < d11.minY) {
									d11.minY = ny9;
								}
								if(ny9 > d11.maxY) {
									d11.maxY = ny9;
								}
								this.contour.reset();
							}
						}
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_DOWN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_DOWN");
						} else {
							this.penIsDown = true;
						}
					} else {
						if(this.turtleHistoryOn) {
							this.historyAdd("FORWARD");
							this.historyParameters.push(distance6);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FORWARD");
							this.turtleParameters.push(distance6);
						} else {
							var nx10 = this.x + distance6 * Math.cos(this.rotation);
							var ny10 = this.y + distance6 * Math.sin(this.rotation);
							if(this.penIsDown) {
								this.lastDistance = distance6;
								this.lineTo(nx10,ny10);
							} else {
								var tmp12;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp12 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp12 = true;
									break;
								}
								if(tmp12) {
									this.contour.end(this.width);
								}
								this.x = nx10;
								this.y = ny10;
								var l18 = this.points.length;
								this.points[l18] = [];
								this.points[l18][0] = nx10;
								this.points[l18][1] = ny10;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d12 = this.dim[this.dim.length - 1];
								if(nx10 < d12.minX) {
									d12.minX = nx10;
								}
								if(nx10 > d12.maxX) {
									d12.maxX = nx10;
								}
								if(ny10 < d12.minY) {
									d12.minY = ny10;
								}
								if(ny10 > d12.maxY) {
									d12.maxY = ny10;
								}
								this.contour.reset();
							}
						}
					}
					++j;
					break;
				case "NORTH":
					if(this.turtleHistoryOn) {
						this.historyAdd("NORTH");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("NORTH");
					} else {
						this.rotation = -Math.PI / 2;
					}
					break;
				case "ORANGE":
					if(this.turtleHistoryOn) {
						this.historyAdd("ORANGE");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("ORANGE");
					} else {
						this.pen.currentColor = -23808;
					}
					break;
				case "PEN_COLOR":
					var r = v[j];
					var g = v[j + 1];
					var b = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_COLOR");
						this.historyParameters.push(r);
						this.historyParameters.push(g);
						this.historyParameters.push(b);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_COLOR");
						this.turtleParameters.push(r);
						this.turtleParameters.push(g);
						this.turtleParameters.push(b);
					} else {
						this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_B":
					var r1 = v[j];
					var g1 = v[j + 1];
					var b1 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_COLOR_B");
						this.historyParameters.push(r1);
						this.historyParameters.push(g1);
						this.historyParameters.push(b1);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_COLOR_B");
						this.turtleParameters.push(r1);
						this.turtleParameters.push(g1);
						this.turtleParameters.push(b1);
					} else {
						this.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_C":
					var r2 = v[j];
					var g2 = v[j + 1];
					var b2 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_COLOR_C");
						this.historyParameters.push(r2);
						this.historyParameters.push(g2);
						this.historyParameters.push(b2);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_COLOR_C");
						this.turtleParameters.push(r2);
						this.turtleParameters.push(g2);
						this.turtleParameters.push(b2);
					} else {
						this.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE":
					var r3 = v[j];
					var g3 = v[j + 1];
					var b3 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_COLOR_CHANGE");
						this.historyParameters.push(r3);
						this.historyParameters.push(g3);
						this.historyParameters.push(b3);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_COLOR_CHANGE");
						this.turtleParameters.push(r3);
						this.turtleParameters.push(g3);
						this.turtleParameters.push(b3);
					} else {
						var c = this.pen.currentColor;
						var r0 = (c >> 16 & 255) / 255;
						var g0 = (c >> 8 & 255) / 255;
						var b0 = (c & 255) / 255;
						this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_B":
					var r4 = v[j];
					var g4 = v[j + 1];
					var b4 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_COLOR_CHANGE_B");
						this.historyParameters.push(r4);
						this.historyParameters.push(g4);
						this.historyParameters.push(b4);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_COLOR_CHANGE_B");
						this.turtleParameters.push(r4);
						this.turtleParameters.push(g4);
						this.turtleParameters.push(b4);
					} else {
						var c1 = this.pen.colorB;
						var r01 = (c1 >> 16 & 255) / 255;
						var g01 = (c1 >> 8 & 255) / 255;
						var b01 = (c1 & 255) / 255;
						this.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_C":
					var r5 = v[j];
					var g5 = v[j + 1];
					var b5 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_COLOR_CHANGE_C");
						this.historyParameters.push(r5);
						this.historyParameters.push(g5);
						this.historyParameters.push(b5);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_COLOR_CHANGE_C");
						this.turtleParameters.push(r5);
						this.turtleParameters.push(g5);
						this.turtleParameters.push(b5);
					} else {
						var c2 = this.pen.colorC;
						var r02 = (c2 >> 16 & 255) / 255;
						var g02 = (c2 >> 8 & 255) / 255;
						var b02 = (c2 & 255) / 255;
						this.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
					}
					j += 3;
					break;
				case "PEN_DOWN":
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_DOWN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_DOWN");
					} else {
						this.penIsDown = true;
					}
					break;
				case "PEN_SIZE":
					var w = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_SIZE");
						this.historyParameters.push(w);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_SIZE");
						this.turtleParameters.push(w);
					} else {
						this.width = w;
					}
					++j;
					break;
				case "PEN_SIZE_CHANGE":
					var dw = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_SIZE_CHANGE");
						this.historyParameters.push(dw);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_SIZE_CHANGE");
						this.turtleParameters.push(dw);
					} else {
						this.width += dw;
					}
					++j;
					break;
				case "PEN_SIZE_FACTOR":
					var factor1 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_SIZE_FACTOR");
						this.historyParameters.push(factor1);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_SIZE_FACTOR");
						this.turtleParameters.push(factor1);
					} else {
						this.width *= factor1;
					}
					++j;
					break;
				case "PEN_UP":
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_UP");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_UP");
					} else {
						this.penIsDown = false;
					}
					break;
				case "PLUM":
					if(this.turtleHistoryOn) {
						this.historyAdd("PLUM");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PLUM");
					} else {
						this.pen.currentColor = -7310896;
					}
					break;
				case "RED":
					if(this.turtleHistoryOn) {
						this.historyAdd("RED");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("RED");
					} else {
						this.pen.currentColor = -65536;
					}
					break;
				case "RIGHT":
					var degrees3 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("RIGHT");
						this.historyParameters.push(degrees3);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("RIGHT");
						this.turtleParameters.push(degrees3);
					} else {
						this.rotation += degrees3 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_ANGLE":
					var degrees4 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("SET_ANGLE");
						this.historyParameters.push(degrees4);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("SET_ANGLE");
						this.turtleParameters.push(degrees4);
					} else {
						this.rotation = -Math.PI / 2;
						this.rotation += degrees4 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_POSITION":
					var x2 = v[j];
					var y2 = v[j + 1];
					if(this.turtleHistoryOn) {
						this.historyAdd("SET_POSITION");
						this.historyParameters.push(x2);
						this.historyParameters.push(y2);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("SET_POSITION");
						this.turtleParameters.push(x2);
						this.turtleParameters.push(y2);
					} else {
						var tmp13;
						switch(this.endLine) {
						case 0:case 1:case 6:case 9:case 12:case 15:case 18:
							tmp13 = false;
							break;
						case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
							tmp13 = true;
							break;
						}
						if(tmp13) {
							this.contour.end(this.width);
						}
						this.x = x2;
						this.y = y2;
						var l19 = this.points.length;
						this.points[l19] = [];
						this.points[l19][0] = x2;
						this.points[l19][1] = y2;
						this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
						this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
						this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d13 = this.dim[this.dim.length - 1];
						if(x2 < d13.minX) {
							d13.minX = x2;
						}
						if(x2 > d13.maxX) {
							d13.maxX = x2;
						}
						if(y2 < d13.minY) {
							d13.minY = y2;
						}
						if(y2 > d13.maxY) {
							d13.maxY = y2;
						}
						this.contour.reset();
					}
					j += 2;
					break;
				case "SOUTH":
					if(this.turtleHistoryOn) {
						this.historyAdd("SOUTH");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("SOUTH");
					} else {
						this.rotation = Math.PI / 2;
					}
					break;
				case "TAN":
					if(this.turtleHistoryOn) {
						this.historyAdd("TAN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("TAN");
					} else {
						this.pen.currentColor = -27273;
					}
					break;
				case "TRIANGLE_ARCH":
					var distance7 = v[j];
					var distance21 = v[j + 1];
					var radius5 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("TRIANGLE_ARCH");
						this.historyParameters.push(distance7);
						this.historyParameters.push(distance21);
						this.historyParameters.push(radius5);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("TRIANGLE_ARCH");
						this.turtleParameters.push(distance7);
						this.turtleParameters.push(distance21);
						this.turtleParameters.push(radius5);
					} else {
						var nx11 = this.x + distance7 * Math.cos(this.rotation);
						var ny11 = this.y + distance7 * Math.sin(this.rotation);
						if(this.penIsDown) {
							var thruX1 = this.x + distance21 * Math.cos(this.rotation) - radius5 * Math.cos(this.rotation + Math.PI / 2);
							var thruY1 = this.y + distance21 * Math.sin(this.rotation) - radius5 * Math.sin(this.rotation + Math.PI / 2);
							if(this.fill) {
								this.pen.triangle2DFill(this.x,this.y,thruX1,thruY1,nx11,ny11);
							}
							this.lineTo(thruX1,thruY1);
							this.lineTo(nx11,ny11);
							if(this.fill) {
								this.lineTo(this.x,this.y);
							}
							var tmp14;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp14 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp14 = true;
								break;
							}
							if(tmp14) {
								this.contour.end(this.width);
							}
							this.x = nx11;
							this.y = ny11;
							var l20 = this.points.length;
							this.points[l20] = [];
							this.points[l20][0] = nx11;
							this.points[l20][1] = ny11;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d14 = this.dim[this.dim.length - 1];
							if(nx11 < d14.minX) {
								d14.minX = nx11;
							}
							if(nx11 > d14.maxX) {
								d14.maxX = nx11;
							}
							if(ny11 < d14.minY) {
								d14.minY = ny11;
							}
							if(ny11 > d14.maxY) {
								d14.maxY = ny11;
							}
							this.contour.reset();
						} else {
							var tmp15;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp15 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp15 = true;
								break;
							}
							if(tmp15) {
								this.contour.end(this.width);
							}
							this.x = nx11;
							this.y = ny11;
							var l21 = this.points.length;
							this.points[l21] = [];
							this.points[l21][0] = nx11;
							this.points[l21][1] = ny11;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d15 = this.dim[this.dim.length - 1];
							if(nx11 < d15.minX) {
								d15.minX = nx11;
							}
							if(nx11 > d15.maxX) {
								d15.maxX = nx11;
							}
							if(ny11 < d15.minY) {
								d15.minY = ny11;
							}
							if(ny11 > d15.maxY) {
								d15.maxY = ny11;
							}
							this.contour.reset();
						}
					}
					j += 3;
					break;
				case "WEST":
					if(this.turtleHistoryOn) {
						this.historyAdd("WEST");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("WEST");
					} else {
						this.rotation = 0;
					}
					break;
				case "WHITE":
					if(this.turtleHistoryOn) {
						this.historyAdd("WHITE");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("WHITE");
					} else {
						this.pen.currentColor = -1;
					}
					break;
				case "YELLOW":
					if(this.turtleHistoryOn) {
						this.historyAdd("YELLOW");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("YELLOW");
					} else {
						this.pen.currentColor = -256;
					}
					break;
				}
			}
			j = 0;
		}
		this.turtleHistoryOn = wasHistoryOn;
		this.turtleCommands.length = 0;
		this.turtleParameters.length = 0;
		return this;
	}
	,endRepeat: function() {
		this.repeatCommands = false;
		if(this.turtleHistoryOn) {
			this.historyAdd("END_REPEAT");
		}
		var wasHistoryOn = this.turtleHistoryOn;
		this.turtleHistoryOn = false;
		var v = this.turtleParameters;
		var j = 0;
		var _g = 0;
		var _g1 = this.repeatCount;
		while(_g < _g1) {
			var k = _g++;
			var _g2 = 0;
			var _g3 = this.turtleCommands.length;
			while(_g2 < _g3) {
				var i = _g2++;
				var command = this.turtleCommands[i];
				switch(command) {
				case "ARC":
					var radius = v[j];
					var degrees = v[j + 1];
					if(this.turtleHistoryOn) {
						this.historyAdd("ARC");
						this.historyParameters.push(radius);
						this.historyParameters.push(degrees);
					}
					if(radius != 0) {
						if(this.repeatCommands) {
							this.turtleCommands.push("ARC");
							this.turtleParameters.push(radius);
							this.turtleParameters.push(degrees);
						} else {
							var beta = degrees * Math.PI / 180 / 24;
							var alpha = (Math.PI - beta) / 2;
							var rotate = -(Math.PI / 2 - alpha);
							var baseLength = 0.5 * radius * Math.sin(beta / 2);
							var ox = this.x;
							var oy = this.y;
							var arr = [];
							arr.push(this.x);
							arr.push(this.y);
							var _g4 = 0;
							while(_g4 < 48) {
								var i1 = _g4++;
								this.rotation += rotate;
								var wasHistoryOn1 = this.turtleHistoryOn;
								this.turtleHistoryOn = false;
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD");
									this.historyParameters.push(baseLength);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD");
									this.turtleParameters.push(baseLength);
								} else {
									var nx = this.x + baseLength * Math.cos(this.rotation);
									var ny = this.y + baseLength * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = baseLength;
										this.lineTo(nx,ny);
									} else {
										var tmp;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp = true;
											break;
										}
										if(tmp) {
											this.contour.end(this.width);
										}
										this.x = nx;
										this.y = ny;
										var l = this.points.length;
										this.points[l] = [];
										this.points[l][0] = nx;
										this.points[l][1] = ny;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d = this.dim[this.dim.length - 1];
										if(nx < d.minX) {
											d.minX = nx;
										}
										if(nx > d.maxX) {
											d.maxX = nx;
										}
										if(ny < d.minY) {
											d.minY = ny;
										}
										if(ny > d.maxY) {
											d.maxY = ny;
										}
										this.contour.reset();
									}
								}
								this.turtleHistoryOn = wasHistoryOn1;
								if(this.fill) {
									arr.push(this.x);
									arr.push(this.y);
								}
							}
							if(this.fill) {
								var cx = (ox + arr[arr.length - 2]) / 2;
								var cy = (oy + arr[arr.length - 1]) / 2;
								var l1 = arr.length;
								var i2 = 2;
								var lx = 0.;
								var ly = 0.;
								this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
								while(i2 < l1) {
									if(i2 > 2) {
										this.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
									}
									lx = arr[i2];
									ly = arr[i2 + 1];
									i2 += 2;
								}
							}
							arr.length = 0;
						}
					}
					j += 2;
					break;
				case "ARCH_BEZIER":
					var distance = v[j];
					var distance2 = v[j + 1];
					var radius1 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("ARCH_BEZIER");
						this.historyParameters.push(distance);
						this.historyParameters.push(distance2);
						this.historyParameters.push(radius1);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("ARCH_BEZIER");
						this.turtleParameters.push(distance);
						this.turtleParameters.push(distance2);
						this.turtleParameters.push(radius1);
					} else {
						var nx1 = this.x + distance * Math.cos(this.rotation);
						var ny1 = this.y + distance * Math.sin(this.rotation);
						if(this.penIsDown) {
							var thruX = this.x + distance2 * Math.cos(this.rotation) - radius1 * Math.cos(this.rotation + Math.PI / 2);
							var thruY = this.y + distance2 * Math.sin(this.rotation) - radius1 * Math.sin(this.rotation + Math.PI / 2);
							var newx = 2 * thruX - 0.5 * (this.x + nx1);
							var newy = 2 * thruY - 0.5 * (this.y + ny1);
							this.tempArr = [];
							var p = this.tempArr;
							var ax = this.x;
							var ay = this.y;
							var x = ax - newx;
							var y = ay - newy;
							var x1 = newx - nx1;
							var y1 = newy - ny1;
							var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
							if(approxDistance == 0) {
								approxDistance = 0.000001;
							}
							var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
							var l2 = p.length;
							p[l2++] = ax;
							p[l2++] = ay;
							var t = step;
							while(t < 1.) {
								var u = 1 - t;
								p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
								var u1 = 1 - t;
								p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
								t += step;
							}
							p[l2++] = nx1;
							p[l2++] = ny1;
							var arr1 = this.tempArr;
							var withMove = false;
							if(withMove == null) {
								withMove = true;
							}
							var l3 = arr1.length;
							var i3 = 2;
							if(withMove) {
								var x_ = arr1[0];
								var y_ = arr1[1];
								var tmp1;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp1 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp1 = true;
									break;
								}
								if(tmp1) {
									this.contour.end(this.width);
								}
								this.x = x_;
								this.y = y_;
								var l4 = this.points.length;
								this.points[l4] = [];
								this.points[l4][0] = x_;
								this.points[l4][1] = y_;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d1 = this.dim[this.dim.length - 1];
								if(x_ < d1.minX) {
									d1.minX = x_;
								}
								if(x_ > d1.maxX) {
									d1.maxX = x_;
								}
								if(y_ < d1.minY) {
									d1.minY = y_;
								}
								if(y_ > d1.maxY) {
									d1.maxY = y_;
								}
								this.contour.reset();
							} else {
								this.lineTo(arr1[0],arr1[1]);
							}
							var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
							var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
							var ox1 = this.x;
							var oy1 = this.y;
							while(i3 < l3) {
								if(this.fill && this.penIsDown) {
									if(i3 > 0 && i3 < l3 - 2) {
										this.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
									}
								}
								this.lineTo(arr1[i3],arr1[i3 + 1]);
								i3 += 2;
							}
							if(this.fill && this.penIsDown) {
								var tmp2;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp2 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp2 = true;
									break;
								}
								if(tmp2) {
									this.contour.end(this.width);
								}
								this.x = ox1;
								this.y = oy1;
								var l5 = this.points.length;
								this.points[l5] = [];
								this.points[l5][0] = ox1;
								this.points[l5][1] = oy1;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d2 = this.dim[this.dim.length - 1];
								if(ox1 < d2.minX) {
									d2.minX = ox1;
								}
								if(ox1 > d2.maxX) {
									d2.maxX = ox1;
								}
								if(oy1 < d2.minY) {
									d2.minY = oy1;
								}
								if(oy1 > d2.maxY) {
									d2.maxY = oy1;
								}
								this.contour.reset();
								this.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
							}
							this.x = nx1;
							this.y = ny1;
						} else {
							var tmp3;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp3 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp3 = true;
								break;
							}
							if(tmp3) {
								this.contour.end(this.width);
							}
							this.x = nx1;
							this.y = ny1;
							var l6 = this.points.length;
							this.points[l6] = [];
							this.points[l6][0] = nx1;
							this.points[l6][1] = ny1;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d3 = this.dim[this.dim.length - 1];
							if(nx1 < d3.minX) {
								d3.minX = nx1;
							}
							if(nx1 > d3.maxX) {
								d3.maxX = nx1;
							}
							if(ny1 < d3.minY) {
								d3.minY = ny1;
							}
							if(ny1 > d3.maxY) {
								d3.maxY = ny1;
							}
							this.contour.reset();
						}
					}
					j += 3;
					break;
				case "ARC_SIDES":
					var radius2 = v[j];
					var degrees1 = v[j + 1];
					var sides = v[j + 2];
					if(sides == null) {
						sides = 24;
					}
					if(this.turtleHistoryOn) {
						if(sides == 24) {
							this.historyAdd("ARC");
							this.historyParameters.push(radius2);
							this.historyParameters.push(degrees1);
						} else {
							this.historyAdd("ARC_SIDES");
							this.historyParameters.push(radius2);
							this.historyParameters.push(degrees1);
							this.historyParameters.push(sides);
						}
					}
					if(radius2 != 0) {
						if(this.repeatCommands) {
							if(sides == 24) {
								this.turtleCommands.push("ARC");
								this.turtleParameters.push(radius2);
								this.turtleParameters.push(degrees1);
							} else {
								this.turtleCommands.push("ARC_SIDES");
								this.turtleParameters.push(radius2);
								this.turtleParameters.push(degrees1);
								this.turtleParameters.push(sides);
							}
						} else {
							var beta1 = degrees1 * Math.PI / 180 / sides;
							var alpha1 = (Math.PI - beta1) / 2;
							var rotate1 = -(Math.PI / 2 - alpha1);
							var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
							var ox2 = this.x;
							var oy2 = this.y;
							var arr2 = [];
							arr2.push(this.x);
							arr2.push(this.y);
							var _g5 = 0;
							while(_g5 < 48) {
								var i4 = _g5++;
								this.rotation += rotate1;
								var wasHistoryOn2 = this.turtleHistoryOn;
								this.turtleHistoryOn = false;
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD");
									this.historyParameters.push(baseLength1);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD");
									this.turtleParameters.push(baseLength1);
								} else {
									var nx2 = this.x + baseLength1 * Math.cos(this.rotation);
									var ny2 = this.y + baseLength1 * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = baseLength1;
										this.lineTo(nx2,ny2);
									} else {
										var tmp4;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp4 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp4 = true;
											break;
										}
										if(tmp4) {
											this.contour.end(this.width);
										}
										this.x = nx2;
										this.y = ny2;
										var l7 = this.points.length;
										this.points[l7] = [];
										this.points[l7][0] = nx2;
										this.points[l7][1] = ny2;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d4 = this.dim[this.dim.length - 1];
										if(nx2 < d4.minX) {
											d4.minX = nx2;
										}
										if(nx2 > d4.maxX) {
											d4.maxX = nx2;
										}
										if(ny2 < d4.minY) {
											d4.minY = ny2;
										}
										if(ny2 > d4.maxY) {
											d4.maxY = ny2;
										}
										this.contour.reset();
									}
								}
								this.turtleHistoryOn = wasHistoryOn2;
								if(this.fill) {
									arr2.push(this.x);
									arr2.push(this.y);
								}
							}
							if(this.fill) {
								var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
								var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
								var l8 = arr2.length;
								var i5 = 2;
								var lx1 = 0.;
								var ly1 = 0.;
								this.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
								while(i5 < l8) {
									if(i5 > 2) {
										this.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
									}
									lx1 = arr2[i5];
									ly1 = arr2[i5 + 1];
									i5 += 2;
								}
							}
							arr2.length = 0;
						}
					}
					j += 3;
					break;
				case "BACKWARD":
					var distance1 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("BACKWARD");
						this.historyParameters.push(distance1);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("BACKWARD");
						this.turtleParameters.push(distance1);
					} else {
						var nx3 = this.x + distance1 * Math.cos(this.rotation + Math.PI);
						var ny3 = this.y + distance1 * Math.sin(this.rotation + Math.PI);
						if(this.penIsDown) {
							this.lineTo(nx3,ny3);
						} else {
							var tmp5;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp5 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp5 = true;
								break;
							}
							if(tmp5) {
								this.contour.end(this.width);
							}
							this.x = nx3;
							this.y = ny3;
							var l9 = this.points.length;
							this.points[l9] = [];
							this.points[l9][0] = nx3;
							this.points[l9][1] = ny3;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d5 = this.dim[this.dim.length - 1];
							if(nx3 < d5.minX) {
								d5.minX = nx3;
							}
							if(nx3 > d5.maxX) {
								d5.maxX = nx3;
							}
							if(ny3 < d5.minY) {
								d5.minY = ny3;
							}
							if(ny3 > d5.maxY) {
								d5.maxY = ny3;
							}
							this.contour.reset();
						}
					}
					++j;
					break;
				case "BEGIN_REPEAT":
					break;
				case "BLACK":
					if(this.turtleHistoryOn) {
						this.historyAdd("BLACK");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("BLACK");
					} else {
						this.pen.currentColor = -16777216;
					}
					break;
				case "BLUE":
					if(this.turtleHistoryOn) {
						this.historyAdd("BLUE");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("BLUE");
					} else {
						this.pen.currentColor = -16776961;
					}
					break;
				case "BROWN":
					if(this.turtleHistoryOn) {
						this.historyAdd("BROWN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("BROWN");
					} else {
						this.pen.currentColor = -6594501;
					}
					break;
				case "CIRCLE":
					var radius3 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("CIRCLE");
						this.historyParameters.push(radius3);
					}
					if(radius3 != 0) {
						if(this.repeatCommands) {
							this.turtleCommands.push("CIRCLE");
							this.turtleParameters.push(radius3);
						} else {
							var beta2 = 2 * Math.PI / 24;
							var alpha2 = (Math.PI - beta2) / 2;
							var rotate2 = -(Math.PI / 2 - alpha2);
							var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
							var ox3 = this.x;
							var oy3 = this.y;
							var arr3 = [];
							var _g6 = 0;
							while(_g6 < 48) {
								var i6 = _g6++;
								this.rotation += rotate2;
								var wasHistoryOn3 = this.turtleHistoryOn;
								this.turtleHistoryOn = false;
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD");
									this.historyParameters.push(baseLength2);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD");
									this.turtleParameters.push(baseLength2);
								} else {
									var nx4 = this.x + baseLength2 * Math.cos(this.rotation);
									var ny4 = this.y + baseLength2 * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = baseLength2;
										this.lineTo(nx4,ny4);
									} else {
										var tmp6;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp6 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp6 = true;
											break;
										}
										if(tmp6) {
											this.contour.end(this.width);
										}
										this.x = nx4;
										this.y = ny4;
										var l10 = this.points.length;
										this.points[l10] = [];
										this.points[l10][0] = nx4;
										this.points[l10][1] = ny4;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d6 = this.dim[this.dim.length - 1];
										if(nx4 < d6.minX) {
											d6.minX = nx4;
										}
										if(nx4 > d6.maxX) {
											d6.maxX = nx4;
										}
										if(ny4 < d6.minY) {
											d6.minY = ny4;
										}
										if(ny4 > d6.maxY) {
											d6.maxY = ny4;
										}
										this.contour.reset();
									}
								}
								this.turtleHistoryOn = wasHistoryOn3;
								if(this.fill) {
									arr3.push(this.x);
									arr3.push(this.y);
								}
							}
							if(this.fill) {
								var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
								var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
								var l11 = arr3.length;
								var i7 = 2;
								var lx2 = 0.;
								var ly2 = 0.;
								while(i7 < l11) {
									if(i7 > 2) {
										this.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
									}
									lx2 = arr3[i7];
									ly2 = arr3[i7 + 1];
									i7 += 2;
								}
							}
							arr3.length = 0;
						}
					}
					++j;
					break;
				case "CIRCLE_SIDES":
					var radius4 = v[j];
					var sides1 = v[j + 1];
					if(sides1 == null) {
						sides1 = 24;
					}
					if(this.turtleHistoryOn) {
						if(sides1 == 24) {
							this.historyAdd("CIRCLE");
							this.historyParameters.push(radius4);
						} else {
							this.historyAdd("CIRCLE_SIDES");
							this.historyParameters.push(radius4);
							this.historyParameters.push(sides1);
						}
					}
					if(radius4 != 0) {
						if(this.repeatCommands) {
							if(sides1 == 24) {
								this.turtleCommands.push("CIRCLE");
								this.turtleParameters.push(radius4);
							} else {
								this.turtleCommands.push("CIRCLE_SIDES");
								this.turtleParameters.push(radius4);
								this.turtleParameters.push(sides1);
							}
						} else {
							var beta3 = 2 * Math.PI / sides1;
							var alpha3 = (Math.PI - beta3) / 2;
							var rotate3 = -(Math.PI / 2 - alpha3);
							var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
							var ox4 = this.x;
							var oy4 = this.y;
							var arr4 = [];
							var _g7 = 0;
							while(_g7 < 48) {
								var i8 = _g7++;
								this.rotation += rotate3;
								var wasHistoryOn4 = this.turtleHistoryOn;
								this.turtleHistoryOn = false;
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD");
									this.historyParameters.push(baseLength3);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD");
									this.turtleParameters.push(baseLength3);
								} else {
									var nx5 = this.x + baseLength3 * Math.cos(this.rotation);
									var ny5 = this.y + baseLength3 * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = baseLength3;
										this.lineTo(nx5,ny5);
									} else {
										var tmp7;
										switch(this.endLine) {
										case 0:case 1:case 6:case 9:case 12:case 15:case 18:
											tmp7 = false;
											break;
										case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
											tmp7 = true;
											break;
										}
										if(tmp7) {
											this.contour.end(this.width);
										}
										this.x = nx5;
										this.y = ny5;
										var l12 = this.points.length;
										this.points[l12] = [];
										this.points[l12][0] = nx5;
										this.points[l12][1] = ny5;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d7 = this.dim[this.dim.length - 1];
										if(nx5 < d7.minX) {
											d7.minX = nx5;
										}
										if(nx5 > d7.maxX) {
											d7.maxX = nx5;
										}
										if(ny5 < d7.minY) {
											d7.minY = ny5;
										}
										if(ny5 > d7.maxY) {
											d7.maxY = ny5;
										}
										this.contour.reset();
									}
								}
								this.turtleHistoryOn = wasHistoryOn4;
								if(this.fill) {
									arr4.push(this.x);
									arr4.push(this.y);
								}
							}
							if(this.fill) {
								var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
								var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
								var l13 = arr4.length;
								var i9 = 2;
								var lx3 = 0.;
								var ly3 = 0.;
								while(i9 < l13) {
									if(i9 > 2) {
										this.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
									}
									lx3 = arr4[i9];
									ly3 = arr4[i9 + 1];
									i9 += 2;
								}
							}
							arr4.length = 0;
						}
					}
					j += 2;
					break;
				case "CYAN":
					if(this.turtleHistoryOn) {
						this.historyAdd("CYAN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("CYAN");
					} else {
						this.pen.currentColor = -16711681;
					}
					break;
				case "DARKISH_BLUE":
					if(this.turtleHistoryOn) {
						this.historyAdd("DARKISH_BLUE");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("DARKISH_BLUE");
					} else {
						this.pen.currentColor = -8864837;
					}
					break;
				case "DARK_GREEN":
					if(this.turtleHistoryOn) {
						this.historyAdd("DARK_GREEN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("DARK_GREEN");
					} else {
						this.pen.currentColor = -10182080;
					}
					break;
				case "EAST":
					if(this.turtleHistoryOn) {
						this.historyAdd("WEST");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("EAST");
					} else {
						this.rotation = Math.PI;
					}
					break;
				case "END_REPEAT":
					break;
				case "FILL_OFF":
					if(this.turtleHistoryOn) {
						this.historyAdd("FILL_OFF");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FILL_OFF");
					} else {
						this.fill = false;
					}
					break;
				case "FILL_ON":
					if(this.turtleHistoryOn) {
						this.historyAdd("FILL_ON");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FILL_ON");
					} else {
						this.fill = true;
					}
					break;
				case "FORWARD":
					var distance3 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("FORWARD");
						this.historyParameters.push(distance3);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FORWARD");
						this.turtleParameters.push(distance3);
					} else {
						var nx6 = this.x + distance3 * Math.cos(this.rotation);
						var ny6 = this.y + distance3 * Math.sin(this.rotation);
						if(this.penIsDown) {
							this.lastDistance = distance3;
							this.lineTo(nx6,ny6);
						} else {
							var tmp8;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp8 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp8 = true;
								break;
							}
							if(tmp8) {
								this.contour.end(this.width);
							}
							this.x = nx6;
							this.y = ny6;
							var l14 = this.points.length;
							this.points[l14] = [];
							this.points[l14][0] = nx6;
							this.points[l14][1] = ny6;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d8 = this.dim[this.dim.length - 1];
							if(nx6 < d8.minX) {
								d8.minX = nx6;
							}
							if(nx6 > d8.maxX) {
								d8.maxX = nx6;
							}
							if(ny6 < d8.minY) {
								d8.minY = ny6;
							}
							if(ny6 > d8.maxY) {
								d8.maxY = ny6;
							}
							this.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_CHANGE":
					var deltaDistance = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("FORWARD_CHANGE");
						this.historyParameters.push(deltaDistance);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FORWARD_CHANGE");
						this.turtleParameters.push(deltaDistance);
					} else {
						var distance4 = this.lastDistance + deltaDistance;
						var nx7 = this.x + distance4 * Math.cos(this.rotation);
						var ny7 = this.y + distance4 * Math.sin(this.rotation);
						if(this.penIsDown) {
							this.lastDistance = distance4 + deltaDistance;
							this.lineTo(nx7,ny7);
						} else {
							var tmp9;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp9 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp9 = true;
								break;
							}
							if(tmp9) {
								this.contour.end(this.width);
							}
							this.x = nx7;
							this.y = ny7;
							var l15 = this.points.length;
							this.points[l15] = [];
							this.points[l15][0] = nx7;
							this.points[l15][1] = ny7;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d9 = this.dim[this.dim.length - 1];
							if(nx7 < d9.minX) {
								d9.minX = nx7;
							}
							if(nx7 > d9.maxX) {
								d9.maxX = nx7;
							}
							if(ny7 < d9.minY) {
								d9.minY = ny7;
							}
							if(ny7 > d9.maxY) {
								d9.maxY = ny7;
							}
							this.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_FACTOR":
					var factor = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("FORWARD_FACTOR");
						this.historyParameters.push(factor);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FORWARD_FACTOR");
						this.turtleParameters.push(factor);
					} else {
						var distance5 = this.lastDistance * factor;
						var nx8 = this.x + distance5 * Math.cos(this.rotation);
						var ny8 = this.y + distance5 * Math.sin(this.rotation);
						if(this.penIsDown) {
							this.lastDistance = distance5;
							this.lineTo(nx8,ny8);
						} else {
							var tmp10;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp10 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp10 = true;
								break;
							}
							if(tmp10) {
								this.contour.end(this.width);
							}
							this.x = nx8;
							this.y = ny8;
							var l16 = this.points.length;
							this.points[l16] = [];
							this.points[l16][0] = nx8;
							this.points[l16][1] = ny8;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d10 = this.dim[this.dim.length - 1];
							if(nx8 < d10.minX) {
								d10.minX = nx8;
							}
							if(nx8 > d10.maxX) {
								d10.maxX = nx8;
							}
							if(ny8 < d10.minY) {
								d10.minY = ny8;
							}
							if(ny8 > d10.maxY) {
								d10.maxY = ny8;
							}
							this.contour.reset();
						}
					}
					++j;
					break;
				case "GREEN":
					if(this.turtleHistoryOn) {
						this.historyAdd("GREEN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("GREEN");
					} else {
						this.pen.currentColor = -16711936;
					}
					break;
				case "GREY":
					if(this.turtleHistoryOn) {
						this.historyAdd("GREY");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("GREY");
					} else {
						this.pen.currentColor = -4737097;
					}
					break;
				case "LEFT":
					var degrees2 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("LEFT");
						this.historyParameters.push(degrees2);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("LEFT");
						this.turtleParameters.push(degrees2);
					} else {
						this.rotation -= degrees2 * Math.PI / 180;
					}
					++j;
					break;
				case "LIGHT_BROWN":
					if(this.turtleHistoryOn) {
						this.historyAdd("LIGHT_BROWN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("LIGHT_BROWN");
					} else {
						this.pen.currentColor = -3831790;
					}
					break;
				case "LINE_STYLE":
					var thickness = v[j];
					var color = v[j + 1];
					if(this.turtleHistoryOn) {
						this.historyAdd("LINE_STYLE");
						this.historyParameters.push(thickness);
						this.historyParameters.push(color);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("LINE_STYLE");
						this.historyParameters.push(thickness);
						this.historyParameters.push(color);
					} else {
						this.width = thickness;
						this.pen.currentColor = color | 0;
					}
					j += 2;
					break;
				case "MAGENTA":
					if(this.turtleHistoryOn) {
						this.historyAdd("MAGENTA");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("MAGENTA");
					} else {
						this.pen.currentColor = -65281;
					}
					break;
				case "MOVE_PEN":
					var distance6 = v[j];
					if(this.repeatCommands) {
						this.turtleCommands.push("MOVE_PEN");
						this.turtleParameters.push(distance6);
					} else if(this.penIsDown) {
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_UP");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_UP");
						} else {
							this.penIsDown = false;
						}
						if(this.turtleHistoryOn) {
							this.historyAdd("FORWARD");
							this.historyParameters.push(distance6);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FORWARD");
							this.turtleParameters.push(distance6);
						} else {
							var nx9 = this.x + distance6 * Math.cos(this.rotation);
							var ny9 = this.y + distance6 * Math.sin(this.rotation);
							if(this.penIsDown) {
								this.lastDistance = distance6;
								this.lineTo(nx9,ny9);
							} else {
								var tmp11;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp11 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp11 = true;
									break;
								}
								if(tmp11) {
									this.contour.end(this.width);
								}
								this.x = nx9;
								this.y = ny9;
								var l17 = this.points.length;
								this.points[l17] = [];
								this.points[l17][0] = nx9;
								this.points[l17][1] = ny9;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d11 = this.dim[this.dim.length - 1];
								if(nx9 < d11.minX) {
									d11.minX = nx9;
								}
								if(nx9 > d11.maxX) {
									d11.maxX = nx9;
								}
								if(ny9 < d11.minY) {
									d11.minY = ny9;
								}
								if(ny9 > d11.maxY) {
									d11.maxY = ny9;
								}
								this.contour.reset();
							}
						}
						if(this.turtleHistoryOn) {
							this.historyAdd("PEN_DOWN");
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("PEN_DOWN");
						} else {
							this.penIsDown = true;
						}
					} else {
						if(this.turtleHistoryOn) {
							this.historyAdd("FORWARD");
							this.historyParameters.push(distance6);
						}
						if(this.repeatCommands) {
							this.turtleCommands.push("FORWARD");
							this.turtleParameters.push(distance6);
						} else {
							var nx10 = this.x + distance6 * Math.cos(this.rotation);
							var ny10 = this.y + distance6 * Math.sin(this.rotation);
							if(this.penIsDown) {
								this.lastDistance = distance6;
								this.lineTo(nx10,ny10);
							} else {
								var tmp12;
								switch(this.endLine) {
								case 0:case 1:case 6:case 9:case 12:case 15:case 18:
									tmp12 = false;
									break;
								case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
									tmp12 = true;
									break;
								}
								if(tmp12) {
									this.contour.end(this.width);
								}
								this.x = nx10;
								this.y = ny10;
								var l18 = this.points.length;
								this.points[l18] = [];
								this.points[l18][0] = nx10;
								this.points[l18][1] = ny10;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d12 = this.dim[this.dim.length - 1];
								if(nx10 < d12.minX) {
									d12.minX = nx10;
								}
								if(nx10 > d12.maxX) {
									d12.maxX = nx10;
								}
								if(ny10 < d12.minY) {
									d12.minY = ny10;
								}
								if(ny10 > d12.maxY) {
									d12.maxY = ny10;
								}
								this.contour.reset();
							}
						}
					}
					++j;
					break;
				case "NORTH":
					if(this.turtleHistoryOn) {
						this.historyAdd("NORTH");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("NORTH");
					} else {
						this.rotation = -Math.PI / 2;
					}
					break;
				case "ORANGE":
					if(this.turtleHistoryOn) {
						this.historyAdd("ORANGE");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("ORANGE");
					} else {
						this.pen.currentColor = -23808;
					}
					break;
				case "PEN_COLOR":
					var r = v[j];
					var g = v[j + 1];
					var b = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_COLOR");
						this.historyParameters.push(r);
						this.historyParameters.push(g);
						this.historyParameters.push(b);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_COLOR");
						this.turtleParameters.push(r);
						this.turtleParameters.push(g);
						this.turtleParameters.push(b);
					} else {
						this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_B":
					var r1 = v[j];
					var g1 = v[j + 1];
					var b1 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_COLOR_B");
						this.historyParameters.push(r1);
						this.historyParameters.push(g1);
						this.historyParameters.push(b1);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_COLOR_B");
						this.turtleParameters.push(r1);
						this.turtleParameters.push(g1);
						this.turtleParameters.push(b1);
					} else {
						this.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_C":
					var r2 = v[j];
					var g2 = v[j + 1];
					var b2 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_COLOR_C");
						this.historyParameters.push(r2);
						this.historyParameters.push(g2);
						this.historyParameters.push(b2);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_COLOR_C");
						this.turtleParameters.push(r2);
						this.turtleParameters.push(g2);
						this.turtleParameters.push(b2);
					} else {
						this.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE":
					var r3 = v[j];
					var g3 = v[j + 1];
					var b3 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_COLOR_CHANGE");
						this.historyParameters.push(r3);
						this.historyParameters.push(g3);
						this.historyParameters.push(b3);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_COLOR_CHANGE");
						this.turtleParameters.push(r3);
						this.turtleParameters.push(g3);
						this.turtleParameters.push(b3);
					} else {
						var c = this.pen.currentColor;
						var r0 = (c >> 16 & 255) / 255;
						var g0 = (c >> 8 & 255) / 255;
						var b0 = (c & 255) / 255;
						this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_B":
					var r4 = v[j];
					var g4 = v[j + 1];
					var b4 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_COLOR_CHANGE_B");
						this.historyParameters.push(r4);
						this.historyParameters.push(g4);
						this.historyParameters.push(b4);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_COLOR_CHANGE_B");
						this.turtleParameters.push(r4);
						this.turtleParameters.push(g4);
						this.turtleParameters.push(b4);
					} else {
						var c1 = this.pen.colorB;
						var r01 = (c1 >> 16 & 255) / 255;
						var g01 = (c1 >> 8 & 255) / 255;
						var b01 = (c1 & 255) / 255;
						this.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_C":
					var r5 = v[j];
					var g5 = v[j + 1];
					var b5 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_COLOR_CHANGE_C");
						this.historyParameters.push(r5);
						this.historyParameters.push(g5);
						this.historyParameters.push(b5);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_COLOR_CHANGE_C");
						this.turtleParameters.push(r5);
						this.turtleParameters.push(g5);
						this.turtleParameters.push(b5);
					} else {
						var c2 = this.pen.colorC;
						var r02 = (c2 >> 16 & 255) / 255;
						var g02 = (c2 >> 8 & 255) / 255;
						var b02 = (c2 & 255) / 255;
						this.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
					}
					j += 3;
					break;
				case "PEN_DOWN":
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_DOWN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_DOWN");
					} else {
						this.penIsDown = true;
					}
					break;
				case "PEN_SIZE":
					var w = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_SIZE");
						this.historyParameters.push(w);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_SIZE");
						this.turtleParameters.push(w);
					} else {
						this.width = w;
					}
					++j;
					break;
				case "PEN_SIZE_CHANGE":
					var dw = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_SIZE_CHANGE");
						this.historyParameters.push(dw);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_SIZE_CHANGE");
						this.turtleParameters.push(dw);
					} else {
						this.width += dw;
					}
					++j;
					break;
				case "PEN_SIZE_FACTOR":
					var factor1 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_SIZE_FACTOR");
						this.historyParameters.push(factor1);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_SIZE_FACTOR");
						this.turtleParameters.push(factor1);
					} else {
						this.width *= factor1;
					}
					++j;
					break;
				case "PEN_UP":
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_UP");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_UP");
					} else {
						this.penIsDown = false;
					}
					break;
				case "PLUM":
					if(this.turtleHistoryOn) {
						this.historyAdd("PLUM");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PLUM");
					} else {
						this.pen.currentColor = -7310896;
					}
					break;
				case "RED":
					if(this.turtleHistoryOn) {
						this.historyAdd("RED");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("RED");
					} else {
						this.pen.currentColor = -65536;
					}
					break;
				case "RIGHT":
					var degrees3 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("RIGHT");
						this.historyParameters.push(degrees3);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("RIGHT");
						this.turtleParameters.push(degrees3);
					} else {
						this.rotation += degrees3 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_ANGLE":
					var degrees4 = v[j];
					if(this.turtleHistoryOn) {
						this.historyAdd("SET_ANGLE");
						this.historyParameters.push(degrees4);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("SET_ANGLE");
						this.turtleParameters.push(degrees4);
					} else {
						this.rotation = -Math.PI / 2;
						this.rotation += degrees4 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_POSITION":
					var x2 = v[j];
					var y2 = v[j + 1];
					if(this.turtleHistoryOn) {
						this.historyAdd("SET_POSITION");
						this.historyParameters.push(x2);
						this.historyParameters.push(y2);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("SET_POSITION");
						this.turtleParameters.push(x2);
						this.turtleParameters.push(y2);
					} else {
						var tmp13;
						switch(this.endLine) {
						case 0:case 1:case 6:case 9:case 12:case 15:case 18:
							tmp13 = false;
							break;
						case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
							tmp13 = true;
							break;
						}
						if(tmp13) {
							this.contour.end(this.width);
						}
						this.x = x2;
						this.y = y2;
						var l19 = this.points.length;
						this.points[l19] = [];
						this.points[l19][0] = x2;
						this.points[l19][1] = y2;
						this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
						this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
						this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d13 = this.dim[this.dim.length - 1];
						if(x2 < d13.minX) {
							d13.minX = x2;
						}
						if(x2 > d13.maxX) {
							d13.maxX = x2;
						}
						if(y2 < d13.minY) {
							d13.minY = y2;
						}
						if(y2 > d13.maxY) {
							d13.maxY = y2;
						}
						this.contour.reset();
					}
					j += 2;
					break;
				case "SOUTH":
					if(this.turtleHistoryOn) {
						this.historyAdd("SOUTH");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("SOUTH");
					} else {
						this.rotation = Math.PI / 2;
					}
					break;
				case "TAN":
					if(this.turtleHistoryOn) {
						this.historyAdd("TAN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("TAN");
					} else {
						this.pen.currentColor = -27273;
					}
					break;
				case "TRIANGLE_ARCH":
					var distance7 = v[j];
					var distance21 = v[j + 1];
					var radius5 = v[j + 2];
					if(this.turtleHistoryOn) {
						this.historyAdd("TRIANGLE_ARCH");
						this.historyParameters.push(distance7);
						this.historyParameters.push(distance21);
						this.historyParameters.push(radius5);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("TRIANGLE_ARCH");
						this.turtleParameters.push(distance7);
						this.turtleParameters.push(distance21);
						this.turtleParameters.push(radius5);
					} else {
						var nx11 = this.x + distance7 * Math.cos(this.rotation);
						var ny11 = this.y + distance7 * Math.sin(this.rotation);
						if(this.penIsDown) {
							var thruX1 = this.x + distance21 * Math.cos(this.rotation) - radius5 * Math.cos(this.rotation + Math.PI / 2);
							var thruY1 = this.y + distance21 * Math.sin(this.rotation) - radius5 * Math.sin(this.rotation + Math.PI / 2);
							if(this.fill) {
								this.pen.triangle2DFill(this.x,this.y,thruX1,thruY1,nx11,ny11);
							}
							this.lineTo(thruX1,thruY1);
							this.lineTo(nx11,ny11);
							if(this.fill) {
								this.lineTo(this.x,this.y);
							}
							var tmp14;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp14 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp14 = true;
								break;
							}
							if(tmp14) {
								this.contour.end(this.width);
							}
							this.x = nx11;
							this.y = ny11;
							var l20 = this.points.length;
							this.points[l20] = [];
							this.points[l20][0] = nx11;
							this.points[l20][1] = ny11;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d14 = this.dim[this.dim.length - 1];
							if(nx11 < d14.minX) {
								d14.minX = nx11;
							}
							if(nx11 > d14.maxX) {
								d14.maxX = nx11;
							}
							if(ny11 < d14.minY) {
								d14.minY = ny11;
							}
							if(ny11 > d14.maxY) {
								d14.maxY = ny11;
							}
							this.contour.reset();
						} else {
							var tmp15;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp15 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp15 = true;
								break;
							}
							if(tmp15) {
								this.contour.end(this.width);
							}
							this.x = nx11;
							this.y = ny11;
							var l21 = this.points.length;
							this.points[l21] = [];
							this.points[l21][0] = nx11;
							this.points[l21][1] = ny11;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d15 = this.dim[this.dim.length - 1];
							if(nx11 < d15.minX) {
								d15.minX = nx11;
							}
							if(nx11 > d15.maxX) {
								d15.maxX = nx11;
							}
							if(ny11 < d15.minY) {
								d15.minY = ny11;
							}
							if(ny11 > d15.maxY) {
								d15.maxY = ny11;
							}
							this.contour.reset();
						}
					}
					j += 3;
					break;
				case "WEST":
					if(this.turtleHistoryOn) {
						this.historyAdd("WEST");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("WEST");
					} else {
						this.rotation = 0;
					}
					break;
				case "WHITE":
					if(this.turtleHistoryOn) {
						this.historyAdd("WHITE");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("WHITE");
					} else {
						this.pen.currentColor = -1;
					}
					break;
				case "YELLOW":
					if(this.turtleHistoryOn) {
						this.historyAdd("YELLOW");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("YELLOW");
					} else {
						this.pen.currentColor = -256;
					}
					break;
				}
			}
			j = 0;
		}
		this.turtleHistoryOn = wasHistoryOn;
		this.turtleCommands.length = 0;
		this.turtleParameters.length = 0;
		return this;
	}
	,penColor: function(r,g,b) {
		if(this.turtleHistoryOn) {
			this.historyAdd("PEN_COLOR");
			this.historyParameters.push(r);
			this.historyParameters.push(g);
			this.historyParameters.push(b);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("PEN_COLOR");
			this.turtleParameters.push(r);
			this.turtleParameters.push(g);
			this.turtleParameters.push(b);
		} else {
			this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		}
		return this;
	}
	,pencolor: function(r,g,b) {
		if(this.turtleHistoryOn) {
			this.historyAdd("PEN_COLOR");
			this.historyParameters.push(r);
			this.historyParameters.push(g);
			this.historyParameters.push(b);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("PEN_COLOR");
			this.turtleParameters.push(r);
			this.turtleParameters.push(g);
			this.turtleParameters.push(b);
		} else {
			this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		}
		return this;
	}
	,penColorChange: function(r,g,b) {
		if(this.turtleHistoryOn) {
			this.historyAdd("PEN_COLOR_CHANGE");
			this.historyParameters.push(r);
			this.historyParameters.push(g);
			this.historyParameters.push(b);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("PEN_COLOR_CHANGE");
			this.turtleParameters.push(r);
			this.turtleParameters.push(g);
			this.turtleParameters.push(b);
		} else {
			var c = this.pen.currentColor;
			var r0 = (c >> 16 & 255) / 255;
			var g0 = (c >> 8 & 255) / 255;
			var b0 = (c & 255) / 255;
			this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r) * 255) << 16 | Math.round((g0 + g) * 255) << 8 | Math.round((b0 + b) * 255);
		}
		return this;
	}
	,penColorB: function(r,g,b) {
		if(this.turtleHistoryOn) {
			this.historyAdd("PEN_COLOR_B");
			this.historyParameters.push(r);
			this.historyParameters.push(g);
			this.historyParameters.push(b);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("PEN_COLOR_B");
			this.turtleParameters.push(r);
			this.turtleParameters.push(g);
			this.turtleParameters.push(b);
		} else {
			this.pen.colorB = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		}
		return this;
	}
	,penColorChangeB: function(r,g,b) {
		if(this.turtleHistoryOn) {
			this.historyAdd("PEN_COLOR_CHANGE_B");
			this.historyParameters.push(r);
			this.historyParameters.push(g);
			this.historyParameters.push(b);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("PEN_COLOR_CHANGE_B");
			this.turtleParameters.push(r);
			this.turtleParameters.push(g);
			this.turtleParameters.push(b);
		} else {
			var c = this.pen.colorB;
			var r0 = (c >> 16 & 255) / 255;
			var g0 = (c >> 8 & 255) / 255;
			var b0 = (c & 255) / 255;
			this.pen.colorB = Math.round(255) << 24 | Math.round((r0 + r) * 255) << 16 | Math.round((g0 + g) * 255) << 8 | Math.round((b0 + b) * 255);
		}
		return this;
	}
	,penColorC: function(r,g,b) {
		if(this.turtleHistoryOn) {
			this.historyAdd("PEN_COLOR_C");
			this.historyParameters.push(r);
			this.historyParameters.push(g);
			this.historyParameters.push(b);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("PEN_COLOR_C");
			this.turtleParameters.push(r);
			this.turtleParameters.push(g);
			this.turtleParameters.push(b);
		} else {
			this.pen.colorC = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
		}
		return this;
	}
	,penColorChangeC: function(r,g,b) {
		if(this.turtleHistoryOn) {
			this.historyAdd("PEN_COLOR_CHANGE_C");
			this.historyParameters.push(r);
			this.historyParameters.push(g);
			this.historyParameters.push(b);
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("PEN_COLOR_CHANGE_C");
			this.turtleParameters.push(r);
			this.turtleParameters.push(g);
			this.turtleParameters.push(b);
		} else {
			var c = this.pen.colorC;
			var r0 = (c >> 16 & 255) / 255;
			var g0 = (c >> 8 & 255) / 255;
			var b0 = (c & 255) / 255;
			this.pen.colorC = Math.round(255) << 24 | Math.round((r0 + r) * 255) << 16 | Math.round((g0 + g) * 255) << 8 | Math.round((b0 + b) * 255);
		}
		return this;
	}
	,black: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("BLACK");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("BLACK");
		} else {
			this.pen.currentColor = -16777216;
		}
		return this;
	}
	,blue: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("BLUE");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("BLUE");
		} else {
			this.pen.currentColor = -16776961;
		}
		return this;
	}
	,green: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("GREEN");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("GREEN");
		} else {
			this.pen.currentColor = -16711936;
		}
		return this;
	}
	,cyan: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("CYAN");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("CYAN");
		} else {
			this.pen.currentColor = -16711681;
		}
		return this;
	}
	,red: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("RED");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("RED");
		} else {
			this.pen.currentColor = -65536;
		}
		return this;
	}
	,magenta: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("MAGENTA");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("MAGENTA");
		} else {
			this.pen.currentColor = -65281;
		}
		return this;
	}
	,yellow: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("YELLOW");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("YELLOW");
		} else {
			this.pen.currentColor = -256;
		}
		return this;
	}
	,white: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("WHITE");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("WHITE");
		} else {
			this.pen.currentColor = -1;
		}
		return this;
	}
	,brown: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("BROWN");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("BROWN");
		} else {
			this.pen.currentColor = -6594501;
		}
		return this;
	}
	,lightBrown: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("LIGHT_BROWN");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("LIGHT_BROWN");
		} else {
			this.pen.currentColor = -3831790;
		}
		return this;
	}
	,darkGreen: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("DARK_GREEN");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("DARK_GREEN");
		} else {
			this.pen.currentColor = -10182080;
		}
		return this;
	}
	,darkishBlue: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("DARKISH_BLUE");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("DARKISH_BLUE");
		} else {
			this.pen.currentColor = -8864837;
		}
		return this;
	}
	,tan: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("TAN");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("TAN");
		} else {
			this.pen.currentColor = -27273;
		}
		return this;
	}
	,plum: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("PLUM");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("PLUM");
		} else {
			this.pen.currentColor = -7310896;
		}
		return this;
	}
	,orange: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("ORANGE");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("ORANGE");
		} else {
			this.pen.currentColor = -23808;
		}
		return this;
	}
	,grey: function() {
		if(this.turtleHistoryOn) {
			this.historyAdd("GREY");
		}
		if(this.repeatCommands) {
			this.turtleCommands.push("GREY");
		} else {
			this.pen.currentColor = -4737097;
		}
		return this;
	}
};
var cornerContour_SketcherGrad = function(pen_,sketchForm_,endLine_) {
	cornerContour_Sketcher.call(this,pen_,sketchForm_,endLine_);
};
cornerContour_SketcherGrad.__name__ = true;
cornerContour_SketcherGrad.__super__ = cornerContour_Sketcher;
cornerContour_SketcherGrad.prototype = $extend(cornerContour_Sketcher.prototype,{
	createContour: function() {
		return new cornerContour_ContourGrad(this.pen,this.endLine);
	}
	,lineTo: function(x_,y_) {
		var repeat = this.x == x_ && this.y == y_;
		if(!repeat) {
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.y,x_,y_);
			}
			if(this.colourFunction != null) {
				this.pen.currentColor = this.colourFunction(this.pen.currentColor,this.x,this.y,x_,y_);
			}
			if(this.colourFunctionB != null) {
				this.pen.colorB = this.colourFunctionB(this.pen.colorB,this.x,this.y,x_,y_);
			}
			if(this.colourFunctionC != null) {
				this.pen.colorC = this.colourFunctionC(this.pen.colorC,this.x,this.y,x_,y_);
			}
			this.line(x_,y_);
			var l = this.points.length;
			var p = this.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.x = x_;
			this.y = y_;
		}
	}
});
var cornerContour_StyleEndLine = {};
cornerContour_StyleEndLine.get_isNo = function(this1) {
	return this1 == 0;
};
cornerContour_StyleEndLine.get_isBegin = function(this1) {
	return this1 == 1;
};
cornerContour_StyleEndLine.get_isEnd = function(this1) {
	return this1 == 2;
};
cornerContour_StyleEndLine.get_isBoth = function(this1) {
	return this1 == 3;
};
cornerContour_StyleEndLine.get_isBeginBoth = function(this1) {
	if(this1 != 1) {
		return this1 == 3;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isEndBoth = function(this1) {
	if(this1 != 2) {
		return this1 == 3;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isQuadrant = function(this1) {
	return this1 == 5;
};
cornerContour_StyleEndLine.get_isHalfRound = function(this1) {
	return this1 == 4;
};
cornerContour_StyleEndLine.get_isTriangleBegin = function(this1) {
	return this1 == 6;
};
cornerContour_StyleEndLine.get_isTriangleEnd = function(this1) {
	return this1 == 7;
};
cornerContour_StyleEndLine.get_isTriangleBoth = function(this1) {
	return this1 == 8;
};
cornerContour_StyleEndLine.get_isTriangleBeginBoth = function(this1) {
	if(this1 != 6) {
		return this1 == 8;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isTriangleEndBoth = function(this1) {
	if(this1 != 7) {
		return this1 == 8;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isArrowBegin = function(this1) {
	return this1 == 9;
};
cornerContour_StyleEndLine.get_isArrowEnd = function(this1) {
	return this1 == 10;
};
cornerContour_StyleEndLine.get_isArrowBoth = function(this1) {
	return this1 == 11;
};
cornerContour_StyleEndLine.get_isArrowBeginBoth = function(this1) {
	if(this1 != 9) {
		return this1 == 11;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isArrowEndBoth = function(this1) {
	if(this1 != 10) {
		return this1 == 11;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isCircleBegin = function(this1) {
	return this1 == 12;
};
cornerContour_StyleEndLine.get_isCircleEnd = function(this1) {
	return this1 == 13;
};
cornerContour_StyleEndLine.get_isCircleBoth = function(this1) {
	return this1 == 14;
};
cornerContour_StyleEndLine.get_isCircleBeginBoth = function(this1) {
	if(this1 != 12) {
		return this1 == 14;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isCircleEndBoth = function(this1) {
	if(this1 != 13) {
		return this1 == 14;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isSquareBegin = function(this1) {
	return this1 == 15;
};
cornerContour_StyleEndLine.get_isSquareEnd = function(this1) {
	return this1 == 16;
};
cornerContour_StyleEndLine.get_isSquareBoth = function(this1) {
	return this1 == 17;
};
cornerContour_StyleEndLine.get_isSquareBeginBoth = function(this1) {
	if(this1 != 15) {
		return this1 == 17;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isSquareEndBoth = function(this1) {
	if(this1 != 16) {
		return this1 == 17;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isEllipseBegin = function(this1) {
	return this1 == 18;
};
cornerContour_StyleEndLine.get_isEllipseEnd = function(this1) {
	return this1 == 19;
};
cornerContour_StyleEndLine.get_isEllipseBoth = function(this1) {
	return this1 == 20;
};
cornerContour_StyleEndLine.get_isEllipseBeginBoth = function(this1) {
	if(this1 != 18) {
		return this1 == 20;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isEllipseEndBoth = function(this1) {
	if(this1 != 19) {
		return this1 == 20;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_thisAbstract = function(this1) {
	return this1;
};
cornerContour_StyleEndLine.get_isArc = function(this1) {
	if(!(this1 == 1 || this1 == 2)) {
		return this1 == 3;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isForButton = function(this1) {
	if(this1 != 5) {
		return this1 == 4;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isArrow = function(this1) {
	if(!(this1 == 9 || this1 == 10)) {
		return this1 == 11;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isArrowEnding = function(this1) {
	if(this1 != 10) {
		return this1 == 11;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isTriangle = function(this1) {
	if(!(this1 == 6 || this1 == 7)) {
		return this1 == 8;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isSquare = function(this1) {
	if(!(this1 == 15 || this1 == 16)) {
		return this1 == 17;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isCircle = function(this1) {
	if(!(this1 == 12 || this1 == 13)) {
		return this1 == 14;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isEllipse = function(this1) {
	if(!(this1 == 18 || this1 == 19)) {
		return this1 == 20;
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isBeginLine = function(this1) {
	switch(this1) {
	case 1:case 3:case 4:case 5:case 6:case 8:case 9:case 11:case 12:case 14:case 15:case 17:case 18:case 20:
		return true;
	case 0:case 2:case 7:case 10:case 13:case 16:case 19:
		return false;
	}
};
cornerContour_StyleEndLine.get_isBeginSymetrical = function(this1) {
	switch(this1) {
	case 1:case 3:case 6:case 8:case 9:case 11:case 12:case 14:case 15:case 17:case 18:case 20:
		return true;
	case 0:case 2:case 4:case 5:case 7:case 10:case 13:case 16:case 19:
		return false;
	}
};
cornerContour_StyleEndLine.get_isEndLine = function(this1) {
	switch(this1) {
	case 0:case 1:case 6:case 9:case 12:case 15:case 18:
		return false;
	case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
		return true;
	}
};
cornerContour_StyleEndLine.get_isEndSymetrical = function(this1) {
	switch(this1) {
	case 0:case 1:case 6:case 9:case 12:case 15:case 18:
		return false;
	case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
		return true;
	}
};
cornerContour_StyleEndLine.get_isBothLine = function(this1) {
	switch(this1) {
	case 0:case 1:case 2:case 6:case 7:case 9:case 10:case 12:case 13:case 15:case 16:case 18:case 19:
		return false;
	case 3:case 4:case 5:case 8:case 11:case 14:case 17:case 20:
		return true;
	}
};
cornerContour_StyleEndLine.get_hasCurves = function(this1) {
	switch(this1) {
	case 1:case 2:case 3:case 4:case 5:case 12:case 13:case 14:case 18:case 19:case 20:
		return true;
	case 0:case 6:case 7:case 8:case 9:case 10:case 11:case 15:case 16:case 17:
		return false;
	}
};
cornerContour_StyleEndLine.get_isStraightEdgesBegins = function(this1) {
	if(!(this1 == 6 || this1 == 8 || (this1 == 9 || this1 == 11))) {
		if(this1 != 15) {
			return this1 == 17;
		} else {
			return true;
		}
	} else {
		return true;
	}
};
cornerContour_StyleEndLine.get_isStraightEdgesEnds = function(this1) {
	if(!(this1 == 7 || this1 == 8 || (this1 == 10 || this1 == 11))) {
		if(this1 != 16) {
			return this1 == 17;
		} else {
			return true;
		}
	} else {
		return true;
	}
};
var cornerContour_color_ColorHelp = function() {
	this.argbIntAvg_ = cornerContour_color_ColorHelp_argbIntAvg;
	this.blueAvg_ = cornerContour_color_ColorHelp_blueAvg;
	this.greenAvg_ = cornerContour_color_ColorHelp_greenAvg;
	this.redAvg_ = cornerContour_color_ColorHelp_redAvg;
	this.alphaAvg_ = cornerContour_color_ColorHelp_alphaAvg;
	this.argbInt_ = cornerContour_color_ColorHelp_argbInt;
	this.blueChannel_ = cornerContour_color_ColorHelp_blueChannel;
	this.greenChannel_ = cornerContour_color_ColorHelp_greenChannel;
	this.redChannel_ = cornerContour_color_ColorHelp_redChannel;
	this.alphaChannel_ = cornerContour_color_ColorHelp_alphaChannel;
	this.toHexInt_ = cornerContour_color_ColorHelp_toHexInt;
	this.from_argb_ = cornerContour_color_ColorHelp_from_argb;
};
cornerContour_color_ColorHelp.__name__ = true;
function cornerContour_color_ColorHelp_alphaChannel(int) {
	return (int >> 24 & 255) / 255;
}
function cornerContour_color_ColorHelp_redChannel(int) {
	return (int >> 16 & 255) / 255;
}
function cornerContour_color_ColorHelp_greenChannel(int) {
	return (int >> 8 & 255) / 255;
}
function cornerContour_color_ColorHelp_blueChannel(int) {
	return (int & 255) / 255;
}
function cornerContour_color_ColorHelp_argbInt(a,r,g,b) {
	return a << 24 | r << 16 | g << 8 | b;
}
function cornerContour_color_ColorHelp_alphaAvg(a,b) {
	return ((a >> 24 & 255) / 255 + (b >> 24 & 255) / 255) / 2;
}
function cornerContour_color_ColorHelp_alphaBetween(a,b,t0) {
	if(t0 == null) {
		t0 = 0.5;
	}
	var t1 = 1. - t0;
	return t0 * ((a >> 24 & 255) / 255) + t1 * ((b >> 24 & 255) / 255);
}
function cornerContour_color_ColorHelp_redAvg(a,b) {
	return ((a >> 16 & 255) / 255 + (b >> 16 & 255) / 255) / 2;
}
function cornerContour_color_ColorHelp_redBetween(a,b,t0) {
	if(t0 == null) {
		t0 = 0.5;
	}
	var t1 = 1. - t0;
	return t0 * ((a >> 16 & 255) / 255) + t1 * ((b >> 16 & 255) / 255);
}
function cornerContour_color_ColorHelp_greenAvg(a,b) {
	return ((a >> 8 & 255) / 255 + (b >> 8 & 255) / 255) / 2;
}
function cornerContour_color_ColorHelp_greenBetween(a,b,t0) {
	if(t0 == null) {
		t0 = 0.5;
	}
	var t1 = 1. - t0;
	return t0 * ((a >> 8 & 255) / 255) + t1 * ((b >> 8 & 255) / 255);
}
function cornerContour_color_ColorHelp_blueAvg(a,b) {
	return ((a & 255) / 255 + (b & 255) / 255) / 2;
}
function cornerContour_color_ColorHelp_blueBetween(a,b,t0) {
	if(t0 == null) {
		t0 = 0.5;
	}
	var t1 = 1. - t0;
	return t0 * ((a & 255) / 255) + t1 * ((b & 255) / 255);
}
function cornerContour_color_ColorHelp_toHexInt(c) {
	return Math.round(c * 255);
}
function cornerContour_color_ColorHelp_from_argb(a,r,g,b) {
	return Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
}
function cornerContour_color_ColorHelp_argbIntBetween(c0,c1,t) {
	if(t == null) {
		t = 0.5;
	}
	var t0 = t;
	if(t0 == null) {
		t0 = 0.5;
	}
	var t1 = 1. - t0;
	var a = t0 * ((c0 >> 24 & 255) / 255) + t1 * ((c1 >> 24 & 255) / 255);
	var t0 = t;
	if(t0 == null) {
		t0 = 0.5;
	}
	var t1 = 1. - t0;
	var r = t0 * ((c0 >> 16 & 255) / 255) + t1 * ((c1 >> 16 & 255) / 255);
	var t0 = t;
	if(t0 == null) {
		t0 = 0.5;
	}
	var t1 = 1. - t0;
	var g = t0 * ((c0 >> 8 & 255) / 255) + t1 * ((c1 >> 8 & 255) / 255);
	var t0 = t;
	if(t0 == null) {
		t0 = 0.5;
	}
	var t1 = 1. - t0;
	var b = t0 * ((c0 & 255) / 255) + t1 * ((c1 & 255) / 255);
	return Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
}
function cornerContour_color_ColorHelp_argbIntAvg(c0,c1) {
	var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
	var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
	var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
	var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
	return Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
}
var cornerContour_color_TwoGrad_$ = function(colorClock,colorAnti) {
	this.colorClock = colorClock;
	this.colorAnti = colorAnti;
};
cornerContour_color_TwoGrad_$.__name__ = true;
var cornerContour_color_TwoGrad = {};
cornerContour_color_TwoGrad._new = function(colorClock,colorAnti) {
	var this1 = new cornerContour_color_TwoGrad_$(colorClock,colorAnti);
	return this1;
};
cornerContour_color_TwoGrad.average = function(this1) {
	var c0 = this1.colorClock;
	var c1 = this1.colorAnti;
	var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
	var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
	var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
	var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
	return Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
};
var cornerContour_io_Array2DTriGrad = {};
cornerContour_io_Array2DTriGrad._new = function() {
	var this1 = [];
	this1[0] = 0.;
	var this2 = this1;
	var this1 = this2;
	var this2 = this1;
	return this2;
};
cornerContour_io_Array2DTriGrad.create = function() {
	var this1 = [];
	this1[0] = 0.;
	var this2 = this1;
	var this1 = this2;
	var this2 = this1;
	return this2;
};
cornerContour_io_Array2DTriGrad.get_ax = function(this1) {
	return this1[(this1[0] | 0) * 9 + 1];
};
cornerContour_io_Array2DTriGrad.set_ax = function(this1,v) {
	this1[(this1[0] | 0) * 9 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriGrad.get_ay = function(this1) {
	return this1[(this1[0] | 0) * 9 + 1 + 1];
};
cornerContour_io_Array2DTriGrad.set_ay = function(this1,v) {
	this1[(this1[0] | 0) * 9 + 1 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriGrad.get_bx = function(this1) {
	return this1[(this1[0] | 0) * 9 + 2 + 1];
};
cornerContour_io_Array2DTriGrad.set_bx = function(this1,v) {
	this1[(this1[0] | 0) * 9 + 2 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriGrad.get_by = function(this1) {
	return this1[(this1[0] | 0) * 9 + 3 + 1];
};
cornerContour_io_Array2DTriGrad.set_by = function(this1,v) {
	this1[(this1[0] | 0) * 9 + 3 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriGrad.get_cx = function(this1) {
	return this1[(this1[0] | 0) * 9 + 4 + 1];
};
cornerContour_io_Array2DTriGrad.set_cx = function(this1,v) {
	this1[(this1[0] | 0) * 9 + 4 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriGrad.get_cy = function(this1) {
	return this1[(this1[0] | 0) * 9 + 5 + 1];
};
cornerContour_io_Array2DTriGrad.set_cy = function(this1,v) {
	this1[(this1[0] | 0) * 9 + 5 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriGrad.get_colorA = function(this1) {
	return this1[(this1[0] | 0) * 9 + 6 + 1];
};
cornerContour_io_Array2DTriGrad.set_colorA = function(this1,v) {
	this1[(this1[0] | 0) * 9 + 6 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriGrad.get_colorIntA = function(this1) {
	return Math.round(this1[(this1[0] | 0) * 9 + 6 + 1]);
};
cornerContour_io_Array2DTriGrad.set_colorIntA = function(this1,v) {
	var v1 = v | 0;
	this1[(this1[0] | 0) * 9 + 6 + 1] = v1;
	return v;
};
cornerContour_io_Array2DTriGrad.get_colorB = function(this1) {
	return this1[(this1[0] | 0) * 9 + 7 + 1];
};
cornerContour_io_Array2DTriGrad.set_colorB = function(this1,v) {
	this1[(this1[0] | 0) * 9 + 7 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriGrad.get_colorIntB = function(this1) {
	return Math.round(this1[(this1[0] | 0) * 9 + 7 + 1]);
};
cornerContour_io_Array2DTriGrad.set_colorIntB = function(this1,v) {
	var v1 = v | 0;
	this1[(this1[0] | 0) * 9 + 7 + 1] = v1;
	return v;
};
cornerContour_io_Array2DTriGrad.get_colorC = function(this1) {
	return this1[(this1[0] | 0) * 9 + 8 + 1];
};
cornerContour_io_Array2DTriGrad.set_colorC = function(this1,v) {
	this1[(this1[0] | 0) * 9 + 8 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriGrad.get_colorIntC = function(this1) {
	return Math.round(this1[(this1[0] | 0) * 9 + 8 + 1]);
};
cornerContour_io_Array2DTriGrad.set_colorIntC = function(this1,v) {
	var v1 = v | 0;
	this1[(this1[0] | 0) * 9 + 8 + 1] = v1;
	return v;
};
cornerContour_io_Array2DTriGrad.triangle2DFill = function(this1,ax_,ay_,bx_,by_,cx_,cy_,color_) {
	cornerContour_io_Array2DTriGrad.triangle(this1,ax_,ay_,bx_,by_,cx_,cy_);
	if(color_ == null) {
		cornerContour_io_Array2DTriGrad.set_colorIntA(this1,16711680);
	} else {
		cornerContour_io_Array2DTriGrad.set_colorIntA(this1,color_);
	}
	if(color_ == null) {
		cornerContour_io_Array2DTriGrad.set_colorIntB(this1,16711680);
	} else {
		cornerContour_io_Array2DTriGrad.set_colorIntB(this1,color_);
	}
	if(color_ == null) {
		cornerContour_io_Array2DTriGrad.set_colorIntC(this1,16711680);
	} else {
		cornerContour_io_Array2DTriGrad.set_colorIntC(this1,color_);
	}
	return 1;
};
cornerContour_io_Array2DTriGrad.triangle2DGrad = function(this1,ax_,ay_,bx_,by_,cx_,cy_,colorA_,colorB_,colorC_) {
	cornerContour_io_Array2DTriGrad.triangle(this1,ax_,ay_,bx_,by_,cx_,cy_);
	if(colorA_ == null) {
		cornerContour_io_Array2DTriGrad.set_colorIntA(this1,16711680);
	} else {
		cornerContour_io_Array2DTriGrad.set_colorIntA(this1,colorA_);
	}
	if(colorB_ == null) {
		cornerContour_io_Array2DTriGrad.set_colorIntB(this1,16711680);
	} else {
		cornerContour_io_Array2DTriGrad.set_colorIntB(this1,colorB_);
	}
	if(colorC_ == null) {
		cornerContour_io_Array2DTriGrad.set_colorIntC(this1,16711680);
	} else {
		cornerContour_io_Array2DTriGrad.set_colorIntC(this1,colorC_);
	}
	return 1;
};
cornerContour_io_Array2DTriGrad.triangle = function(this1,ax_,ay_,bx_,by_,cx_,cy_) {
	cornerContour_io_Array2DTriGrad.set_ax(this1,ax_);
	cornerContour_io_Array2DTriGrad.set_ay(this1,ay_);
	cornerContour_io_Array2DTriGrad.set_bx(this1,bx_);
	cornerContour_io_Array2DTriGrad.set_by(this1,by_);
	cornerContour_io_Array2DTriGrad.set_cx(this1,cx_);
	cornerContour_io_Array2DTriGrad.set_cy(this1,cy_);
	var windingAdjusted = cornerContour_io_Array2DTriGrad.adjustWinding(this1);
	if(windingAdjusted) {
		cornerContour_io_Array2DTriGrad.set_ax(this1,ax_);
		cornerContour_io_Array2DTriGrad.set_ay(this1,ay_);
		cornerContour_io_Array2DTriGrad.set_bx(this1,cx_);
		cornerContour_io_Array2DTriGrad.set_by(this1,cy_);
		cornerContour_io_Array2DTriGrad.set_cx(this1,bx_);
		cornerContour_io_Array2DTriGrad.set_cy(this1,by_);
	}
	return windingAdjusted;
};
cornerContour_io_Array2DTriGrad.adjustWinding = function(this1) {
	return cornerContour_io_Array2DTriGrad.get_ax(this1) * cornerContour_io_Array2DTriGrad.get_by(this1) - cornerContour_io_Array2DTriGrad.get_bx(this1) * cornerContour_io_Array2DTriGrad.get_ay(this1) + (cornerContour_io_Array2DTriGrad.get_bx(this1) * cornerContour_io_Array2DTriGrad.get_cy(this1) - cornerContour_io_Array2DTriGrad.get_cx(this1) * cornerContour_io_Array2DTriGrad.get_by(this1)) + (cornerContour_io_Array2DTriGrad.get_cx(this1) * cornerContour_io_Array2DTriGrad.get_ay(this1) - cornerContour_io_Array2DTriGrad.get_ax(this1) * cornerContour_io_Array2DTriGrad.get_cy(this1)) > 0;
};
cornerContour_io_Array2DTriGrad.get_x = function(this1) {
	return Math.min(Math.min(cornerContour_io_Array2DTriGrad.get_ax(this1),cornerContour_io_Array2DTriGrad.get_bx(this1)),cornerContour_io_Array2DTriGrad.get_cx(this1));
};
cornerContour_io_Array2DTriGrad.set_x = function(this1,x) {
	var dx = x - Math.min(Math.min(cornerContour_io_Array2DTriGrad.get_ax(this1),cornerContour_io_Array2DTriGrad.get_bx(this1)),cornerContour_io_Array2DTriGrad.get_cx(this1));
	cornerContour_io_Array2DTriGrad.set_ax(this1,cornerContour_io_Array2DTriGrad.get_ax(this1) + dx);
	cornerContour_io_Array2DTriGrad.set_bx(this1,cornerContour_io_Array2DTriGrad.get_bx(this1) + dx);
	cornerContour_io_Array2DTriGrad.set_cx(this1,cornerContour_io_Array2DTriGrad.get_cx(this1) + dx);
	return x;
};
cornerContour_io_Array2DTriGrad.get_y = function(this1) {
	return Math.max(Math.max(cornerContour_io_Array2DTriGrad.get_ay(this1),cornerContour_io_Array2DTriGrad.get_by(this1)),cornerContour_io_Array2DTriGrad.get_cy(this1));
};
cornerContour_io_Array2DTriGrad.set_y = function(this1,y) {
	var dy = y - Math.max(Math.max(cornerContour_io_Array2DTriGrad.get_ay(this1),cornerContour_io_Array2DTriGrad.get_by(this1)),cornerContour_io_Array2DTriGrad.get_cy(this1));
	cornerContour_io_Array2DTriGrad.set_ay(this1,cornerContour_io_Array2DTriGrad.get_ay(this1) + dy);
	cornerContour_io_Array2DTriGrad.set_by(this1,cornerContour_io_Array2DTriGrad.get_by(this1) + dy);
	cornerContour_io_Array2DTriGrad.set_cy(this1,cornerContour_io_Array2DTriGrad.get_cy(this1) + dy);
	return y;
};
cornerContour_io_Array2DTriGrad.get_right = function(this1) {
	return Math.max(Math.max(cornerContour_io_Array2DTriGrad.get_ax(this1),cornerContour_io_Array2DTriGrad.get_bx(this1)),cornerContour_io_Array2DTriGrad.get_cx(this1));
};
cornerContour_io_Array2DTriGrad.get_bottom = function(this1) {
	return Math.max(Math.max(cornerContour_io_Array2DTriGrad.get_ay(this1),cornerContour_io_Array2DTriGrad.get_by(this1)),cornerContour_io_Array2DTriGrad.get_cy(this1));
};
cornerContour_io_Array2DTriGrad.moveDelta = function(this1,dx,dy) {
	cornerContour_io_Array2DTriGrad.set_ax(this1,cornerContour_io_Array2DTriGrad.get_ax(this1) + dx);
	cornerContour_io_Array2DTriGrad.set_ay(this1,cornerContour_io_Array2DTriGrad.get_ay(this1) + dy);
	cornerContour_io_Array2DTriGrad.set_bx(this1,cornerContour_io_Array2DTriGrad.get_bx(this1) + dx);
	cornerContour_io_Array2DTriGrad.set_by(this1,cornerContour_io_Array2DTriGrad.get_by(this1) + dy);
	cornerContour_io_Array2DTriGrad.set_cx(this1,cornerContour_io_Array2DTriGrad.get_cx(this1) + dx);
	cornerContour_io_Array2DTriGrad.set_cy(this1,cornerContour_io_Array2DTriGrad.get_cy(this1) + dy);
};
cornerContour_io_Array2DTriGrad.sign = function(n) {
	return Math.abs(n) / n | 0;
};
cornerContour_io_Array2DTriGrad.distHit = function(this1,px,py) {
	var planeAB = (cornerContour_io_Array2DTriGrad.get_ax(this1) - px) * (cornerContour_io_Array2DTriGrad.get_by(this1) - py) - (cornerContour_io_Array2DTriGrad.get_bx(this1) - px) * (cornerContour_io_Array2DTriGrad.get_ay(this1) - py);
	var planeBC = (cornerContour_io_Array2DTriGrad.get_bx(this1) - px) * (cornerContour_io_Array2DTriGrad.get_cy(this1) - py) - (cornerContour_io_Array2DTriGrad.get_cx(this1) - px) * (cornerContour_io_Array2DTriGrad.get_by(this1) - py);
	var planeCA = (cornerContour_io_Array2DTriGrad.get_cx(this1) - px) * (cornerContour_io_Array2DTriGrad.get_ay(this1) - py) - (cornerContour_io_Array2DTriGrad.get_ax(this1) - px) * (cornerContour_io_Array2DTriGrad.get_cy(this1) - py);
	if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0) && (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0)) {
		return 0;
	}
	var dA = Math.pow(Math.pow(px - cornerContour_io_Array2DTriGrad.get_ax(this1),2) + Math.pow(py - cornerContour_io_Array2DTriGrad.get_ay(this1),2),0.5);
	var dB = Math.pow(Math.pow(px - cornerContour_io_Array2DTriGrad.get_bx(this1),2) + Math.pow(py - cornerContour_io_Array2DTriGrad.get_by(this1),2),0.5);
	var dC = Math.pow(Math.pow(px - cornerContour_io_Array2DTriGrad.get_cx(this1),2) + Math.pow(py - cornerContour_io_Array2DTriGrad.get_cy(this1),2),0.5);
	return Math.min(Math.min(dA,dB),dC);
};
cornerContour_io_Array2DTriGrad.liteHit = function(this1,px,py) {
	var planeAB = (cornerContour_io_Array2DTriGrad.get_ax(this1) - px) * (cornerContour_io_Array2DTriGrad.get_by(this1) - py) - (cornerContour_io_Array2DTriGrad.get_bx(this1) - px) * (cornerContour_io_Array2DTriGrad.get_ay(this1) - py);
	var planeBC = (cornerContour_io_Array2DTriGrad.get_bx(this1) - px) * (cornerContour_io_Array2DTriGrad.get_cy(this1) - py) - (cornerContour_io_Array2DTriGrad.get_cx(this1) - px) * (cornerContour_io_Array2DTriGrad.get_by(this1) - py);
	var planeCA = (cornerContour_io_Array2DTriGrad.get_cx(this1) - px) * (cornerContour_io_Array2DTriGrad.get_ay(this1) - py) - (cornerContour_io_Array2DTriGrad.get_ax(this1) - px) * (cornerContour_io_Array2DTriGrad.get_cy(this1) - py);
	if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
		return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
	} else {
		return false;
	}
};
cornerContour_io_Array2DTriGrad.fullHit = function(this1,px,py) {
	if(px > Math.min(Math.min(cornerContour_io_Array2DTriGrad.get_ax(this1),cornerContour_io_Array2DTriGrad.get_bx(this1)),cornerContour_io_Array2DTriGrad.get_cx(this1)) && px < Math.max(Math.max(cornerContour_io_Array2DTriGrad.get_ax(this1),cornerContour_io_Array2DTriGrad.get_bx(this1)),cornerContour_io_Array2DTriGrad.get_cx(this1)) && py > Math.max(Math.max(cornerContour_io_Array2DTriGrad.get_ay(this1),cornerContour_io_Array2DTriGrad.get_by(this1)),cornerContour_io_Array2DTriGrad.get_cy(this1)) && py < Math.max(Math.max(cornerContour_io_Array2DTriGrad.get_ay(this1),cornerContour_io_Array2DTriGrad.get_by(this1)),cornerContour_io_Array2DTriGrad.get_cy(this1))) {
		return true;
	}
	var planeAB = (cornerContour_io_Array2DTriGrad.get_ax(this1) - px) * (cornerContour_io_Array2DTriGrad.get_by(this1) - py) - (cornerContour_io_Array2DTriGrad.get_bx(this1) - px) * (cornerContour_io_Array2DTriGrad.get_ay(this1) - py);
	var planeBC = (cornerContour_io_Array2DTriGrad.get_bx(this1) - px) * (cornerContour_io_Array2DTriGrad.get_cy(this1) - py) - (cornerContour_io_Array2DTriGrad.get_cx(this1) - px) * (cornerContour_io_Array2DTriGrad.get_by(this1) - py);
	var planeCA = (cornerContour_io_Array2DTriGrad.get_cx(this1) - px) * (cornerContour_io_Array2DTriGrad.get_ay(this1) - py) - (cornerContour_io_Array2DTriGrad.get_ax(this1) - px) * (cornerContour_io_Array2DTriGrad.get_cy(this1) - py);
	if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
		return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
	} else {
		return false;
	}
};
cornerContour_io_Array2DTriGrad.rotate = function(this1,x,y,theta) {
	var cos = Math.cos(-theta);
	var sin = Math.sin(-theta);
	cornerContour_io_Array2DTriGrad.set_ax(this1,cornerContour_io_Array2DTriGrad.get_ax(this1) - x);
	cornerContour_io_Array2DTriGrad.set_ay(this1,cornerContour_io_Array2DTriGrad.get_ay(this1) - y);
	cornerContour_io_Array2DTriGrad.set_bx(this1,cornerContour_io_Array2DTriGrad.get_bx(this1) - x);
	cornerContour_io_Array2DTriGrad.set_by(this1,cornerContour_io_Array2DTriGrad.get_by(this1) - y);
	cornerContour_io_Array2DTriGrad.set_cx(this1,cornerContour_io_Array2DTriGrad.get_cx(this1) - x);
	cornerContour_io_Array2DTriGrad.set_cy(this1,cornerContour_io_Array2DTriGrad.get_cy(this1) - y);
	var dx = cornerContour_io_Array2DTriGrad.get_ax(this1);
	var dy = cornerContour_io_Array2DTriGrad.get_ay(this1);
	cornerContour_io_Array2DTriGrad.set_ax(this1,dx * cos - dy * sin);
	cornerContour_io_Array2DTriGrad.set_ay(this1,dx * sin + dy * cos);
	dx = cornerContour_io_Array2DTriGrad.get_bx(this1);
	dy = cornerContour_io_Array2DTriGrad.get_by(this1);
	cornerContour_io_Array2DTriGrad.set_bx(this1,dx * cos - dy * sin);
	cornerContour_io_Array2DTriGrad.set_by(this1,dx * sin + dy * cos);
	dx = cornerContour_io_Array2DTriGrad.get_cx(this1);
	dy = cornerContour_io_Array2DTriGrad.get_cy(this1);
	cornerContour_io_Array2DTriGrad.set_cx(this1,dx * cos - dy * sin);
	cornerContour_io_Array2DTriGrad.set_cy(this1,dx * sin + dy * cos);
	cornerContour_io_Array2DTriGrad.set_ax(this1,cornerContour_io_Array2DTriGrad.get_ax(this1) + x);
	cornerContour_io_Array2DTriGrad.set_ay(this1,cornerContour_io_Array2DTriGrad.get_ay(this1) + y);
	cornerContour_io_Array2DTriGrad.set_bx(this1,cornerContour_io_Array2DTriGrad.get_bx(this1) + x);
	cornerContour_io_Array2DTriGrad.set_by(this1,cornerContour_io_Array2DTriGrad.get_by(this1) + y);
	cornerContour_io_Array2DTriGrad.set_cx(this1,cornerContour_io_Array2DTriGrad.get_cx(this1) + x);
	cornerContour_io_Array2DTriGrad.set_cy(this1,cornerContour_io_Array2DTriGrad.get_cy(this1) + y);
};
cornerContour_io_Array2DTriGrad.rotateTrig = function(this1,x,y,cos,sin) {
	cornerContour_io_Array2DTriGrad.set_ax(this1,cornerContour_io_Array2DTriGrad.get_ax(this1) - x);
	cornerContour_io_Array2DTriGrad.set_ay(this1,cornerContour_io_Array2DTriGrad.get_ay(this1) - y);
	cornerContour_io_Array2DTriGrad.set_bx(this1,cornerContour_io_Array2DTriGrad.get_bx(this1) - x);
	cornerContour_io_Array2DTriGrad.set_by(this1,cornerContour_io_Array2DTriGrad.get_by(this1) - y);
	cornerContour_io_Array2DTriGrad.set_cx(this1,cornerContour_io_Array2DTriGrad.get_cx(this1) - x);
	cornerContour_io_Array2DTriGrad.set_cy(this1,cornerContour_io_Array2DTriGrad.get_cy(this1) - y);
	var dx = cornerContour_io_Array2DTriGrad.get_ax(this1);
	var dy = cornerContour_io_Array2DTriGrad.get_ay(this1);
	cornerContour_io_Array2DTriGrad.set_ax(this1,dx * cos - dy * sin);
	cornerContour_io_Array2DTriGrad.set_ay(this1,dx * sin + dy * cos);
	dx = cornerContour_io_Array2DTriGrad.get_bx(this1);
	dy = cornerContour_io_Array2DTriGrad.get_by(this1);
	cornerContour_io_Array2DTriGrad.set_bx(this1,dx * cos - dy * sin);
	cornerContour_io_Array2DTriGrad.set_by(this1,dx * sin + dy * cos);
	dx = cornerContour_io_Array2DTriGrad.get_cx(this1);
	dy = cornerContour_io_Array2DTriGrad.get_cy(this1);
	cornerContour_io_Array2DTriGrad.set_cx(this1,dx * cos - dy * sin);
	cornerContour_io_Array2DTriGrad.set_cy(this1,dx * sin + dy * cos);
	cornerContour_io_Array2DTriGrad.set_ax(this1,cornerContour_io_Array2DTriGrad.get_ax(this1) + x);
	cornerContour_io_Array2DTriGrad.set_ay(this1,cornerContour_io_Array2DTriGrad.get_ay(this1) + y);
	cornerContour_io_Array2DTriGrad.set_bx(this1,cornerContour_io_Array2DTriGrad.get_bx(this1) + x);
	cornerContour_io_Array2DTriGrad.set_by(this1,cornerContour_io_Array2DTriGrad.get_by(this1) + y);
	cornerContour_io_Array2DTriGrad.set_cx(this1,cornerContour_io_Array2DTriGrad.get_cx(this1) + x);
	cornerContour_io_Array2DTriGrad.set_cy(this1,cornerContour_io_Array2DTriGrad.get_cy(this1) + y);
};
cornerContour_io_Array2DTriGrad.prettyString = function(this1) {
	return "{ ax: " + cornerContour_io_Array2DTriGrad.get_ax(this1) + ", ay: " + cornerContour_io_Array2DTriGrad.get_ay(this1) + " }" + "\n" + "{ bx: " + cornerContour_io_Array2DTriGrad.get_bx(this1) + ", by: " + cornerContour_io_Array2DTriGrad.get_by(this1) + " }" + "\n" + "{ cx: " + cornerContour_io_Array2DTriGrad.get_cx(this1) + ", cy: " + cornerContour_io_Array2DTriGrad.get_cy(this1) + " }" + "\n" + "{ colorA: " + cornerContour_io_Array2DTriGrad.get_colorA(this1) + ", colorB: " + cornerContour_io_Array2DTriGrad.get_colorB(this1) + "colorC: " + cornerContour_io_Array2DTriGrad.get_colorC(this1) + " }" + "\n";
};
cornerContour_io_Array2DTriGrad.hex = function(this1,col) {
	return "0x" + StringTools.hex(col);
};
cornerContour_io_Array2DTriGrad.hexA = function(this1) {
	return "0x" + StringTools.hex(cornerContour_io_Array2DTriGrad.get_colorIntA(this1));
};
cornerContour_io_Array2DTriGrad.hexB = function(this1) {
	return "0x" + StringTools.hex(cornerContour_io_Array2DTriGrad.get_colorIntB(this1));
};
cornerContour_io_Array2DTriGrad.hexC = function(this1) {
	return "0x" + StringTools.hex(cornerContour_io_Array2DTriGrad.get_colorIntC(this1));
};
var cornerContour_io_Array2DTriangles = {};
cornerContour_io_Array2DTriangles._new = function() {
	var this1 = [];
	this1[0] = 0.;
	var this2 = this1;
	var this1 = this2;
	var this2 = this1;
	return this2;
};
cornerContour_io_Array2DTriangles.create = function() {
	var this1 = [];
	this1[0] = 0.;
	var this2 = this1;
	var this1 = this2;
	var this2 = this1;
	return this2;
};
cornerContour_io_Array2DTriangles.get_ax = function(this1) {
	return this1[(this1[0] | 0) * 7 + 1];
};
cornerContour_io_Array2DTriangles.set_ax = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_ay = function(this1) {
	return this1[(this1[0] | 0) * 7 + 1 + 1];
};
cornerContour_io_Array2DTriangles.set_ay = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 1 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_bx = function(this1) {
	return this1[(this1[0] | 0) * 7 + 2 + 1];
};
cornerContour_io_Array2DTriangles.set_bx = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 2 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_by = function(this1) {
	return this1[(this1[0] | 0) * 7 + 3 + 1];
};
cornerContour_io_Array2DTriangles.set_by = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 3 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_cx = function(this1) {
	return this1[(this1[0] | 0) * 7 + 4 + 1];
};
cornerContour_io_Array2DTriangles.set_cx = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 4 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_cy = function(this1) {
	return this1[(this1[0] | 0) * 7 + 5 + 1];
};
cornerContour_io_Array2DTriangles.set_cy = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 5 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_color = function(this1) {
	return this1[(this1[0] | 0) * 7 + 6 + 1];
};
cornerContour_io_Array2DTriangles.set_color = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 6 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_colorInt = function(this1) {
	return Math.round(this1[(this1[0] | 0) * 7 + 6 + 1]);
};
cornerContour_io_Array2DTriangles.set_colorInt = function(this1,v) {
	var v1 = v | 0;
	this1[(this1[0] | 0) * 7 + 6 + 1] = v1;
	return v;
};
cornerContour_io_Array2DTriangles.triangle2DFill = function(this1,ax_,ay_,bx_,by_,cx_,cy_,color_) {
	cornerContour_io_Array2DTriangles.triangle(this1,ax_,ay_,bx_,by_,cx_,cy_);
	if(color_ == null) {
		cornerContour_io_Array2DTriangles.set_colorInt(this1,16711680);
	} else {
		cornerContour_io_Array2DTriangles.set_colorInt(this1,color_);
	}
	return 1;
};
cornerContour_io_Array2DTriangles.triangle = function(this1,ax_,ay_,bx_,by_,cx_,cy_) {
	cornerContour_io_Array2DTriangles.set_ax(this1,ax_);
	cornerContour_io_Array2DTriangles.set_ay(this1,ay_);
	cornerContour_io_Array2DTriangles.set_bx(this1,bx_);
	cornerContour_io_Array2DTriangles.set_by(this1,by_);
	cornerContour_io_Array2DTriangles.set_cx(this1,cx_);
	cornerContour_io_Array2DTriangles.set_cy(this1,cy_);
	var windingAdjusted = cornerContour_io_Array2DTriangles.adjustWinding(this1);
	if(windingAdjusted) {
		cornerContour_io_Array2DTriangles.set_ax(this1,ax_);
		cornerContour_io_Array2DTriangles.set_ay(this1,ay_);
		cornerContour_io_Array2DTriangles.set_bx(this1,cx_);
		cornerContour_io_Array2DTriangles.set_by(this1,cy_);
		cornerContour_io_Array2DTriangles.set_cx(this1,bx_);
		cornerContour_io_Array2DTriangles.set_cy(this1,by_);
	}
	return windingAdjusted;
};
cornerContour_io_Array2DTriangles.adjustWinding = function(this1) {
	return cornerContour_io_Array2DTriangles.get_ax(this1) * cornerContour_io_Array2DTriangles.get_by(this1) - cornerContour_io_Array2DTriangles.get_bx(this1) * cornerContour_io_Array2DTriangles.get_ay(this1) + (cornerContour_io_Array2DTriangles.get_bx(this1) * cornerContour_io_Array2DTriangles.get_cy(this1) - cornerContour_io_Array2DTriangles.get_cx(this1) * cornerContour_io_Array2DTriangles.get_by(this1)) + (cornerContour_io_Array2DTriangles.get_cx(this1) * cornerContour_io_Array2DTriangles.get_ay(this1) - cornerContour_io_Array2DTriangles.get_ax(this1) * cornerContour_io_Array2DTriangles.get_cy(this1)) > 0;
};
cornerContour_io_Array2DTriangles.get_x = function(this1) {
	return Math.min(Math.min(cornerContour_io_Array2DTriangles.get_ax(this1),cornerContour_io_Array2DTriangles.get_bx(this1)),cornerContour_io_Array2DTriangles.get_cx(this1));
};
cornerContour_io_Array2DTriangles.set_x = function(this1,x) {
	var dx = x - Math.min(Math.min(cornerContour_io_Array2DTriangles.get_ax(this1),cornerContour_io_Array2DTriangles.get_bx(this1)),cornerContour_io_Array2DTriangles.get_cx(this1));
	cornerContour_io_Array2DTriangles.set_ax(this1,cornerContour_io_Array2DTriangles.get_ax(this1) + dx);
	cornerContour_io_Array2DTriangles.set_bx(this1,cornerContour_io_Array2DTriangles.get_bx(this1) + dx);
	cornerContour_io_Array2DTriangles.set_cx(this1,cornerContour_io_Array2DTriangles.get_cx(this1) + dx);
	return x;
};
cornerContour_io_Array2DTriangles.get_y = function(this1) {
	return Math.max(Math.max(cornerContour_io_Array2DTriangles.get_ay(this1),cornerContour_io_Array2DTriangles.get_by(this1)),cornerContour_io_Array2DTriangles.get_cy(this1));
};
cornerContour_io_Array2DTriangles.set_y = function(this1,y) {
	var dy = y - Math.max(Math.max(cornerContour_io_Array2DTriangles.get_ay(this1),cornerContour_io_Array2DTriangles.get_by(this1)),cornerContour_io_Array2DTriangles.get_cy(this1));
	cornerContour_io_Array2DTriangles.set_ay(this1,cornerContour_io_Array2DTriangles.get_ay(this1) + dy);
	cornerContour_io_Array2DTriangles.set_by(this1,cornerContour_io_Array2DTriangles.get_by(this1) + dy);
	cornerContour_io_Array2DTriangles.set_cy(this1,cornerContour_io_Array2DTriangles.get_cy(this1) + dy);
	return y;
};
cornerContour_io_Array2DTriangles.get_right = function(this1) {
	return Math.max(Math.max(cornerContour_io_Array2DTriangles.get_ax(this1),cornerContour_io_Array2DTriangles.get_bx(this1)),cornerContour_io_Array2DTriangles.get_cx(this1));
};
cornerContour_io_Array2DTriangles.get_bottom = function(this1) {
	return Math.max(Math.max(cornerContour_io_Array2DTriangles.get_ay(this1),cornerContour_io_Array2DTriangles.get_by(this1)),cornerContour_io_Array2DTriangles.get_cy(this1));
};
cornerContour_io_Array2DTriangles.moveDelta = function(this1,dx,dy) {
	cornerContour_io_Array2DTriangles.set_ax(this1,cornerContour_io_Array2DTriangles.get_ax(this1) + dx);
	cornerContour_io_Array2DTriangles.set_ay(this1,cornerContour_io_Array2DTriangles.get_ay(this1) + dy);
	cornerContour_io_Array2DTriangles.set_bx(this1,cornerContour_io_Array2DTriangles.get_bx(this1) + dx);
	cornerContour_io_Array2DTriangles.set_by(this1,cornerContour_io_Array2DTriangles.get_by(this1) + dy);
	cornerContour_io_Array2DTriangles.set_cx(this1,cornerContour_io_Array2DTriangles.get_cx(this1) + dx);
	cornerContour_io_Array2DTriangles.set_cy(this1,cornerContour_io_Array2DTriangles.get_cy(this1) + dy);
};
cornerContour_io_Array2DTriangles.sign = function(n) {
	return Math.abs(n) / n | 0;
};
cornerContour_io_Array2DTriangles.distHit = function(this1,px,py) {
	var planeAB = (cornerContour_io_Array2DTriangles.get_ax(this1) - px) * (cornerContour_io_Array2DTriangles.get_by(this1) - py) - (cornerContour_io_Array2DTriangles.get_bx(this1) - px) * (cornerContour_io_Array2DTriangles.get_ay(this1) - py);
	var planeBC = (cornerContour_io_Array2DTriangles.get_bx(this1) - px) * (cornerContour_io_Array2DTriangles.get_cy(this1) - py) - (cornerContour_io_Array2DTriangles.get_cx(this1) - px) * (cornerContour_io_Array2DTriangles.get_by(this1) - py);
	var planeCA = (cornerContour_io_Array2DTriangles.get_cx(this1) - px) * (cornerContour_io_Array2DTriangles.get_ay(this1) - py) - (cornerContour_io_Array2DTriangles.get_ax(this1) - px) * (cornerContour_io_Array2DTriangles.get_cy(this1) - py);
	if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0) && (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0)) {
		return 0;
	}
	var dA = Math.pow(Math.pow(px - cornerContour_io_Array2DTriangles.get_ax(this1),2) + Math.pow(py - cornerContour_io_Array2DTriangles.get_ay(this1),2),0.5);
	var dB = Math.pow(Math.pow(px - cornerContour_io_Array2DTriangles.get_bx(this1),2) + Math.pow(py - cornerContour_io_Array2DTriangles.get_by(this1),2),0.5);
	var dC = Math.pow(Math.pow(px - cornerContour_io_Array2DTriangles.get_cx(this1),2) + Math.pow(py - cornerContour_io_Array2DTriangles.get_cy(this1),2),0.5);
	return Math.min(Math.min(dA,dB),dC);
};
cornerContour_io_Array2DTriangles.liteHit = function(this1,px,py) {
	var planeAB = (cornerContour_io_Array2DTriangles.get_ax(this1) - px) * (cornerContour_io_Array2DTriangles.get_by(this1) - py) - (cornerContour_io_Array2DTriangles.get_bx(this1) - px) * (cornerContour_io_Array2DTriangles.get_ay(this1) - py);
	var planeBC = (cornerContour_io_Array2DTriangles.get_bx(this1) - px) * (cornerContour_io_Array2DTriangles.get_cy(this1) - py) - (cornerContour_io_Array2DTriangles.get_cx(this1) - px) * (cornerContour_io_Array2DTriangles.get_by(this1) - py);
	var planeCA = (cornerContour_io_Array2DTriangles.get_cx(this1) - px) * (cornerContour_io_Array2DTriangles.get_ay(this1) - py) - (cornerContour_io_Array2DTriangles.get_ax(this1) - px) * (cornerContour_io_Array2DTriangles.get_cy(this1) - py);
	if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
		return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
	} else {
		return false;
	}
};
cornerContour_io_Array2DTriangles.fullHit = function(this1,px,py) {
	if(px > Math.min(Math.min(cornerContour_io_Array2DTriangles.get_ax(this1),cornerContour_io_Array2DTriangles.get_bx(this1)),cornerContour_io_Array2DTriangles.get_cx(this1)) && px < Math.max(Math.max(cornerContour_io_Array2DTriangles.get_ax(this1),cornerContour_io_Array2DTriangles.get_bx(this1)),cornerContour_io_Array2DTriangles.get_cx(this1)) && py > Math.max(Math.max(cornerContour_io_Array2DTriangles.get_ay(this1),cornerContour_io_Array2DTriangles.get_by(this1)),cornerContour_io_Array2DTriangles.get_cy(this1)) && py < Math.max(Math.max(cornerContour_io_Array2DTriangles.get_ay(this1),cornerContour_io_Array2DTriangles.get_by(this1)),cornerContour_io_Array2DTriangles.get_cy(this1))) {
		return true;
	}
	var planeAB = (cornerContour_io_Array2DTriangles.get_ax(this1) - px) * (cornerContour_io_Array2DTriangles.get_by(this1) - py) - (cornerContour_io_Array2DTriangles.get_bx(this1) - px) * (cornerContour_io_Array2DTriangles.get_ay(this1) - py);
	var planeBC = (cornerContour_io_Array2DTriangles.get_bx(this1) - px) * (cornerContour_io_Array2DTriangles.get_cy(this1) - py) - (cornerContour_io_Array2DTriangles.get_cx(this1) - px) * (cornerContour_io_Array2DTriangles.get_by(this1) - py);
	var planeCA = (cornerContour_io_Array2DTriangles.get_cx(this1) - px) * (cornerContour_io_Array2DTriangles.get_ay(this1) - py) - (cornerContour_io_Array2DTriangles.get_ax(this1) - px) * (cornerContour_io_Array2DTriangles.get_cy(this1) - py);
	if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
		return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
	} else {
		return false;
	}
};
cornerContour_io_Array2DTriangles.rotate = function(this1,x,y,theta) {
	var cos = Math.cos(-theta);
	var sin = Math.sin(-theta);
	cornerContour_io_Array2DTriangles.set_ax(this1,cornerContour_io_Array2DTriangles.get_ax(this1) - x);
	cornerContour_io_Array2DTriangles.set_ay(this1,cornerContour_io_Array2DTriangles.get_ay(this1) - y);
	cornerContour_io_Array2DTriangles.set_bx(this1,cornerContour_io_Array2DTriangles.get_bx(this1) - x);
	cornerContour_io_Array2DTriangles.set_by(this1,cornerContour_io_Array2DTriangles.get_by(this1) - y);
	cornerContour_io_Array2DTriangles.set_cx(this1,cornerContour_io_Array2DTriangles.get_cx(this1) - x);
	cornerContour_io_Array2DTriangles.set_cy(this1,cornerContour_io_Array2DTriangles.get_cy(this1) - y);
	var dx = cornerContour_io_Array2DTriangles.get_ax(this1);
	var dy = cornerContour_io_Array2DTriangles.get_ay(this1);
	cornerContour_io_Array2DTriangles.set_ax(this1,dx * cos - dy * sin);
	cornerContour_io_Array2DTriangles.set_ay(this1,dx * sin + dy * cos);
	dx = cornerContour_io_Array2DTriangles.get_bx(this1);
	dy = cornerContour_io_Array2DTriangles.get_by(this1);
	cornerContour_io_Array2DTriangles.set_bx(this1,dx * cos - dy * sin);
	cornerContour_io_Array2DTriangles.set_by(this1,dx * sin + dy * cos);
	dx = cornerContour_io_Array2DTriangles.get_cx(this1);
	dy = cornerContour_io_Array2DTriangles.get_cy(this1);
	cornerContour_io_Array2DTriangles.set_cx(this1,dx * cos - dy * sin);
	cornerContour_io_Array2DTriangles.set_cy(this1,dx * sin + dy * cos);
	cornerContour_io_Array2DTriangles.set_ax(this1,cornerContour_io_Array2DTriangles.get_ax(this1) + x);
	cornerContour_io_Array2DTriangles.set_ay(this1,cornerContour_io_Array2DTriangles.get_ay(this1) + y);
	cornerContour_io_Array2DTriangles.set_bx(this1,cornerContour_io_Array2DTriangles.get_bx(this1) + x);
	cornerContour_io_Array2DTriangles.set_by(this1,cornerContour_io_Array2DTriangles.get_by(this1) + y);
	cornerContour_io_Array2DTriangles.set_cx(this1,cornerContour_io_Array2DTriangles.get_cx(this1) + x);
	cornerContour_io_Array2DTriangles.set_cy(this1,cornerContour_io_Array2DTriangles.get_cy(this1) + y);
};
cornerContour_io_Array2DTriangles.rotateTrig = function(this1,x,y,cos,sin) {
	cornerContour_io_Array2DTriangles.set_ax(this1,cornerContour_io_Array2DTriangles.get_ax(this1) - x);
	cornerContour_io_Array2DTriangles.set_ay(this1,cornerContour_io_Array2DTriangles.get_ay(this1) - y);
	cornerContour_io_Array2DTriangles.set_bx(this1,cornerContour_io_Array2DTriangles.get_bx(this1) - x);
	cornerContour_io_Array2DTriangles.set_by(this1,cornerContour_io_Array2DTriangles.get_by(this1) - y);
	cornerContour_io_Array2DTriangles.set_cx(this1,cornerContour_io_Array2DTriangles.get_cx(this1) - x);
	cornerContour_io_Array2DTriangles.set_cy(this1,cornerContour_io_Array2DTriangles.get_cy(this1) - y);
	var dx = cornerContour_io_Array2DTriangles.get_ax(this1);
	var dy = cornerContour_io_Array2DTriangles.get_ay(this1);
	cornerContour_io_Array2DTriangles.set_ax(this1,dx * cos - dy * sin);
	cornerContour_io_Array2DTriangles.set_ay(this1,dx * sin + dy * cos);
	dx = cornerContour_io_Array2DTriangles.get_bx(this1);
	dy = cornerContour_io_Array2DTriangles.get_by(this1);
	cornerContour_io_Array2DTriangles.set_bx(this1,dx * cos - dy * sin);
	cornerContour_io_Array2DTriangles.set_by(this1,dx * sin + dy * cos);
	dx = cornerContour_io_Array2DTriangles.get_cx(this1);
	dy = cornerContour_io_Array2DTriangles.get_cy(this1);
	cornerContour_io_Array2DTriangles.set_cx(this1,dx * cos - dy * sin);
	cornerContour_io_Array2DTriangles.set_cy(this1,dx * sin + dy * cos);
	cornerContour_io_Array2DTriangles.set_ax(this1,cornerContour_io_Array2DTriangles.get_ax(this1) + x);
	cornerContour_io_Array2DTriangles.set_ay(this1,cornerContour_io_Array2DTriangles.get_ay(this1) + y);
	cornerContour_io_Array2DTriangles.set_bx(this1,cornerContour_io_Array2DTriangles.get_bx(this1) + x);
	cornerContour_io_Array2DTriangles.set_by(this1,cornerContour_io_Array2DTriangles.get_by(this1) + y);
	cornerContour_io_Array2DTriangles.set_cx(this1,cornerContour_io_Array2DTriangles.get_cx(this1) + x);
	cornerContour_io_Array2DTriangles.set_cy(this1,cornerContour_io_Array2DTriangles.get_cy(this1) + y);
};
cornerContour_io_Array2DTriangles.prettyString = function(this1) {
	return "{ ax: " + cornerContour_io_Array2DTriangles.get_ax(this1) + ", ay: " + cornerContour_io_Array2DTriangles.get_ay(this1) + " }" + "\n" + "{ bx: " + cornerContour_io_Array2DTriangles.get_bx(this1) + ", by: " + cornerContour_io_Array2DTriangles.get_by(this1) + " }" + "\n" + "{ cx: " + cornerContour_io_Array2DTriangles.get_cx(this1) + ", cy: " + cornerContour_io_Array2DTriangles.get_cy(this1) + " }" + "\n" + "{ color: " + cornerContour_io_Array2DTriangles.get_color(this1) + " }" + "\n";
};
cornerContour_io_Array2DTriangles.hex = function(this1) {
	return "0x" + StringTools.hex(cornerContour_io_Array2DTriangles.get_colorInt(this1));
};
var cornerContour_io_Array7 = {};
cornerContour_io_Array7.readItem = function(this1,k) {
	return this1[(this1[0] | 0) * 7 + k + 1];
};
cornerContour_io_Array7.writeItem = function(this1,k,v) {
	this1[(this1[0] | 0) * 7 + k + 1] = v;
	return v;
};
cornerContour_io_Array7._new = function() {
	var this1 = [];
	this1[0] = 0.;
	var this2 = this1;
	var this1 = this2;
	return this1;
};
cornerContour_io_Array7.get_index = function(this1) {
	return this1[0] | 0;
};
cornerContour_io_Array7.set_index = function(this1,id) {
	this1[0] = id;
	return id;
};
cornerContour_io_Array7.toEnd = function(this1,id,len) {
	return cornerContour_io_ArrayFlatDepth.rangeToEnd(this1,id * 7,7 * len | 0,this1.length - 1);
};
cornerContour_io_Array7.toStart = function(this1,id,len) {
	var starting = id * 7;
	var totalLen = 7 * len | 0;
	if(starting == 0) {
		return false;
	} else {
		var ending = starting + totalLen;
		var temp = [];
		var count = 0;
		var _g = starting;
		var _g1 = ending;
		while(_g < _g1) {
			var i = _g++;
			temp[count] = this1[i + 1];
			++count;
		}
		count = totalLen;
		var _g = 0;
		var _g1 = starting;
		while(_g < _g1) {
			var i = _g++;
			var v = this1[starting - 1 - i + 1];
			this1[ending - 1 - i + 1] = v;
		}
		count = 0;
		var _g = 0;
		var _g1 = totalLen;
		while(_g < _g1) {
			var i = _g++;
			var v = temp[count - 2];
			this1[i + 1] = v;
			++count;
		}
		temp = null;
		return true;
	}
};
cornerContour_io_Array7.swap = function(this1,id0,id1,len) {
	var start0 = id0 * 7;
	var start1 = id1 * 7;
	var totalLen = 7 * len | 0;
	if(start0 + totalLen > this1.length - 1 && start1 + totalLen > this1.length - 1) {
		var temp0;
		var temp1;
		var _g = 0;
		var _g1 = totalLen;
		while(_g < _g1) {
			var i = _g++;
			temp0 = this1[start0 + i + 1];
			temp1 = this1[start1 + i + 1];
			this1[start0 + i + 1] = temp1;
			this1[start1 + i + 1] = temp0;
		}
		return true;
	} else {
		return false;
	}
};
var cornerContour_io_Array9 = {};
cornerContour_io_Array9.readItem = function(this1,k) {
	return this1[(this1[0] | 0) * 9 + k + 1];
};
cornerContour_io_Array9.writeItem = function(this1,k,v) {
	this1[(this1[0] | 0) * 9 + k + 1] = v;
	return v;
};
cornerContour_io_Array9._new = function() {
	var this1 = [];
	this1[0] = 0.;
	var this2 = this1;
	var this1 = this2;
	return this1;
};
cornerContour_io_Array9.get_index = function(this1) {
	return this1[0] | 0;
};
cornerContour_io_Array9.set_index = function(this1,id) {
	this1[0] = id;
	return id;
};
cornerContour_io_Array9.toEnd = function(this1,id,len) {
	return cornerContour_io_ArrayFlatDepth.rangeToEnd(this1,id * 9,9 * len | 0,this1.length - 1);
};
cornerContour_io_Array9.toStart = function(this1,id,len) {
	var starting = id * 9;
	var totalLen = 9 * len | 0;
	if(starting == 0) {
		return false;
	} else {
		var ending = starting + totalLen;
		var temp = [];
		var count = 0;
		var _g = starting;
		var _g1 = ending;
		while(_g < _g1) {
			var i = _g++;
			temp[count] = this1[i + 1];
			++count;
		}
		count = totalLen;
		var _g = 0;
		var _g1 = starting;
		while(_g < _g1) {
			var i = _g++;
			var v = this1[starting - 1 - i + 1];
			this1[ending - 1 - i + 1] = v;
		}
		count = 0;
		var _g = 0;
		var _g1 = totalLen;
		while(_g < _g1) {
			var i = _g++;
			var v = temp[count - 2];
			this1[i + 1] = v;
			++count;
		}
		temp = null;
		return true;
	}
};
cornerContour_io_Array9.swap = function(this1,id0,id1,len) {
	var start0 = id0 * 9;
	var start1 = id1 * 9;
	var totalLen = 9 * len | 0;
	if(start0 + totalLen > this1.length - 1 && start1 + totalLen > this1.length - 1) {
		var temp0;
		var temp1;
		var _g = 0;
		var _g1 = totalLen;
		while(_g < _g1) {
			var i = _g++;
			temp0 = this1[start0 + i + 1];
			temp1 = this1[start1 + i + 1];
			this1[start0 + i + 1] = temp1;
			this1[start1 + i + 1] = temp0;
		}
		return true;
	} else {
		return false;
	}
};
var cornerContour_io_ArrayFlat = {};
cornerContour_io_ArrayFlat.readItem = function(this1,k) {
	return this1[k + 1];
};
cornerContour_io_ArrayFlat.writeItem = function(this1,k,v) {
	this1[k + 1] = v;
	return v;
};
cornerContour_io_ArrayFlat._new = function() {
	var this1 = [];
	this1[0] = 0.;
	return this1;
};
cornerContour_io_ArrayFlat.get_size = function(this1) {
	return this1.length - 1;
};
cornerContour_io_ArrayFlat.get_index = function(this1) {
	return this1[0] | 0;
};
cornerContour_io_ArrayFlat.set_index = function(this1,id) {
	this1[0] = id;
	return id;
};
cornerContour_io_ArrayFlat.get_pos = function(this1) {
	return this1[0];
};
cornerContour_io_ArrayFlat.set_pos = function(this1,pos_) {
	this1[0] = pos_;
	return pos_;
};
cornerContour_io_ArrayFlat.hasNext = function(this1) {
	return this1[0] < this1.length - 1;
};
cornerContour_io_ArrayFlat.next = function(this1) {
	var pos_ = this1[0] + 1.;
	this1[0] = pos_;
	return this1[0];
};
cornerContour_io_ArrayFlat.increment = function(this1) {
	var pos_ = this1[0] + 1.;
	this1[0] = pos_;
	return this1[0];
};
cornerContour_io_ArrayFlat.setArray = function(this1,arr) {
	this1 = arr;
};
cornerContour_io_ArrayFlat.clone = function(this1) {
	var this2 = [];
	this2[0] = 0.;
	var af = this2;
	af = this1.slice();
	return af;
};
var cornerContour_io_ArrayFlatDepth = {};
cornerContour_io_ArrayFlatDepth._new = function() {
	var this1 = [];
	this1[0] = 0.;
	var this2 = this1;
	return this2;
};
cornerContour_io_ArrayFlatDepth.getArray = function(this1) {
	var this2 = new Float32Array(this1.length - 1);
	var fa32 = this2;
	var _g = 0;
	var _g1 = this1.length - 1;
	while(_g < _g1) {
		var i = _g++;
		fa32[i] = this1[i + 1];
	}
	return fa32;
};
cornerContour_io_ArrayFlatDepth.rangeToEnd = function(this1,starting,totalLen,section) {
	var ending = starting + totalLen;
	var temp = [];
	var count = 0;
	var _g = starting;
	var _g1 = ending;
	while(_g < _g1) {
		var i = _g++;
		temp[count++] = this1[i + 1];
	}
	var left = section - ending;
	var _g = 0;
	var _g1 = left;
	while(_g < _g1) {
		var i = _g++;
		var v = this1[ending + i + 1];
		this1[starting + i + 1] = v;
	}
	var last = section;
	var reserveTop = last - totalLen;
	count = 0;
	var _g = reserveTop;
	var _g1 = last;
	while(_g < _g1) {
		var i = _g++;
		var v = temp[count++];
		this1[i + 1] = v;
	}
	temp = null;
	return true;
};
cornerContour_io_ArrayFlatDepth.rangeToStart = function(this1,starting,totalLen) {
	if(starting == 0) {
		return false;
	}
	var ending = starting + totalLen;
	var temp = [];
	var count = 0;
	var _g = starting;
	var _g1 = ending;
	while(_g < _g1) {
		var i = _g++;
		temp[count] = this1[i + 1];
		++count;
	}
	count = totalLen;
	var _g = 0;
	var _g1 = starting;
	while(_g < _g1) {
		var i = _g++;
		var v = this1[starting - 1 - i + 1];
		this1[ending - 1 - i + 1] = v;
	}
	count = 0;
	var _g = 0;
	var _g1 = totalLen;
	while(_g < _g1) {
		var i = _g++;
		var v = temp[count - 2];
		this1[i + 1] = v;
		++count;
	}
	temp = null;
	return true;
};
cornerContour_io_ArrayFlatDepth.rangeSwitch = function(this1,start0,start1,totalLen) {
	if(start0 + totalLen > this1.length - 1 && start1 + totalLen > this1.length - 1) {
		var temp0;
		var temp1;
		var _g = 0;
		var _g1 = totalLen;
		while(_g < _g1) {
			var i = _g++;
			temp0 = this1[start0 + i + 1];
			temp1 = this1[start1 + i + 1];
			this1[start0 + i + 1] = temp1;
			this1[start1 + i + 1] = temp0;
		}
		return true;
	} else {
		return false;
	}
};
var cornerContourClay_CCCEvents = function() {
};
cornerContourClay_CCCEvents.__name__ = true;
cornerContourClay_CCCEvents.__super__ = clay_Events;
cornerContourClay_CCCEvents.prototype = $extend(clay_Events.prototype,{
	tick: function(delta) {
		cornerContourClay_MainCCC.draw();
	}
	,ready: function() {
		cornerContourClay_MainCCC.ready();
	}
});
var cornerContourClay_MainCCC = function() { };
cornerContourClay_MainCCC.__name__ = true;
cornerContourClay_MainCCC.main = function() {
	cornerContourClay_MainCCC.divertTrace = new htmlHelper_tools_DivertTrace();
	haxe_Log.trace("cornerContour clay demo",{ fileName : "src/cornerContourClay/MainCCC.hx", lineNumber : 102, className : "cornerContourClay.MainCCC", methodName : "main"});
	cornerContourClay_MainCCC.events = new cornerContourClay_CCCEvents();
	new clay_Clay(cornerContourClay_MainCCC.configure,cornerContourClay_MainCCC.events);
};
cornerContourClay_MainCCC.configure = function(config) {
	config.window.resizable = true;
	config.render.stencil = 2;
	config.render.depth = 16;
};
cornerContourClay_MainCCC.ready = function() {
	cornerContourClay_MainCCC.width = clay_Clay.app.screenWidth;
	cornerContourClay_MainCCC.height = clay_Clay.app.screenHeight;
	cornerContourClay_MainCCC.pen2D = new cornerContour_Pen2DGrad(-16776961,-16711936,-16776961);
	cornerContourClay_MainCCC.pen2D.currentColor = -16776961;
	cornerContourClay_MainCCC.pen2D.colorB = -16711936;
	cornerContourClay_MainCCC.pen2D.colorC = -16776961;
	var styleEnd = 20;
	cornerContourClay_MainCCC.sketcher = new cornerContour_SketcherGrad(cornerContourClay_MainCCC.pen2D,4,styleEnd);
	var x0 = 0.;
	var y0 = 0.;
	var pw = 20;
	var penWidth = pw;
	cornerContourClay_MainCCC.sketcher.contour.endCapFactor = 0.6;
	var _g = 0;
	while(_g < 20) {
		var i = _g++;
		x0 = 200 + 160 * Math.sin(i * Math.PI * 2 / 20);
		y0 = 200 - 160 * Math.cos(i * Math.PI * 2 / 20);
		++penWidth;
		cornerContourClay_MainCCC.chooseColors[cornerContourClay_MainCCC.chooseI] = -16777216 + Std.random(16777215);
		cornerContourClay_MainCCC.pen2D.currentColor = cornerContourClay_MainCCC.chooseI++;
		cornerContourClay_MainCCC.chooseColors[cornerContourClay_MainCCC.chooseI] = -16777216 + Std.random(16777215);
		cornerContourClay_MainCCC.pen2D.colorB = cornerContourClay_MainCCC.chooseI++;
		var _this = cornerContourClay_MainCCC.sketcher;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("SET_POSITION");
			_this.historyParameters.push(x0);
			_this.historyParameters.push(y0);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("SET_POSITION");
			_this.turtleParameters.push(x0);
			_this.turtleParameters.push(y0);
		} else {
			var tmp;
			switch(_this.endLine) {
			case 0:case 1:case 6:case 9:case 12:case 15:case 18:
				tmp = false;
				break;
			case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
				tmp = true;
				break;
			}
			if(tmp) {
				_this.contour.end(_this.width);
			}
			_this.x = x0;
			_this.y = y0;
			var l = _this.points.length;
			_this.points[l] = [];
			_this.points[l][0] = x0;
			_this.points[l][1] = y0;
			_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
			_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
			_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = _this.dim[_this.dim.length - 1];
			if(x0 < d.minX) {
				d.minX = x0;
			}
			if(x0 > d.maxX) {
				d.maxX = x0;
			}
			if(y0 < d.minY) {
				d.minY = y0;
			}
			if(y0 > d.maxY) {
				d.maxY = y0;
			}
			_this.contour.reset();
		}
		var _this1 = _this;
		var w = penWidth / 4;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("PEN_SIZE");
			_this1.historyParameters.push(w);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("PEN_SIZE");
			_this1.turtleParameters.push(w);
		} else {
			_this1.width = w;
		}
		var _this2 = _this1;
		var degrees = i * 180 / 10 + 180;
		if(_this2.turtleHistoryOn) {
			_this2.historyAdd("SET_ANGLE");
			_this2.historyParameters.push(degrees);
		}
		if(_this2.repeatCommands) {
			_this2.turtleCommands.push("SET_ANGLE");
			_this2.turtleParameters.push(degrees);
		} else {
			_this2.rotation = -Math.PI / 2;
			_this2.rotation += degrees * Math.PI / 180;
		}
		var _this3 = _this2;
		if(_this3.turtleHistoryOn) {
			_this3.historyAdd("FORWARD");
			_this3.historyParameters.push(80);
		}
		if(_this3.repeatCommands) {
			_this3.turtleCommands.push("FORWARD");
			_this3.turtleParameters.push(80);
		} else {
			var nx = _this3.x + 80 * Math.cos(_this3.rotation);
			var ny = _this3.y + 80 * Math.sin(_this3.rotation);
			if(_this3.penIsDown) {
				_this3.lastDistance = 80;
				_this3.lineTo(nx,ny);
			} else {
				var tmp1;
				switch(_this3.endLine) {
				case 0:case 1:case 6:case 9:case 12:case 15:case 18:
					tmp1 = false;
					break;
				case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
					tmp1 = true;
					break;
				}
				if(tmp1) {
					_this3.contour.end(_this3.width);
				}
				_this3.x = nx;
				_this3.y = ny;
				var l1 = _this3.points.length;
				_this3.points[l1] = [];
				_this3.points[l1][0] = nx;
				_this3.points[l1][1] = ny;
				_this3.pointsClock[_this3.pointsClock.length] = _this3.contour.pointsClock.slice();
				_this3.pointsAnti[_this3.pointsAnti.length] = _this3.contour.pointsAnti.slice();
				_this3.dim[_this3.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d1 = _this3.dim[_this3.dim.length - 1];
				if(nx < d1.minX) {
					d1.minX = nx;
				}
				if(nx > d1.maxX) {
					d1.maxX = nx;
				}
				if(ny < d1.minY) {
					d1.minY = ny;
				}
				if(ny > d1.maxY) {
					d1.maxY = ny;
				}
				_this3.contour.reset();
			}
		}
		var _this4 = _this3;
		if(_this4.turtleHistoryOn) {
			_this4.historyAdd("FORWARD");
			_this4.historyParameters.push(10);
		}
		if(_this4.repeatCommands) {
			_this4.turtleCommands.push("FORWARD");
			_this4.turtleParameters.push(10);
		} else {
			var nx1 = _this4.x + 10 * Math.cos(_this4.rotation);
			var ny1 = _this4.y + 10 * Math.sin(_this4.rotation);
			if(_this4.penIsDown) {
				_this4.lastDistance = 10;
				_this4.lineTo(nx1,ny1);
			} else {
				var tmp2;
				switch(_this4.endLine) {
				case 0:case 1:case 6:case 9:case 12:case 15:case 18:
					tmp2 = false;
					break;
				case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
					tmp2 = true;
					break;
				}
				if(tmp2) {
					_this4.contour.end(_this4.width);
				}
				_this4.x = nx1;
				_this4.y = ny1;
				var l2 = _this4.points.length;
				_this4.points[l2] = [];
				_this4.points[l2][0] = nx1;
				_this4.points[l2][1] = ny1;
				_this4.pointsClock[_this4.pointsClock.length] = _this4.contour.pointsClock.slice();
				_this4.pointsAnti[_this4.pointsAnti.length] = _this4.contour.pointsAnti.slice();
				_this4.dim[_this4.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d2 = _this4.dim[_this4.dim.length - 1];
				if(nx1 < d2.minX) {
					d2.minX = nx1;
				}
				if(nx1 > d2.maxX) {
					d2.maxX = nx1;
				}
				if(ny1 < d2.minY) {
					d2.minY = ny1;
				}
				if(ny1 > d2.maxY) {
					d2.maxY = ny1;
				}
				_this4.contour.reset();
			}
		}
		var _this5 = _this4;
		var tmp3;
		switch(_this5.endLine) {
		case 0:case 1:case 6:case 9:case 12:case 15:case 18:
			tmp3 = false;
			break;
		case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
			tmp3 = true;
			break;
		}
		if(tmp3) {
			_this5.contour.end(_this5.width);
		}
		_this5.x = 0;
		_this5.y = 0;
		var l3 = _this5.points.length;
		_this5.points[l3] = [];
		_this5.points[l3][0] = 0;
		_this5.points[l3][1] = 0;
		_this5.pointsClock[_this5.pointsClock.length] = _this5.contour.pointsClock.slice();
		_this5.pointsAnti[_this5.pointsAnti.length] = _this5.contour.pointsAnti.slice();
		_this5.dim[_this5.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
		var d3 = _this5.dim[_this5.dim.length - 1];
		if(0 < d3.minX) {
			d3.minX = 0;
		}
		if(0 > d3.maxX) {
			d3.maxX = 0;
		}
		if(0 < d3.minY) {
			d3.minY = 0;
		}
		if(0 > d3.maxY) {
			d3.maxY = 0;
		}
		_this5.contour.reset();
	}
	penWidth = pw;
	cornerContourClay_MainCCC.sketcher.contour.endCapFactor = 0.2;
	var _g = 0;
	while(_g < 20) {
		var i = _g++;
		x0 = 420 + 160 * Math.sin(i * Math.PI * 2 / 20);
		y0 = 420 - 160 * Math.cos(i * Math.PI * 2 / 20);
		++penWidth;
		cornerContourClay_MainCCC.sketcher.contour.endCapFactor += 0.2;
		cornerContourClay_MainCCC.chooseColors[cornerContourClay_MainCCC.chooseI] = -16777216 + Std.random(16777215);
		cornerContourClay_MainCCC.pen2D.currentColor = cornerContourClay_MainCCC.chooseI++;
		cornerContourClay_MainCCC.chooseColors[cornerContourClay_MainCCC.chooseI] = -16777216 + Std.random(16777215);
		cornerContourClay_MainCCC.pen2D.colorB = cornerContourClay_MainCCC.chooseI++;
		var _this = cornerContourClay_MainCCC.sketcher;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("SET_POSITION");
			_this.historyParameters.push(x0);
			_this.historyParameters.push(y0);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("SET_POSITION");
			_this.turtleParameters.push(x0);
			_this.turtleParameters.push(y0);
		} else {
			var tmp;
			switch(_this.endLine) {
			case 0:case 1:case 6:case 9:case 12:case 15:case 18:
				tmp = false;
				break;
			case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
				tmp = true;
				break;
			}
			if(tmp) {
				_this.contour.end(_this.width);
			}
			_this.x = x0;
			_this.y = y0;
			var l = _this.points.length;
			_this.points[l] = [];
			_this.points[l][0] = x0;
			_this.points[l][1] = y0;
			_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
			_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
			_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = _this.dim[_this.dim.length - 1];
			if(x0 < d.minX) {
				d.minX = x0;
			}
			if(x0 > d.maxX) {
				d.maxX = x0;
			}
			if(y0 < d.minY) {
				d.minY = y0;
			}
			if(y0 > d.maxY) {
				d.maxY = y0;
			}
			_this.contour.reset();
		}
		var _this1 = _this;
		var w = penWidth / 4;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("PEN_SIZE");
			_this1.historyParameters.push(w);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("PEN_SIZE");
			_this1.turtleParameters.push(w);
		} else {
			_this1.width = w;
		}
		var _this2 = _this1;
		var degrees = i * 180 / 10 + 180;
		if(_this2.turtleHistoryOn) {
			_this2.historyAdd("SET_ANGLE");
			_this2.historyParameters.push(degrees);
		}
		if(_this2.repeatCommands) {
			_this2.turtleCommands.push("SET_ANGLE");
			_this2.turtleParameters.push(degrees);
		} else {
			_this2.rotation = -Math.PI / 2;
			_this2.rotation += degrees * Math.PI / 180;
		}
		var _this3 = _this2;
		if(_this3.turtleHistoryOn) {
			_this3.historyAdd("FORWARD");
			_this3.historyParameters.push(80);
		}
		if(_this3.repeatCommands) {
			_this3.turtleCommands.push("FORWARD");
			_this3.turtleParameters.push(80);
		} else {
			var nx = _this3.x + 80 * Math.cos(_this3.rotation);
			var ny = _this3.y + 80 * Math.sin(_this3.rotation);
			if(_this3.penIsDown) {
				_this3.lastDistance = 80;
				_this3.lineTo(nx,ny);
			} else {
				var tmp1;
				switch(_this3.endLine) {
				case 0:case 1:case 6:case 9:case 12:case 15:case 18:
					tmp1 = false;
					break;
				case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
					tmp1 = true;
					break;
				}
				if(tmp1) {
					_this3.contour.end(_this3.width);
				}
				_this3.x = nx;
				_this3.y = ny;
				var l1 = _this3.points.length;
				_this3.points[l1] = [];
				_this3.points[l1][0] = nx;
				_this3.points[l1][1] = ny;
				_this3.pointsClock[_this3.pointsClock.length] = _this3.contour.pointsClock.slice();
				_this3.pointsAnti[_this3.pointsAnti.length] = _this3.contour.pointsAnti.slice();
				_this3.dim[_this3.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d1 = _this3.dim[_this3.dim.length - 1];
				if(nx < d1.minX) {
					d1.minX = nx;
				}
				if(nx > d1.maxX) {
					d1.maxX = nx;
				}
				if(ny < d1.minY) {
					d1.minY = ny;
				}
				if(ny > d1.maxY) {
					d1.maxY = ny;
				}
				_this3.contour.reset();
			}
		}
		var _this4 = _this3;
		if(_this4.turtleHistoryOn) {
			_this4.historyAdd("FORWARD");
			_this4.historyParameters.push(10);
		}
		if(_this4.repeatCommands) {
			_this4.turtleCommands.push("FORWARD");
			_this4.turtleParameters.push(10);
		} else {
			var nx1 = _this4.x + 10 * Math.cos(_this4.rotation);
			var ny1 = _this4.y + 10 * Math.sin(_this4.rotation);
			if(_this4.penIsDown) {
				_this4.lastDistance = 10;
				_this4.lineTo(nx1,ny1);
			} else {
				var tmp2;
				switch(_this4.endLine) {
				case 0:case 1:case 6:case 9:case 12:case 15:case 18:
					tmp2 = false;
					break;
				case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
					tmp2 = true;
					break;
				}
				if(tmp2) {
					_this4.contour.end(_this4.width);
				}
				_this4.x = nx1;
				_this4.y = ny1;
				var l2 = _this4.points.length;
				_this4.points[l2] = [];
				_this4.points[l2][0] = nx1;
				_this4.points[l2][1] = ny1;
				_this4.pointsClock[_this4.pointsClock.length] = _this4.contour.pointsClock.slice();
				_this4.pointsAnti[_this4.pointsAnti.length] = _this4.contour.pointsAnti.slice();
				_this4.dim[_this4.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d2 = _this4.dim[_this4.dim.length - 1];
				if(nx1 < d2.minX) {
					d2.minX = nx1;
				}
				if(nx1 > d2.maxX) {
					d2.maxX = nx1;
				}
				if(ny1 < d2.minY) {
					d2.minY = ny1;
				}
				if(ny1 > d2.maxY) {
					d2.maxY = ny1;
				}
				_this4.contour.reset();
			}
		}
		var _this5 = _this4;
		var tmp3;
		switch(_this5.endLine) {
		case 0:case 1:case 6:case 9:case 12:case 15:case 18:
			tmp3 = false;
			break;
		case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
			tmp3 = true;
			break;
		}
		if(tmp3) {
			_this5.contour.end(_this5.width);
		}
		_this5.x = 0;
		_this5.y = 0;
		var l3 = _this5.points.length;
		_this5.points[l3] = [];
		_this5.points[l3][0] = 0;
		_this5.points[l3][1] = 0;
		_this5.pointsClock[_this5.pointsClock.length] = _this5.contour.pointsClock.slice();
		_this5.pointsAnti[_this5.pointsAnti.length] = _this5.contour.pointsAnti.slice();
		_this5.dim[_this5.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
		var d3 = _this5.dim[_this5.dim.length - 1];
		if(0 < d3.minX) {
			d3.minX = 0;
		}
		if(0 > d3.maxX) {
			d3.maxX = 0;
		}
		if(0 < d3.minY) {
			d3.minY = 0;
		}
		if(0 > d3.maxY) {
			d3.maxY = 0;
		}
		_this5.contour.reset();
	}
	var data = cornerContourClay_MainCCC.get_xyzw_rgba_array(cornerContourClay_MainCCC.pen2D.arr);
	cornerContourClay_MainCCC.vertices = new Float32Array(data.xyzw);
	cornerContourClay_MainCCC.colors = new Float32Array(data.rgba);
	cornerContourClay_MainCCC.totalLen = 3 * (cornerContourClay_MainCCC.pen2D.arr.length - 1);
	haxe_Log.trace("Create shader",{ fileName : "src/cornerContourClay/MainCCC.hx", lineNumber : 171, className : "cornerContourClay.MainCCC", methodName : "ready"});
	cornerContourClay_MainCCC.shader = new clay_graphics_Shader();
	cornerContourClay_MainCCC.shader.vertSource = cornerContourClay_MainCCC.vertShaderData;
	cornerContourClay_MainCCC.shader.fragSource = cornerContourClay_MainCCC.fragShaderData;
	cornerContourClay_MainCCC.shader.attributes = ["vertexPosition","vertexColor"];
	cornerContourClay_MainCCC.shader.init();
	haxe_Log.trace("Did init shader",{ fileName : "src/cornerContourClay/MainCCC.hx", lineNumber : 177, className : "cornerContourClay.MainCCC", methodName : "ready"});
	cornerContourClay_MainCCC.shader.activate();
};
cornerContourClay_MainCCC.alphaChannel = function(int) {
	return (int >> 24 & 255) / 255;
};
cornerContourClay_MainCCC.redChannel = function(int) {
	return (int >> 16 & 255) / 255;
};
cornerContourClay_MainCCC.greenChannel = function(int) {
	return (int >> 8 & 255) / 255;
};
cornerContourClay_MainCCC.blueChannel = function(int) {
	return (int & 255) / 255;
};
cornerContourClay_MainCCC.get_xyzw_rgba_array = function(data) {
	var vert = [];
	var col = [];
	var v = 0;
	var c = 0;
	var _g = 0;
	var _g1 = data.length - 1;
	while(_g < _g1) {
		var i = _g++;
		data[0] = i;
		vert[v++] = -(1 - 2 * cornerContour_io_Array2DTriGrad.get_ax(data) / cornerContourClay_MainCCC.width);
		vert[v++] = 1 - 2 * cornerContour_io_Array2DTriGrad.get_ay(data) / cornerContourClay_MainCCC.height;
		vert[v++] = 0.;
		vert[v++] = 1.;
		vert[v++] = -(1 - 2 * cornerContour_io_Array2DTriGrad.get_bx(data) / cornerContourClay_MainCCC.width);
		vert[v++] = 1 - 2 * cornerContour_io_Array2DTriGrad.get_by(data) / cornerContourClay_MainCCC.height;
		vert[v++] = 0.;
		vert[v++] = 1.;
		vert[v++] = -(1 - 2 * cornerContour_io_Array2DTriGrad.get_cx(data) / cornerContourClay_MainCCC.width);
		vert[v++] = 1 - 2 * cornerContour_io_Array2DTriGrad.get_cy(data) / cornerContourClay_MainCCC.height;
		vert[v++] = 0.;
		vert[v++] = 1.;
		var colInt = cornerContour_io_Array2DTriGrad.get_colorIntA(data);
		col[c++] = (colInt >> 16 & 255) / 255;
		col[c++] = (colInt >> 8 & 255) / 255;
		col[c++] = (colInt & 255) / 255;
		col[c++] = (colInt >> 24 & 255) / 255;
		colInt = cornerContour_io_Array2DTriGrad.get_colorIntB(data);
		col[c++] = (colInt >> 16 & 255) / 255;
		col[c++] = (colInt >> 8 & 255) / 255;
		col[c++] = (colInt & 255) / 255;
		col[c++] = (colInt >> 24 & 255) / 255;
		colInt = cornerContour_io_Array2DTriGrad.get_colorIntC(data);
		col[c++] = (colInt >> 16 & 255) / 255;
		col[c++] = (colInt >> 8 & 255) / 255;
		col[c++] = (colInt & 255) / 255;
		col[c++] = (colInt >> 24 & 255) / 255;
	}
	return { xyzw : vert, rgba : col};
};
cornerContourClay_MainCCC.gx = function(v) {
	return -(1 - 2 * v / cornerContourClay_MainCCC.width);
};
cornerContourClay_MainCCC.gy = function(v) {
	return 1 - 2 * v / cornerContourClay_MainCCC.height;
};
cornerContourClay_MainCCC.draw = function() {
	cornerContourClay_MainCCC.width = clay_Clay.app.screenWidth;
	cornerContourClay_MainCCC.height = clay_Clay.app.screenHeight;
	cornerContourClay_MainCCC.pen2D = new cornerContour_Pen2DGrad(-16776961,-16711936,-16776961);
	cornerContourClay_MainCCC.pen2D.currentColor = -16776961;
	cornerContourClay_MainCCC.pen2D.colorB = -16711936;
	cornerContourClay_MainCCC.pen2D.colorC = -16776961;
	var styleEnd = 20;
	cornerContourClay_MainCCC.sketcher = new cornerContour_SketcherGrad(cornerContourClay_MainCCC.pen2D,4,styleEnd);
	var x0 = 0.;
	var y0 = 0.;
	var pw = 25;
	var penWidth = pw;
	cornerContourClay_MainCCC.chooseI = 0;
	cornerContourClay_MainCCC.sketcher.contour.endCapFactor = 0.6;
	var _g = 0;
	while(_g < 20) {
		var i = _g++;
		x0 = 200 + 160 * Math.sin(i * Math.PI * 2 / 20 + cornerContourClay_MainCCC.theta);
		y0 = 200 - 160 * Math.cos(i * Math.PI * 2 / 20 + cornerContourClay_MainCCC.theta);
		++penWidth;
		cornerContourClay_MainCCC.pen2D.currentColor = cornerContourClay_MainCCC.chooseColors[cornerContourClay_MainCCC.chooseI++];
		cornerContourClay_MainCCC.pen2D.colorB = cornerContourClay_MainCCC.chooseColors[cornerContourClay_MainCCC.chooseI++];
		var _this = cornerContourClay_MainCCC.sketcher;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("SET_POSITION");
			_this.historyParameters.push(x0);
			_this.historyParameters.push(y0);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("SET_POSITION");
			_this.turtleParameters.push(x0);
			_this.turtleParameters.push(y0);
		} else {
			var tmp;
			switch(_this.endLine) {
			case 0:case 1:case 6:case 9:case 12:case 15:case 18:
				tmp = false;
				break;
			case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
				tmp = true;
				break;
			}
			if(tmp) {
				_this.contour.end(_this.width);
			}
			_this.x = x0;
			_this.y = y0;
			var l = _this.points.length;
			_this.points[l] = [];
			_this.points[l][0] = x0;
			_this.points[l][1] = y0;
			_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
			_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
			_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = _this.dim[_this.dim.length - 1];
			if(x0 < d.minX) {
				d.minX = x0;
			}
			if(x0 > d.maxX) {
				d.maxX = x0;
			}
			if(y0 < d.minY) {
				d.minY = y0;
			}
			if(y0 > d.maxY) {
				d.maxY = y0;
			}
			_this.contour.reset();
		}
		var _this1 = _this;
		var w = penWidth / 4;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("PEN_SIZE");
			_this1.historyParameters.push(w);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("PEN_SIZE");
			_this1.turtleParameters.push(w);
		} else {
			_this1.width = w;
		}
		var _this2 = _this1;
		var degrees = i * 180 / 10 + 180;
		if(_this2.turtleHistoryOn) {
			_this2.historyAdd("SET_ANGLE");
			_this2.historyParameters.push(degrees);
		}
		if(_this2.repeatCommands) {
			_this2.turtleCommands.push("SET_ANGLE");
			_this2.turtleParameters.push(degrees);
		} else {
			_this2.rotation = -Math.PI / 2;
			_this2.rotation += degrees * Math.PI / 180;
		}
		var _this3 = _this2;
		if(_this3.turtleHistoryOn) {
			_this3.historyAdd("FORWARD");
			_this3.historyParameters.push(50);
		}
		if(_this3.repeatCommands) {
			_this3.turtleCommands.push("FORWARD");
			_this3.turtleParameters.push(50);
		} else {
			var nx = _this3.x + 50 * Math.cos(_this3.rotation);
			var ny = _this3.y + 50 * Math.sin(_this3.rotation);
			if(_this3.penIsDown) {
				_this3.lastDistance = 50;
				_this3.lineTo(nx,ny);
			} else {
				var tmp1;
				switch(_this3.endLine) {
				case 0:case 1:case 6:case 9:case 12:case 15:case 18:
					tmp1 = false;
					break;
				case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
					tmp1 = true;
					break;
				}
				if(tmp1) {
					_this3.contour.end(_this3.width);
				}
				_this3.x = nx;
				_this3.y = ny;
				var l1 = _this3.points.length;
				_this3.points[l1] = [];
				_this3.points[l1][0] = nx;
				_this3.points[l1][1] = ny;
				_this3.pointsClock[_this3.pointsClock.length] = _this3.contour.pointsClock.slice();
				_this3.pointsAnti[_this3.pointsAnti.length] = _this3.contour.pointsAnti.slice();
				_this3.dim[_this3.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d1 = _this3.dim[_this3.dim.length - 1];
				if(nx < d1.minX) {
					d1.minX = nx;
				}
				if(nx > d1.maxX) {
					d1.maxX = nx;
				}
				if(ny < d1.minY) {
					d1.minY = ny;
				}
				if(ny > d1.maxY) {
					d1.maxY = ny;
				}
				_this3.contour.reset();
			}
		}
		var _this4 = _this3;
		if(_this4.turtleHistoryOn) {
			_this4.historyAdd("ARC");
			_this4.historyParameters.push(50);
			_this4.historyParameters.push(120);
		}
		if(_this4.repeatCommands) {
			_this4.turtleCommands.push("ARC");
			_this4.turtleParameters.push(50);
			_this4.turtleParameters.push(120);
		} else {
			var beta = 120 * Math.PI / 180 / 24;
			var alpha = (Math.PI - beta) / 2;
			var rotate = -(Math.PI / 2 - alpha);
			var baseLength = 25. * Math.sin(beta / 2);
			var ox = _this4.x;
			var oy = _this4.y;
			var arr = [];
			arr.push(_this4.x);
			arr.push(_this4.y);
			var _g1 = 0;
			while(_g1 < 48) {
				var i1 = _g1++;
				_this4.rotation += rotate;
				var wasHistoryOn = _this4.turtleHistoryOn;
				_this4.turtleHistoryOn = false;
				if(_this4.turtleHistoryOn) {
					_this4.historyAdd("FORWARD");
					_this4.historyParameters.push(baseLength);
				}
				if(_this4.repeatCommands) {
					_this4.turtleCommands.push("FORWARD");
					_this4.turtleParameters.push(baseLength);
				} else {
					var nx1 = _this4.x + baseLength * Math.cos(_this4.rotation);
					var ny1 = _this4.y + baseLength * Math.sin(_this4.rotation);
					if(_this4.penIsDown) {
						_this4.lastDistance = baseLength;
						_this4.lineTo(nx1,ny1);
					} else {
						var tmp2;
						switch(_this4.endLine) {
						case 0:case 1:case 6:case 9:case 12:case 15:case 18:
							tmp2 = false;
							break;
						case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
							tmp2 = true;
							break;
						}
						if(tmp2) {
							_this4.contour.end(_this4.width);
						}
						_this4.x = nx1;
						_this4.y = ny1;
						var l2 = _this4.points.length;
						_this4.points[l2] = [];
						_this4.points[l2][0] = nx1;
						_this4.points[l2][1] = ny1;
						_this4.pointsClock[_this4.pointsClock.length] = _this4.contour.pointsClock.slice();
						_this4.pointsAnti[_this4.pointsAnti.length] = _this4.contour.pointsAnti.slice();
						_this4.dim[_this4.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d2 = _this4.dim[_this4.dim.length - 1];
						if(nx1 < d2.minX) {
							d2.minX = nx1;
						}
						if(nx1 > d2.maxX) {
							d2.maxX = nx1;
						}
						if(ny1 < d2.minY) {
							d2.minY = ny1;
						}
						if(ny1 > d2.maxY) {
							d2.maxY = ny1;
						}
						_this4.contour.reset();
					}
				}
				_this4.turtleHistoryOn = wasHistoryOn;
				if(_this4.fill) {
					arr.push(_this4.x);
					arr.push(_this4.y);
				}
			}
			if(_this4.fill) {
				var cx = (ox + arr[arr.length - 2]) / 2;
				var cy = (oy + arr[arr.length - 1]) / 2;
				var l3 = arr.length;
				var i2 = 2;
				var lx = 0.;
				var ly = 0.;
				_this4.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
				while(i2 < l3) {
					if(i2 > 2) {
						_this4.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
					}
					lx = arr[i2];
					ly = arr[i2 + 1];
					i2 += 2;
				}
			}
			arr.length = 0;
		}
		var _this5 = _this4;
		if(_this5.turtleHistoryOn) {
			_this5.historyAdd("FORWARD");
			_this5.historyParameters.push(10);
		}
		if(_this5.repeatCommands) {
			_this5.turtleCommands.push("FORWARD");
			_this5.turtleParameters.push(10);
		} else {
			var nx2 = _this5.x + 10 * Math.cos(_this5.rotation);
			var ny2 = _this5.y + 10 * Math.sin(_this5.rotation);
			if(_this5.penIsDown) {
				_this5.lastDistance = 10;
				_this5.lineTo(nx2,ny2);
			} else {
				var tmp3;
				switch(_this5.endLine) {
				case 0:case 1:case 6:case 9:case 12:case 15:case 18:
					tmp3 = false;
					break;
				case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
					tmp3 = true;
					break;
				}
				if(tmp3) {
					_this5.contour.end(_this5.width);
				}
				_this5.x = nx2;
				_this5.y = ny2;
				var l4 = _this5.points.length;
				_this5.points[l4] = [];
				_this5.points[l4][0] = nx2;
				_this5.points[l4][1] = ny2;
				_this5.pointsClock[_this5.pointsClock.length] = _this5.contour.pointsClock.slice();
				_this5.pointsAnti[_this5.pointsAnti.length] = _this5.contour.pointsAnti.slice();
				_this5.dim[_this5.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d3 = _this5.dim[_this5.dim.length - 1];
				if(nx2 < d3.minX) {
					d3.minX = nx2;
				}
				if(nx2 > d3.maxX) {
					d3.maxX = nx2;
				}
				if(ny2 < d3.minY) {
					d3.minY = ny2;
				}
				if(ny2 > d3.maxY) {
					d3.maxY = ny2;
				}
				_this5.contour.reset();
			}
		}
		var _this6 = _this5;
		var tmp4;
		switch(_this6.endLine) {
		case 0:case 1:case 6:case 9:case 12:case 15:case 18:
			tmp4 = false;
			break;
		case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
			tmp4 = true;
			break;
		}
		if(tmp4) {
			_this6.contour.end(_this6.width);
		}
		_this6.x = 0;
		_this6.y = 0;
		var l5 = _this6.points.length;
		_this6.points[l5] = [];
		_this6.points[l5][0] = 0;
		_this6.points[l5][1] = 0;
		_this6.pointsClock[_this6.pointsClock.length] = _this6.contour.pointsClock.slice();
		_this6.pointsAnti[_this6.pointsAnti.length] = _this6.contour.pointsAnti.slice();
		_this6.dim[_this6.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
		var d4 = _this6.dim[_this6.dim.length - 1];
		if(0 < d4.minX) {
			d4.minX = 0;
		}
		if(0 > d4.maxX) {
			d4.maxX = 0;
		}
		if(0 < d4.minY) {
			d4.minY = 0;
		}
		if(0 > d4.maxY) {
			d4.maxY = 0;
		}
		_this6.contour.reset();
	}
	penWidth = pw;
	cornerContourClay_MainCCC.sketcher.contour.endCapFactor = 0.2;
	var _g = 0;
	while(_g < 20) {
		var i = _g++;
		x0 = 420 + 160 * Math.sin(i * Math.PI * 2 / 20 + cornerContourClay_MainCCC.theta);
		y0 = 420 - 160 * Math.cos(i * Math.PI * 2 / 20 + cornerContourClay_MainCCC.theta);
		++penWidth;
		cornerContourClay_MainCCC.sketcher.contour.endCapFactor += 0.2;
		cornerContourClay_MainCCC.chooseColors[cornerContourClay_MainCCC.chooseI] += 196608;
		cornerContourClay_MainCCC.pen2D.currentColor = cornerContourClay_MainCCC.chooseColors[cornerContourClay_MainCCC.chooseI++];
		cornerContourClay_MainCCC.chooseColors[cornerContourClay_MainCCC.chooseI] -= 65539;
		cornerContourClay_MainCCC.pen2D.colorB = cornerContourClay_MainCCC.chooseColors[cornerContourClay_MainCCC.chooseI++];
		var _this = cornerContourClay_MainCCC.sketcher;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("SET_POSITION");
			_this.historyParameters.push(x0);
			_this.historyParameters.push(y0);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("SET_POSITION");
			_this.turtleParameters.push(x0);
			_this.turtleParameters.push(y0);
		} else {
			var tmp;
			switch(_this.endLine) {
			case 0:case 1:case 6:case 9:case 12:case 15:case 18:
				tmp = false;
				break;
			case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
				tmp = true;
				break;
			}
			if(tmp) {
				_this.contour.end(_this.width);
			}
			_this.x = x0;
			_this.y = y0;
			var l = _this.points.length;
			_this.points[l] = [];
			_this.points[l][0] = x0;
			_this.points[l][1] = y0;
			_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
			_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
			_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = _this.dim[_this.dim.length - 1];
			if(x0 < d.minX) {
				d.minX = x0;
			}
			if(x0 > d.maxX) {
				d.maxX = x0;
			}
			if(y0 < d.minY) {
				d.minY = y0;
			}
			if(y0 > d.maxY) {
				d.maxY = y0;
			}
			_this.contour.reset();
		}
		var _this1 = _this;
		var w = penWidth / 4;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("PEN_SIZE");
			_this1.historyParameters.push(w);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("PEN_SIZE");
			_this1.turtleParameters.push(w);
		} else {
			_this1.width = w;
		}
		var _this2 = _this1;
		var degrees = i * 180 / 10 + 180;
		if(_this2.turtleHistoryOn) {
			_this2.historyAdd("SET_ANGLE");
			_this2.historyParameters.push(degrees);
		}
		if(_this2.repeatCommands) {
			_this2.turtleCommands.push("SET_ANGLE");
			_this2.turtleParameters.push(degrees);
		} else {
			_this2.rotation = -Math.PI / 2;
			_this2.rotation += degrees * Math.PI / 180;
		}
		var _this3 = _this2;
		if(_this3.turtleHistoryOn) {
			_this3.historyAdd("FORWARD");
			_this3.historyParameters.push(80);
		}
		if(_this3.repeatCommands) {
			_this3.turtleCommands.push("FORWARD");
			_this3.turtleParameters.push(80);
		} else {
			var nx = _this3.x + 80 * Math.cos(_this3.rotation);
			var ny = _this3.y + 80 * Math.sin(_this3.rotation);
			if(_this3.penIsDown) {
				_this3.lastDistance = 80;
				_this3.lineTo(nx,ny);
			} else {
				var tmp1;
				switch(_this3.endLine) {
				case 0:case 1:case 6:case 9:case 12:case 15:case 18:
					tmp1 = false;
					break;
				case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
					tmp1 = true;
					break;
				}
				if(tmp1) {
					_this3.contour.end(_this3.width);
				}
				_this3.x = nx;
				_this3.y = ny;
				var l1 = _this3.points.length;
				_this3.points[l1] = [];
				_this3.points[l1][0] = nx;
				_this3.points[l1][1] = ny;
				_this3.pointsClock[_this3.pointsClock.length] = _this3.contour.pointsClock.slice();
				_this3.pointsAnti[_this3.pointsAnti.length] = _this3.contour.pointsAnti.slice();
				_this3.dim[_this3.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d1 = _this3.dim[_this3.dim.length - 1];
				if(nx < d1.minX) {
					d1.minX = nx;
				}
				if(nx > d1.maxX) {
					d1.maxX = nx;
				}
				if(ny < d1.minY) {
					d1.minY = ny;
				}
				if(ny > d1.maxY) {
					d1.maxY = ny;
				}
				_this3.contour.reset();
			}
		}
		var _this4 = _this3;
		if(_this4.turtleHistoryOn) {
			_this4.historyAdd("FORWARD");
			_this4.historyParameters.push(10);
		}
		if(_this4.repeatCommands) {
			_this4.turtleCommands.push("FORWARD");
			_this4.turtleParameters.push(10);
		} else {
			var nx1 = _this4.x + 10 * Math.cos(_this4.rotation);
			var ny1 = _this4.y + 10 * Math.sin(_this4.rotation);
			if(_this4.penIsDown) {
				_this4.lastDistance = 10;
				_this4.lineTo(nx1,ny1);
			} else {
				var tmp2;
				switch(_this4.endLine) {
				case 0:case 1:case 6:case 9:case 12:case 15:case 18:
					tmp2 = false;
					break;
				case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
					tmp2 = true;
					break;
				}
				if(tmp2) {
					_this4.contour.end(_this4.width);
				}
				_this4.x = nx1;
				_this4.y = ny1;
				var l2 = _this4.points.length;
				_this4.points[l2] = [];
				_this4.points[l2][0] = nx1;
				_this4.points[l2][1] = ny1;
				_this4.pointsClock[_this4.pointsClock.length] = _this4.contour.pointsClock.slice();
				_this4.pointsAnti[_this4.pointsAnti.length] = _this4.contour.pointsAnti.slice();
				_this4.dim[_this4.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d2 = _this4.dim[_this4.dim.length - 1];
				if(nx1 < d2.minX) {
					d2.minX = nx1;
				}
				if(nx1 > d2.maxX) {
					d2.maxX = nx1;
				}
				if(ny1 < d2.minY) {
					d2.minY = ny1;
				}
				if(ny1 > d2.maxY) {
					d2.maxY = ny1;
				}
				_this4.contour.reset();
			}
		}
		var _this5 = _this4;
		var tmp3;
		switch(_this5.endLine) {
		case 0:case 1:case 6:case 9:case 12:case 15:case 18:
			tmp3 = false;
			break;
		case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
			tmp3 = true;
			break;
		}
		if(tmp3) {
			_this5.contour.end(_this5.width);
		}
		_this5.x = 0;
		_this5.y = 0;
		var l3 = _this5.points.length;
		_this5.points[l3] = [];
		_this5.points[l3][0] = 0;
		_this5.points[l3][1] = 0;
		_this5.pointsClock[_this5.pointsClock.length] = _this5.contour.pointsClock.slice();
		_this5.pointsAnti[_this5.pointsAnti.length] = _this5.contour.pointsAnti.slice();
		_this5.dim[_this5.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
		var d3 = _this5.dim[_this5.dim.length - 1];
		if(0 < d3.minX) {
			d3.minX = 0;
		}
		if(0 > d3.maxX) {
			d3.maxX = 0;
		}
		if(0 < d3.minY) {
			d3.minY = 0;
		}
		if(0 > d3.maxY) {
			d3.maxY = 0;
		}
		_this5.contour.reset();
	}
	cornerContourClay_MainCCC.theta += 0.03;
	var data = cornerContourClay_MainCCC.get_xyzw_rgba_array(cornerContourClay_MainCCC.pen2D.arr);
	cornerContourClay_MainCCC.vertices = new Float32Array(data.xyzw);
	cornerContourClay_MainCCC.colors = new Float32Array(data.rgba);
	cornerContourClay_MainCCC.totalLen = 3 * (cornerContourClay_MainCCC.pen2D.arr.length - 1);
	clay_opengl_GLGraphics.clear(0.25,0.25,0.25,1);
	clay_opengl_web_GL.gl.viewport(0,0,clay_Clay.app.screenWidth * clay_Clay.app.screenDensity | 0,clay_Clay.app.screenHeight * clay_Clay.app.screenDensity | 0);
	clay_opengl_web_GL.gl.enableVertexAttribArray(0);
	clay_opengl_web_GL.gl.enableVertexAttribArray(1);
	var verticesBuffer = clay_opengl_web_GL.gl.createBuffer();
	clay_opengl_web_GL.gl.bindBuffer(34962,verticesBuffer);
	clay_opengl_web_GL.gl.bufferData(34962,cornerContourClay_MainCCC.vertices,35040);
	clay_opengl_web_GL.gl.vertexAttribPointer(0,4,5126,false,0,0);
	var colorsBuffer = clay_opengl_web_GL.gl.createBuffer();
	clay_opengl_web_GL.gl.bindBuffer(34962,colorsBuffer);
	clay_opengl_web_GL.gl.bufferData(34962,cornerContourClay_MainCCC.colors,35040);
	clay_opengl_web_GL.gl.vertexAttribPointer(1,4,5126,false,0,0);
	clay_opengl_web_GL.gl.drawArrays(4,0,cornerContourClay_MainCCC.totalLen);
	clay_opengl_web_GL.gl.deleteBuffer(verticesBuffer);
	clay_opengl_web_GL.gl.deleteBuffer(colorsBuffer);
	clay_opengl_web_GL.gl.disableVertexAttribArray(0);
	clay_opengl_web_GL.gl.disableVertexAttribArray(1);
	var error = clay_opengl_web_GL.gl.getError();
	if(error != 0) {
		throw haxe_Exception.thrown("Failed with GL error: " + error);
	}
};
var fracs_DifferencePreference = $hxEnums["fracs.DifferencePreference"] = { __ename__:true,__constructs__:null
	,CLOCKWISE: {_hx_name:"CLOCKWISE",_hx_index:0,__enum__:"fracs.DifferencePreference",toString:$estr}
	,ANTICLOCKWISE: {_hx_name:"ANTICLOCKWISE",_hx_index:1,__enum__:"fracs.DifferencePreference",toString:$estr}
	,SMALL: {_hx_name:"SMALL",_hx_index:2,__enum__:"fracs.DifferencePreference",toString:$estr}
	,LARGE: {_hx_name:"LARGE",_hx_index:3,__enum__:"fracs.DifferencePreference",toString:$estr}
	,SMALL_OLD: {_hx_name:"SMALL_OLD",_hx_index:4,__enum__:"fracs.DifferencePreference",toString:$estr}
};
fracs_DifferencePreference.__constructs__ = [fracs_DifferencePreference.CLOCKWISE,fracs_DifferencePreference.ANTICLOCKWISE,fracs_DifferencePreference.SMALL,fracs_DifferencePreference.LARGE,fracs_DifferencePreference.SMALL_OLD];
var fracs_Angles = function() { };
fracs_Angles.__name__ = true;
fracs_Angles.pi2pi = function(angle) {
	if(angle <= Math.PI && angle > -Math.PI) {
		return angle;
	} else {
		var a = (angle + Math.PI) % (2 * Math.PI);
		if(a >= 0) {
			return a - Math.PI;
		} else {
			return a + Math.PI;
		}
	}
};
fracs_Angles.zeroto2pi = function(angle) {
	if(angle >= 0 && angle > Math.PI) {
		return angle;
	} else {
		var a = angle % (2 * Math.PI);
		if(a >= 0) {
			return a;
		} else {
			return a + 2 * Math.PI;
		}
	}
};
fracs_Angles.zerotoMinus2pi = function(angle) {
	if(angle <= 0 && angle > -Math.PI) {
		return angle;
	} else {
		var a = angle % (2 * Math.PI);
		var a1 = a >= 0 ? a : a + 2 * Math.PI;
		return -(Math.PI * 2 - a1);
	}
};
fracs_Angles.differencePrefer = function(a,b,prefer) {
	switch(prefer._hx_index) {
	case 0:
		var f;
		if(a >= 0 && a > Math.PI) {
			f = a;
		} else {
			var a1 = a % (2 * Math.PI);
			f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this1 = f;
		var za = this1;
		var f;
		if(b >= 0 && b > Math.PI) {
			f = b;
		} else {
			var a1 = b % (2 * Math.PI);
			f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this1 = f;
		var zb = this1;
		var fa = za;
		var fb = zb;
		var theta = Math.abs(fa - fb);
		var clockwise = fa < fb;
		var dif = clockwise ? theta : -theta;
		if(dif > 0) {
			return dif;
		} else {
			return 2 * Math.PI + dif;
		}
		break;
	case 1:
		var f;
		if(a >= 0 && a > Math.PI) {
			f = a;
		} else {
			var a1 = a % (2 * Math.PI);
			f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this1 = f;
		var za = this1;
		var f;
		if(b >= 0 && b > Math.PI) {
			f = b;
		} else {
			var a1 = b % (2 * Math.PI);
			f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this1 = f;
		var zb = this1;
		var fa = za;
		var fb = zb;
		var theta = Math.abs(fa - fb);
		var clockwise = fa < fb;
		var dif = clockwise ? theta : -theta;
		if(dif < 0) {
			return dif;
		} else {
			return -2 * Math.PI + dif;
		}
		break;
	case 2:
		var f;
		if(a >= 0 && a > Math.PI) {
			f = a;
		} else {
			var a1 = a % (2 * Math.PI);
			f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this1 = f;
		var za = this1;
		var f;
		if(b >= 0 && b > Math.PI) {
			f = b;
		} else {
			var a1 = b % (2 * Math.PI);
			f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this1 = f;
		var zb = this1;
		var fa = za;
		var fb = zb;
		var theta = Math.abs(fa - fb);
		var smallest = theta <= Math.PI;
		var clockwise = fa < fb;
		var dif = clockwise ? theta : -theta;
		if(smallest) {
			return dif;
		} else if(clockwise) {
			return -(2 * Math.PI - theta);
		} else {
			return 2 * Math.PI - theta;
		}
		break;
	case 3:
		var f;
		if(a >= 0 && a > Math.PI) {
			f = a;
		} else {
			var a1 = a % (2 * Math.PI);
			f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this1 = f;
		var za = this1;
		var f;
		if(b >= 0 && b > Math.PI) {
			f = b;
		} else {
			var a1 = b % (2 * Math.PI);
			f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this1 = f;
		var zb = this1;
		var fa = za;
		var fb = zb;
		var theta = Math.abs(fa - fb);
		var largest = theta > Math.PI;
		var clockwise = fa < fb;
		var dif = clockwise ? theta : -theta;
		if(largest) {
			return dif;
		} else if(clockwise) {
			return -(2 * Math.PI - theta);
		} else {
			return 2 * Math.PI - theta;
		}
		break;
	case 4:
		var f;
		if(a >= 0 && a > Math.PI) {
			f = a;
		} else {
			var a1 = a % (2 * Math.PI);
			f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this1 = f;
		var za = this1;
		var f;
		if(b >= 0 && b > Math.PI) {
			f = b;
		} else {
			var a1 = b % (2 * Math.PI);
			f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this1 = f;
		var zb = this1;
		var fa = a;
		var fb = b;
		var theta = Math.abs(a - b);
		var smallest = theta <= Math.PI;
		var clockwise = a < b;
		var dif = clockwise ? theta : -theta;
		if(smallest) {
			return dif;
		} else if(clockwise) {
			return -(2 * Math.PI - theta);
		} else {
			return 2 * Math.PI - theta;
		}
		break;
	}
};
fracs_Angles.difference = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var za = this1;
	var f;
	if(b >= 0 && b > Math.PI) {
		f = b;
	} else {
		var a = b % (2 * Math.PI);
		f = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f;
	var zb = this1;
	var fa = za;
	var fb = zb;
	var theta = Math.abs(fa - fb);
	var clockwise = fa < fb;
	if(clockwise) {
		return theta;
	} else {
		return -theta;
	}
};
fracs_Angles.differenceClockWise = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var za = this1;
	var f;
	if(b >= 0 && b > Math.PI) {
		f = b;
	} else {
		var a = b % (2 * Math.PI);
		f = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f;
	var zb = this1;
	var fa = za;
	var fb = zb;
	var theta = Math.abs(fa - fb);
	var clockwise = fa < fb;
	var dif = clockwise ? theta : -theta;
	if(dif > 0) {
		return dif;
	} else {
		return 2 * Math.PI + dif;
	}
};
fracs_Angles.differenceAntiClockwise = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var za = this1;
	var f;
	if(b >= 0 && b > Math.PI) {
		f = b;
	} else {
		var a = b % (2 * Math.PI);
		f = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f;
	var zb = this1;
	var fa = za;
	var fb = zb;
	var theta = Math.abs(fa - fb);
	var clockwise = fa < fb;
	var dif = clockwise ? theta : -theta;
	if(dif < 0) {
		return dif;
	} else {
		return -2 * Math.PI + dif;
	}
};
fracs_Angles.differenceSmall = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var za = this1;
	var f;
	if(b >= 0 && b > Math.PI) {
		f = b;
	} else {
		var a = b % (2 * Math.PI);
		f = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f;
	var zb = this1;
	var fa = za;
	var fb = zb;
	var theta = Math.abs(fa - fb);
	var smallest = theta <= Math.PI;
	var clockwise = fa < fb;
	var dif = clockwise ? theta : -theta;
	if(smallest) {
		return dif;
	} else if(clockwise) {
		return -(2 * Math.PI - theta);
	} else {
		return 2 * Math.PI - theta;
	}
};
fracs_Angles.differenceSmall_old = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var za = this1;
	var f;
	if(b >= 0 && b > Math.PI) {
		f = b;
	} else {
		var a1 = b % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var zb = this1;
	var fa = a;
	var fb = b;
	var theta = Math.abs(a - b);
	var smallest = theta <= Math.PI;
	var clockwise = a < b;
	var dif = clockwise ? theta : -theta;
	if(smallest) {
		return dif;
	} else if(clockwise) {
		return -(2 * Math.PI - theta);
	} else {
		return 2 * Math.PI - theta;
	}
};
fracs_Angles.differenceLarge = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var za = this1;
	var f;
	if(b >= 0 && b > Math.PI) {
		f = b;
	} else {
		var a = b % (2 * Math.PI);
		f = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f;
	var zb = this1;
	var fa = za;
	var fb = zb;
	var theta = Math.abs(fa - fb);
	var largest = theta > Math.PI;
	var clockwise = fa < fb;
	var dif = clockwise ? theta : -theta;
	if(largest) {
		return dif;
	} else if(clockwise) {
		return -(2 * Math.PI - theta);
	} else {
		return 2 * Math.PI - theta;
	}
};
fracs_Angles.differenceSmallLarge = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var za = this1;
	var f;
	if(b >= 0 && b > Math.PI) {
		f = b;
	} else {
		var a = b % (2 * Math.PI);
		f = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f;
	var zb = this1;
	var fa = za;
	var fb = zb;
	var theta = Math.abs(fa - fb);
	var smallest = theta <= Math.PI;
	var clockwise = fa < fb;
	var dif = clockwise ? theta : -theta;
	var other = clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
	if(smallest) {
		return { small : dif, large : other};
	} else {
		return { small : other, large : dif};
	}
};
var fracs_FractionArray = {};
fracs_FractionArray._new = function(val) {
	var this1 = val == null ? [] : val;
	return this1;
};
fracs_FractionArray.add = function(this1,val) {
	this1[this1.length] = val;
};
fracs_FractionArray.toString = function(this1) {
	var l = this1.length;
	var str = "";
	var _g = 0;
	var _g1 = l;
	while(_g < _g1) {
		var i = _g++;
		var tmp = this1[i];
		var str1;
		if(tmp == null) {
			str1 = "null";
		} else {
			var n = tmp.numerator;
			var d = tmp.denominator;
			var out = n == 0 ? "0" : n == d ? "1" : d == 1 ? tmp.positive ? "" + n : "-" + n : tmp.positive ? "" + n + "/" + d : "-" + n + "/" + d;
			str1 = out;
		}
		str = str + "\n" + str1;
	}
	return str;
};
var fracs_Fraction = {};
fracs_Fraction._new = function(numerator,denominator,positive,value) {
	if(positive == null) {
		positive = true;
	}
	var numNeg = numerator < 0;
	var denoNeg = denominator < 0;
	if(value == null) {
		value = positive ? numerator / denominator : -numerator / denominator;
	}
	if(numNeg || denoNeg) {
		if(!(numNeg && denoNeg)) {
			positive = !positive;
		}
		if(numNeg) {
			numerator = -numerator;
		}
		if(denoNeg) {
			denominator = -denominator;
		}
	}
	var this1 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
	return this1;
};
fracs_Fraction.optimize = function(this1) {
	var f = this1.value;
	var arr = fracs_Fracs.approximateFractions(f);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac;
	var fracStore = arr[0];
	var _g = 0;
	var _g1 = l;
	while(_g < _g1) {
		var i = _g++;
		var frac = arr[i];
		fracFloat = frac.positive ? frac.numerator / frac.denominator : -frac.numerator / frac.denominator;
		dif = Math.abs(fracFloat - f);
		if(dif < dist) {
			dist = dif;
			fracStore = frac;
		}
	}
	return fracStore;
};
fracs_Fraction.optimizeFraction = function(this1) {
	var f = this1.positive ? this1.numerator / this1.denominator : -this1.numerator / this1.denominator;
	var arr = fracs_Fracs.approximateFractions(f);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac;
	var fracStore = arr[0];
	var _g = 0;
	var _g1 = l;
	while(_g < _g1) {
		var i = _g++;
		var frac = arr[i];
		fracFloat = frac.positive ? frac.numerator / frac.denominator : -frac.numerator / frac.denominator;
		dif = Math.abs(fracFloat - f);
		if(dif < dist) {
			dist = dif;
			fracStore = frac;
		}
	}
	return fracStore;
};
fracs_Fraction.toFloat = function(this1) {
	if(this1.positive) {
		return this1.numerator / this1.denominator;
	} else {
		return -this1.numerator / this1.denominator;
	}
};
fracs_Fraction.float = function(this1) {
	return this1.value;
};
fracs_Fraction.verbose = function(this1) {
	return "{ numerator:" + this1.numerator + ", denominator: " + this1.denominator + ", positive: " + (this1.positive == null ? "null" : "" + this1.positive) + ", value: " + this1.value + " }";
};
fracs_Fraction.fromString = function(val) {
	var i = val.indexOf("/");
	var frac;
	if(i != -1) {
		var numerator = Std.parseInt(HxOverrides.substr(val,0,i));
		var denominator = Std.parseInt(HxOverrides.substr(val,i + 1,val.length));
		var positive = true;
		var value = null;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			value = positive ? numerator / denominator : -numerator / denominator;
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive = !positive;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		var this1 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
		frac = this1;
	} else {
		var f = parseFloat(val);
		var arr = fracs_Fracs.approximateFractions(f);
		var dist = Infinity;
		var dif;
		var l = arr.length;
		var fracFloat;
		var frac1;
		var fracStore = arr[0];
		var _g = 0;
		var _g1 = l;
		while(_g < _g1) {
			var i = _g++;
			var frac1 = arr[i];
			fracFloat = frac1.positive ? frac1.numerator / frac1.denominator : -frac1.numerator / frac1.denominator;
			dif = Math.abs(fracFloat - f);
			if(dif < dist) {
				dist = dif;
				fracStore = frac1;
			}
		}
		frac = fracStore;
	}
	return frac;
};
fracs_Fraction.toString = function(this1) {
	var n = this1.numerator;
	var d = this1.denominator;
	var out = n == 0 ? "0" : n == d ? "1" : d == 1 ? this1.positive ? "" + n : "-" + n : this1.positive ? "" + n + "/" + d : "-" + n + "/" + d;
	return out;
};
fracs_Fraction.fromFloat = function(f) {
	var arr = fracs_Fracs.approximateFractions(f);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac;
	var fracStore = arr[0];
	var _g = 0;
	var _g1 = l;
	while(_g < _g1) {
		var i = _g++;
		var frac = arr[i];
		fracFloat = frac.positive ? frac.numerator / frac.denominator : -frac.numerator / frac.denominator;
		dif = Math.abs(fracFloat - f);
		if(dif < dist) {
			dist = dif;
			fracStore = frac;
		}
	}
	return fracStore;
};
fracs_Fraction.firstFloat = function(f) {
	var arr = fracs_Fracs.approximateFractions(f);
	var fracStore = arr[0];
	return fracStore;
};
fracs_Fraction.byDenominator = function(this1,val) {
	var n = this1.numerator;
	var d = this1.denominator;
	var out = n == 0 ? "0" : n == d ? "1" : d == 1 ? this1.positive ? "" + n : "-" + n : this1.positive ? "" + n + "/" + d : "-" + n + "/" + d;
	var out1 = out;
	if(!(this1.denominator == val || out1 == "0" || out1 == "1")) {
		var dom = Math.round(this1.value * val);
		var numerator = dom;
		var denominator = val;
		var positive = true;
		var value = null;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			value = positive ? numerator / denominator : -numerator / denominator;
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive = !positive;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		var this1 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
		var frac = this1;
		var n = frac.numerator;
		var d = frac.denominator;
		var out = n == 0 ? "0" : n == d ? "1" : d == 1 ? frac.positive ? "" + n : "-" + n : frac.positive ? "" + n + "/" + d : "-" + n + "/" + d;
		out1 = out;
	}
	return out1;
};
fracs_Fraction.all = function(f) {
	return fracs_Fracs.approximateFractions(f);
};
fracs_Fraction.similarToFraction = function(this1) {
	var f = this1.positive ? this1.numerator / this1.denominator : -this1.numerator / this1.denominator;
	return fracs_Fracs.approximateFractions(f);
};
fracs_Fraction.similarToValue = function(this1) {
	return fracs_Fracs.approximateFractions(this1.value);
};
var fracs_Fracs = function() { };
fracs_Fracs.__name__ = true;
fracs_Fracs.grabDecimalInput = function(decimalVal) {
	var decimal = Math.abs(parseFloat(decimalVal));
	if(isNaN(decimal)) {
		return 0.;
	} else {
		return decimal;
	}
};
fracs_Fracs.approximateFractions = function(f) {
	var positive = f <= 0 ? false : true;
	var numerators = [0,1];
	var denominators = [1,0];
	var f2 = f <= 0 ? -f : f;
	var fStr = f2 == null ? "null" : "" + f2;
	var digits = "";
	var ix = fStr.indexOf(".");
	if(ix == -1) {
		digits = fStr;
	} else if(ix == 0) {
		digits = HxOverrides.substr(fStr,1,fStr.length);
	} else if(ix < fStr.length) {
		digits = HxOverrides.substr(fStr,0,ix) + HxOverrides.substr(fStr,ix + 1,fStr.length);
	}
	var LStr = digits;
	var numDigits = LStr.length;
	var L2 = f2;
	var numIntDigits = Std.string(L2).length;
	if(L2 == 0) {
		numIntDigits = 0;
	}
	var numDigitsPastDecimal = numDigits - numIntDigits;
	var i = numDigitsPastDecimal;
	var L = parseFloat(digits);
	while(i > 0 && L % 2 == 0) {
		L /= 2;
		--i;
	}
	i = numDigitsPastDecimal;
	while(i > 0 && L % 5 == 0) {
		L /= 5;
		--i;
	}
	var maxNumerator = L;
	var d2 = f2;
	var calcD;
	var prevCalcD = null;
	var val = null;
	var this1 = val == null ? [] : val;
	var arrFraction = this1;
	var j = 0;
	var _g = 2;
	while(_g < 1000) {
		var i = _g++;
		var L2 = Math.floor(d2);
		numerators[i] = L2 * numerators[i - 1] + numerators[i - 2] | 0;
		if(Math.abs(numerators[i]) > maxNumerator) {
			break;
		}
		denominators[i] = L2 * denominators[i - 1] + denominators[i - 2] | 0;
		calcD = numerators[i] / denominators[i];
		if(calcD == prevCalcD) {
			break;
		}
		var numerator = numerators[i];
		var denominator = denominators[i];
		var positive1 = positive;
		var value = f;
		if(positive1 == null) {
			positive1 = true;
		}
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			value = positive1 ? numerator / denominator : -numerator / denominator;
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive1 = !positive1;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		var this1 = { numerator : numerator, denominator : denominator, positive : positive1, value : value};
		arrFraction[arrFraction.length] = this1;
		if(calcD == f2) {
			break;
		}
		prevCalcD = calcD;
		d2 = 1 / (d2 - L2);
	}
	return arrFraction;
};
fracs_Fracs.getMaxNumerator = function(f) {
	var fStr = f == null ? "null" : "" + f;
	var digits = "";
	var ix = fStr.indexOf(".");
	if(ix == -1) {
		digits = fStr;
	} else if(ix == 0) {
		digits = HxOverrides.substr(fStr,1,fStr.length);
	} else if(ix < fStr.length) {
		digits = HxOverrides.substr(fStr,0,ix) + HxOverrides.substr(fStr,ix + 1,fStr.length);
	}
	var LStr = digits;
	var numDigits = LStr.length;
	var L2 = f;
	var numIntDigits = (L2 == null ? "null" : "" + L2).length;
	if(L2 == 0) {
		numIntDigits = 0;
	}
	var numDigitsPastDecimal = numDigits - numIntDigits;
	var i = numDigitsPastDecimal;
	var L = parseFloat(digits);
	while(i > 0 && L % 2 == 0) {
		L /= 2;
		--i;
	}
	i = numDigitsPastDecimal;
	while(i > 0 && L % 5 == 0) {
		L /= 5;
		--i;
	}
	return L;
};
fracs_Fracs.extractDigitStr = function(fStr) {
	var f2 = "";
	var ixe = fStr.indexOf("E");
	if(ixe == -1) {
		ixe = fStr.indexOf("e");
	}
	if(ixe == -1) {
		f2 = fStr;
	} else {
		f2 = HxOverrides.substr(fStr,0,ixe);
	}
	var digits = "";
	var ix = f2.indexOf(".");
	if(ix == -1) {
		digits = f2;
	} else if(ix == 0) {
		digits = HxOverrides.substr(f2,1,f2.length);
	} else if(ix < f2.length) {
		digits = HxOverrides.substr(f2,0,ix) + HxOverrides.substr(f2,ix + 1,f2.length);
	}
	return digits;
};
fracs_Fracs.getMaxNumeratorStr = function(fStr) {
	var f2 = "";
	var ixe = fStr.indexOf("E");
	if(ixe == -1) {
		ixe = fStr.indexOf("e");
	}
	if(ixe == -1) {
		f2 = fStr;
	} else {
		f2 = HxOverrides.substr(fStr,0,ixe);
	}
	var digits = "";
	var ix = f2.indexOf(".");
	if(ix == -1) {
		digits = f2;
	} else if(ix == 0) {
		digits = HxOverrides.substr(f2,1,f2.length);
	} else if(ix < f2.length) {
		digits = HxOverrides.substr(f2,0,ix) + HxOverrides.substr(f2,ix + 1,f2.length);
	}
	var LStr = digits;
	var numDigits = LStr.length;
	var L2 = fStr;
	var numIntDigits = L2.length;
	if(L2 == "0") {
		numIntDigits = 0;
	}
	var numDigitsPastDecimal = numDigits - numIntDigits;
	var i = numDigitsPastDecimal;
	var L = parseFloat(fStr);
	while(i > 0 && L % 2 == 0) {
		L /= 2;
		--i;
	}
	i = numDigitsPastDecimal;
	while(i > 0 && L % 5 == 0) {
		L /= 5;
		--i;
	}
	return L;
};
var fracs_Pi2pi = {};
fracs_Pi2pi._new = function(f) {
	var this1 = f;
	return this1;
};
fracs_Pi2pi.fromFloat = function(f) {
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_Pi2pi.additionPi = function(this1,b) {
	var f = this1 + b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_Pi2pi.subtractionPi = function(this1,b) {
	var f = this1 - b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_Pi2pi.dividePi = function(this1,b) {
	var f = this1 / b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_Pi2pi.timesPi = function(this1,b) {
	var f = this1 * b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_Pi2pi.addition = function(this1,b) {
	var f = this1 + b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_Pi2pi.subtraction = function(this1,b) {
	var f = this1 - b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_Pi2pi.divide = function(this1,b) {
	var f = this1 / b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_Pi2pi.times = function(this1,b) {
	var f = this1 * b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_Pi2pi.get_degrees = function(this1) {
	return this1 * 180 / Math.PI;
};
fracs_Pi2pi.set_degrees = function(this1,val) {
	this1 = Math.PI * val / 180;
	return val;
};
fracs_Pi2pi.fromFraction = function(val) {
	var f = (val.positive ? val.numerator / val.denominator : -val.numerator / val.denominator) * Math.PI;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_Pi2pi.tofraction = function(this1) {
	var f = this1 / Math.PI;
	var arr = fracs_Fracs.approximateFractions(f);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac;
	var fracStore = arr[0];
	var _g = 0;
	var _g1 = l;
	while(_g < _g1) {
		var i = _g++;
		var frac = arr[i];
		fracFloat = frac.positive ? frac.numerator / frac.denominator : -frac.numerator / frac.denominator;
		dif = Math.abs(fracFloat - f);
		if(dif < dist) {
			dist = dif;
			fracStore = frac;
		}
	}
	return fracStore;
};
fracs_Pi2pi.fromString = function(val) {
	var i = val.indexOf("/");
	var frac;
	if(i != -1) {
		var numerator = Std.parseInt(HxOverrides.substr(val,0,i));
		var denominator = Std.parseInt(HxOverrides.substr(val,i + 1,val.length));
		var positive = true;
		var value = null;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			value = positive ? numerator / denominator : -numerator / denominator;
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive = !positive;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		var this1 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
		frac = this1;
	} else {
		var f = parseFloat(val);
		var arr = fracs_Fracs.approximateFractions(f);
		var dist = Infinity;
		var dif;
		var l = arr.length;
		var fracFloat;
		var frac1;
		var fracStore = arr[0];
		var _g = 0;
		var _g1 = l;
		while(_g < _g1) {
			var i = _g++;
			var frac1 = arr[i];
			fracFloat = frac1.positive ? frac1.numerator / frac1.denominator : -frac1.numerator / frac1.denominator;
			dif = Math.abs(fracFloat - f);
			if(dif < dist) {
				dist = dif;
				fracStore = frac1;
			}
		}
		frac = fracStore;
	}
	var frac1 = frac;
	var f = (frac1.positive ? frac1.numerator / frac1.denominator : -frac1.numerator / frac1.denominator) * Math.PI;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_Pi2pi.toString = function(this1) {
	if(this1 == null) {
		return "null";
	} else {
		return "" + this1;
	}
};
var fracs_ZeroTo2pi = {};
fracs_ZeroTo2pi._new = function(f) {
	var this1 = f;
	return this1;
};
fracs_ZeroTo2pi.fromFloat = function(f) {
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_ZeroTo2pi.additionPi = function(this1,b) {
	var f = this1 + b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_ZeroTo2pi.subtractionPi = function(this1,b) {
	var f = this1 - b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_ZeroTo2pi.dividePi = function(this1,b) {
	var f = this1 / b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_ZeroTo2pi.timesPi = function(this1,b) {
	var f = this1 * b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_ZeroTo2pi.addition = function(this1,b) {
	var f = this1 + b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_ZeroTo2pi.subtraction = function(this1,b) {
	var f = this1 - b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_ZeroTo2pi.divide = function(this1,b) {
	var f = this1 / b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_ZeroTo2pi.times = function(this1,b) {
	var f = this1 * b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_ZeroTo2pi.get_degrees = function(this1) {
	return this1 * 180 / Math.PI;
};
fracs_ZeroTo2pi.set_degrees = function(this1,val) {
	this1 = Math.PI * val / 180;
	return val;
};
fracs_ZeroTo2pi.fromFraction = function(val) {
	var f = (val.positive ? val.numerator / val.denominator : -val.numerator / val.denominator) * Math.PI;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_ZeroTo2pi.tofraction = function(this1) {
	var f = this1 / Math.PI;
	var arr = fracs_Fracs.approximateFractions(f);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac;
	var fracStore = arr[0];
	var _g = 0;
	var _g1 = l;
	while(_g < _g1) {
		var i = _g++;
		var frac = arr[i];
		fracFloat = frac.positive ? frac.numerator / frac.denominator : -frac.numerator / frac.denominator;
		dif = Math.abs(fracFloat - f);
		if(dif < dist) {
			dist = dif;
			fracStore = frac;
		}
	}
	return fracStore;
};
fracs_ZeroTo2pi.fromString = function(val) {
	var i = val.indexOf("/");
	var frac;
	if(i != -1) {
		var numerator = Std.parseInt(HxOverrides.substr(val,0,i));
		var denominator = Std.parseInt(HxOverrides.substr(val,i + 1,val.length));
		var positive = true;
		var value = null;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			value = positive ? numerator / denominator : -numerator / denominator;
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive = !positive;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		var this1 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
		frac = this1;
	} else {
		var f = parseFloat(val);
		var arr = fracs_Fracs.approximateFractions(f);
		var dist = Infinity;
		var dif;
		var l = arr.length;
		var fracFloat;
		var frac1;
		var fracStore = arr[0];
		var _g = 0;
		var _g1 = l;
		while(_g < _g1) {
			var i = _g++;
			var frac1 = arr[i];
			fracFloat = frac1.positive ? frac1.numerator / frac1.denominator : -frac1.numerator / frac1.denominator;
			dif = Math.abs(fracFloat - f);
			if(dif < dist) {
				dist = dif;
				fracStore = frac1;
			}
		}
		frac = fracStore;
	}
	var frac1 = frac;
	var f = (frac1.positive ? frac1.numerator / frac1.denominator : -frac1.numerator / frac1.denominator) * Math.PI;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f1;
	return this1;
};
fracs_ZeroTo2pi.toString = function(this1) {
	if(this1 == null) {
		return "null";
	} else {
		return "" + this1;
	}
};
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	unwrap: function() {
		return this.__nativeException;
	}
	,get_native: function() {
		return this.__nativeException;
	}
});
var haxe_Log = function() { };
haxe_Log.__name__ = true;
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	unwrap: function() {
		return this.value;
	}
});
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.prototype = {
	remove: function(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	}
};
var haxe_ds_ObjectMap = function() { };
haxe_ds_ObjectMap.__name__ = true;
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = true;
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
haxe_io_Path.__name__ = true;
haxe_io_Path.extension = function(path) {
	var s = new haxe_io_Path(path);
	if(s.ext == null) {
		return "";
	}
	return s.ext;
};
haxe_io_Path.join = function(paths) {
	var _g = [];
	var _g1 = 0;
	var _g2 = paths;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(v != null && v != "") {
			_g.push(v);
		}
	}
	var paths = _g;
	if(paths.length == 0) {
		return "";
	}
	var path = paths[0];
	var _g = 1;
	var _g1 = paths.length;
	while(_g < _g1) {
		var i = _g++;
		path = haxe_io_Path.addTrailingSlash(path);
		path += paths[i];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	var slash = "/";
	path = path.split("\\").join(slash);
	if(path == slash) {
		return slash;
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split(slash);
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token == "") {
			if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
				target.push(token);
			}
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join(slash);
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g2_offset = 0;
	var _g2_s = tmp;
	while(_g2_offset < _g2_s.length) {
		var s = _g2_s;
		var index = _g2_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g2_offset;
		}
		var c2 = c1;
		switch(c2) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				var i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			var i1 = c2;
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCodePoint(i1);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
haxe_io_Path.isAbsolute = function(path) {
	if(StringTools.startsWith(path,"/")) {
		return true;
	}
	if(path.charAt(1) == ":") {
		return true;
	}
	if(StringTools.startsWith(path,"\\\\")) {
		return true;
	}
	return false;
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
var htmlHelper_tools_DivertTrace = function(left,d) {
	if(left == null) {
		left = 610;
	}
	this.textStyle1 = "<span style=\"font-size:14px; color:Grey\">";
	this.textStyle0 = "<span style=\"font-size:12px; color:Silver\">";
	this.traceString = "";
	this.divertTrace(left,d);
};
htmlHelper_tools_DivertTrace.__name__ = true;
htmlHelper_tools_DivertTrace.prototype = {
	divertTrace: function(left,d) {
		if(d == null) {
			var doc = window.document;
			this.traceDiv = doc.createElement("div");
			doc.body.appendChild(this.traceDiv);
			var dom = this.traceDiv;
			var style = dom.style;
			style.position = "absolute";
			style.top = "0px";
			style.left = (left == null ? "null" : "" + left) + "px";
			style.height = "500px";
			style.width = "500px";
			style.zIndex = "99";
			style.overflow = "auto";
		} else {
			this.traceDiv = d;
		}
		haxe_Log.trace = $bind(this,this.myTrace);
	}
	,myTrace: function(v,inf) {
		if(Std.string(v) == "") {
			return;
		}
		this.traceString += this.textStyle0 + inf.className + "." + inf.methodName + " ( " + (inf.lineNumber == null ? "null" : "" + inf.lineNumber) + " )" + "</span>" + "<br> - " + this.textStyle1 + Std.string(v) + "</span>" + "<br>";
		this.traceDiv.innerHTML = this.traceString;
	}
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var js_html__$CanvasElement_CanvasUtil = function() { };
js_html__$CanvasElement_CanvasUtil.__name__ = true;
js_html__$CanvasElement_CanvasUtil.getContextWebGL = function(canvas,attribs) {
	var name = "webgl";
	var ctx = canvas.getContext(name,attribs);
	if(ctx != null) {
		return ctx;
	}
	var name = "experimental-webgl";
	var ctx = canvas.getContext(name,attribs);
	if(ctx != null) {
		return ctx;
	}
	return null;
};
var justPath_transform_ScaleContext = function(pathContext_,sx_,sy_) {
	this.pathContext = pathContext_;
	this.sx = sx_;
	this.sy = sy_;
};
justPath_transform_ScaleContext.__name__ = true;
justPath_transform_ScaleContext.prototype = {
	moveTo: function(x,y) {
		this.pathContext.moveTo(x * this.sx,y * this.sy);
	}
	,lineTo: function(x,y) {
		this.pathContext.lineTo(x * this.sx,y * this.sy);
	}
	,quadTo: function(x1,y1,x2,y2) {
		this.pathContext.quadTo(x1 * this.sx,y1 * this.sy,x2 * this.sx,y2 * this.sy);
	}
	,curveTo: function(x1,y1,x2,y2,x3,y3) {
		this.pathContext.curveTo(x1 * this.sx,y1 * this.sy,x2 * this.sx,y2 * this.sy,x3 * this.sx,y3 * this.sy);
	}
};
var justPath_transform_ScaleTranslateContext = function(pathContext_,dx_,dy_,sx_,sy_) {
	this.pathContext = pathContext_;
	this.dx = dx_;
	this.dy = dy_;
	this.sx = sx_;
	this.sy = sy_;
};
justPath_transform_ScaleTranslateContext.__name__ = true;
justPath_transform_ScaleTranslateContext.prototype = {
	moveTo: function(x,y) {
		this.pathContext.moveTo(x * this.sx + this.dx,y * this.sy + this.dy);
	}
	,lineTo: function(x,y) {
		this.pathContext.lineTo(x * this.sx + this.dx,y * this.sy + this.dy);
	}
	,quadTo: function(x1,y1,x2,y2) {
		this.pathContext.quadTo(x1 * this.sx + this.dx,y1 * this.sy + this.dy,x2 * this.sx + this.dx,y2 * this.sy + this.dy);
	}
	,curveTo: function(x1,y1,x2,y2,x3,y3) {
		this.pathContext.curveTo(x1 * this.sx + this.dx,y1 * this.sy + this.dy,x2 * this.sx + this.dx,y2 * this.sy + this.dy,x3 * this.sx + this.dx,y3 * this.sy + this.dy);
	}
};
var justPath_transform_TranslationContext = function(pathContext_,dx_,dy_) {
	this.pathContext = pathContext_;
	this.dx = dx_;
	this.dy = dy_;
};
justPath_transform_TranslationContext.__name__ = true;
justPath_transform_TranslationContext.prototype = {
	moveTo: function(x,y) {
		this.pathContext.moveTo(x + this.dx,y + this.dy);
	}
	,lineTo: function(x,y) {
		this.pathContext.lineTo(x + this.dx,y + this.dy);
	}
	,quadTo: function(x1,y1,x2,y2) {
		this.pathContext.quadTo(x1 + this.dx,y1 + this.dy,x2 + this.dx,y2 + this.dy);
	}
	,curveTo: function(x1,y1,x2,y2,x3,y3) {
		this.pathContext.curveTo(x1 + this.dx,y1 + this.dy,x2 + this.dx,y2 + this.dy,x3 + this.dx,y3 + this.dy);
	}
};
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
Date.__name__ = "Date";
haxe_ds_ObjectMap.count = 0;
js_Boot.__toStr = ({ }).toString;
clay_ArrayPool.ALLOC_STEP = 10;
clay_ArrayPool.dynPool10 = new clay_ArrayPool(10);
clay_ArrayPool.dynPool100 = new clay_ArrayPool(100);
clay_ArrayPool.dynPool1000 = new clay_ArrayPool(1000);
clay_ArrayPool.dynPool10000 = new clay_ArrayPool(10000);
clay_ArrayPool.dynPool100000 = new clay_ArrayPool(100000);
clay_ArrayPool.didNotifyLargePool = false;
clay_Immediate.immediateCallbacks = [];
clay_Immediate.immediateCallbacksCapacity = 0;
clay_Immediate.immediateCallbacksLen = 0;
clay_KeyCode.UNKNOWN = 0;
clay_KeyCode.ENTER = 13;
clay_KeyCode.ESCAPE = 27;
clay_KeyCode.BACKSPACE = 8;
clay_KeyCode.TAB = 9;
clay_KeyCode.SPACE = 32;
clay_KeyCode.EXCLAIM = 33;
clay_KeyCode.QUOTEDBL = 34;
clay_KeyCode.HASH = 35;
clay_KeyCode.PERCENT = 37;
clay_KeyCode.DOLLAR = 36;
clay_KeyCode.AMPERSAND = 38;
clay_KeyCode.QUOTE = 39;
clay_KeyCode.LEFTPAREN = 40;
clay_KeyCode.RIGHTPAREN = 41;
clay_KeyCode.ASTERISK = 42;
clay_KeyCode.PLUS = 43;
clay_KeyCode.COMMA = 44;
clay_KeyCode.MINUS = 45;
clay_KeyCode.PERIOD = 46;
clay_KeyCode.SLASH = 47;
clay_KeyCode.KEY_0 = 48;
clay_KeyCode.KEY_1 = 49;
clay_KeyCode.KEY_2 = 50;
clay_KeyCode.KEY_3 = 51;
clay_KeyCode.KEY_4 = 52;
clay_KeyCode.KEY_5 = 53;
clay_KeyCode.KEY_6 = 54;
clay_KeyCode.KEY_7 = 55;
clay_KeyCode.KEY_8 = 56;
clay_KeyCode.KEY_9 = 57;
clay_KeyCode.COLON = 58;
clay_KeyCode.SEMICOLON = 59;
clay_KeyCode.LESS = 60;
clay_KeyCode.EQUALS = 61;
clay_KeyCode.GREATER = 62;
clay_KeyCode.QUESTION = 63;
clay_KeyCode.AT = 64;
clay_KeyCode.LEFTBRACKET = 91;
clay_KeyCode.BACKSLASH = 92;
clay_KeyCode.RIGHTBRACKET = 93;
clay_KeyCode.CARET = 94;
clay_KeyCode.UNDERSCORE = 95;
clay_KeyCode.BACKQUOTE = 96;
clay_KeyCode.KEY_A = 97;
clay_KeyCode.KEY_B = 98;
clay_KeyCode.KEY_C = 99;
clay_KeyCode.KEY_D = 100;
clay_KeyCode.KEY_E = 101;
clay_KeyCode.KEY_F = 102;
clay_KeyCode.KEY_G = 103;
clay_KeyCode.KEY_H = 104;
clay_KeyCode.KEY_I = 105;
clay_KeyCode.KEY_J = 106;
clay_KeyCode.KEY_K = 107;
clay_KeyCode.KEY_L = 108;
clay_KeyCode.KEY_M = 109;
clay_KeyCode.KEY_N = 110;
clay_KeyCode.KEY_O = 111;
clay_KeyCode.KEY_P = 112;
clay_KeyCode.KEY_Q = 113;
clay_KeyCode.KEY_R = 114;
clay_KeyCode.KEY_S = 115;
clay_KeyCode.KEY_T = 116;
clay_KeyCode.KEY_U = 117;
clay_KeyCode.KEY_V = 118;
clay_KeyCode.KEY_W = 119;
clay_KeyCode.KEY_X = 120;
clay_KeyCode.KEY_Y = 121;
clay_KeyCode.KEY_Z = 122;
clay_KeyCode.CAPSLOCK = 1073741881;
clay_KeyCode.F1 = 1073741882;
clay_KeyCode.F2 = 1073741883;
clay_KeyCode.F3 = 1073741884;
clay_KeyCode.F4 = 1073741885;
clay_KeyCode.F5 = 1073741886;
clay_KeyCode.F6 = 1073741887;
clay_KeyCode.F7 = 1073741888;
clay_KeyCode.F8 = 1073741889;
clay_KeyCode.F9 = 1073741890;
clay_KeyCode.F10 = 1073741891;
clay_KeyCode.F11 = 1073741892;
clay_KeyCode.F12 = 1073741893;
clay_KeyCode.PRINTSCREEN = 1073741894;
clay_KeyCode.SCROLLLOCK = 1073741895;
clay_KeyCode.PAUSE = 1073741896;
clay_KeyCode.INSERT = 1073741897;
clay_KeyCode.HOME = 1073741898;
clay_KeyCode.PAGEUP = 1073741899;
clay_KeyCode.DELETE = 127;
clay_KeyCode.END = 1073741901;
clay_KeyCode.PAGEDOWN = 1073741902;
clay_KeyCode.RIGHT = 1073741903;
clay_KeyCode.LEFT = 1073741904;
clay_KeyCode.DOWN = 1073741905;
clay_KeyCode.UP = 1073741906;
clay_KeyCode.NUMLOCKCLEAR = 1073741907;
clay_KeyCode.KP_DIVIDE = 1073741908;
clay_KeyCode.KP_MULTIPLY = 1073741909;
clay_KeyCode.KP_MINUS = 1073741910;
clay_KeyCode.KP_PLUS = 1073741911;
clay_KeyCode.KP_ENTER = 1073741912;
clay_KeyCode.KP_1 = 1073741913;
clay_KeyCode.KP_2 = 1073741914;
clay_KeyCode.KP_3 = 1073741915;
clay_KeyCode.KP_4 = 1073741916;
clay_KeyCode.KP_5 = 1073741917;
clay_KeyCode.KP_6 = 1073741918;
clay_KeyCode.KP_7 = 1073741919;
clay_KeyCode.KP_8 = 1073741920;
clay_KeyCode.KP_9 = 1073741921;
clay_KeyCode.KP_0 = 1073741922;
clay_KeyCode.KP_PERIOD = 1073741923;
clay_KeyCode.APPLICATION = 1073741925;
clay_KeyCode.POWER = 1073741926;
clay_KeyCode.KP_EQUALS = 1073741927;
clay_KeyCode.F13 = 1073741928;
clay_KeyCode.F14 = 1073741929;
clay_KeyCode.F15 = 1073741930;
clay_KeyCode.F16 = 1073741931;
clay_KeyCode.F17 = 1073741932;
clay_KeyCode.F18 = 1073741933;
clay_KeyCode.F19 = 1073741934;
clay_KeyCode.F20 = 1073741935;
clay_KeyCode.F21 = 1073741936;
clay_KeyCode.F22 = 1073741937;
clay_KeyCode.F23 = 1073741938;
clay_KeyCode.F24 = 1073741939;
clay_KeyCode.EXECUTE = 1073741940;
clay_KeyCode.HELP = 1073741941;
clay_KeyCode.MENU = 1073741942;
clay_KeyCode.SELECT = 1073741943;
clay_KeyCode.STOP = 1073741944;
clay_KeyCode.AGAIN = 1073741945;
clay_KeyCode.UNDO = 1073741946;
clay_KeyCode.CUT = 1073741947;
clay_KeyCode.COPY = 1073741948;
clay_KeyCode.PASTE = 1073741949;
clay_KeyCode.FIND = 1073741950;
clay_KeyCode.MUTE = 1073741951;
clay_KeyCode.VOLUMEUP = 1073741952;
clay_KeyCode.VOLUMEDOWN = 1073741953;
clay_KeyCode.KP_COMMA = 1073741957;
clay_KeyCode.KP_EQUALSAS400 = 1073741958;
clay_KeyCode.ALTERASE = 1073741977;
clay_KeyCode.SYSREQ = 1073741978;
clay_KeyCode.CANCEL = 1073741979;
clay_KeyCode.CLEAR = 1073741980;
clay_KeyCode.PRIOR = 1073741981;
clay_KeyCode.RETURN2 = 1073741982;
clay_KeyCode.SEPARATOR = 1073741983;
clay_KeyCode.OUT = 1073741984;
clay_KeyCode.OPER = 1073741985;
clay_KeyCode.CLEARAGAIN = 1073741986;
clay_KeyCode.CRSEL = 1073741987;
clay_KeyCode.EXSEL = 1073741988;
clay_KeyCode.KP_00 = 1073742000;
clay_KeyCode.KP_000 = 1073742001;
clay_KeyCode.THOUSANDSSEPARATOR = 1073742002;
clay_KeyCode.DECIMALSEPARATOR = 1073742003;
clay_KeyCode.CURRENCYUNIT = 1073742004;
clay_KeyCode.CURRENCYSUBUNIT = 1073742005;
clay_KeyCode.KP_LEFTPAREN = 1073742006;
clay_KeyCode.KP_RIGHTPAREN = 1073742007;
clay_KeyCode.KP_LEFTBRACE = 1073742008;
clay_KeyCode.KP_RIGHTBRACE = 1073742009;
clay_KeyCode.KP_TAB = 1073742010;
clay_KeyCode.KP_BACKSPACE = 1073742011;
clay_KeyCode.KP_A = 1073742012;
clay_KeyCode.KP_B = 1073742013;
clay_KeyCode.KP_C = 1073742014;
clay_KeyCode.KP_D = 1073742015;
clay_KeyCode.KP_E = 1073742016;
clay_KeyCode.KP_F = 1073742017;
clay_KeyCode.KP_XOR = 1073742018;
clay_KeyCode.KP_POWER = 1073742019;
clay_KeyCode.KP_PERCENT = 1073742020;
clay_KeyCode.KP_LESS = 1073742021;
clay_KeyCode.KP_GREATER = 1073742022;
clay_KeyCode.KP_AMPERSAND = 1073742023;
clay_KeyCode.KP_DBLAMPERSAND = 1073742024;
clay_KeyCode.KP_VERTICALBAR = 1073742025;
clay_KeyCode.KP_DBLVERTICALBAR = 1073742026;
clay_KeyCode.KP_COLON = 1073742027;
clay_KeyCode.KP_HASH = 1073742028;
clay_KeyCode.KP_SPACE = 1073742029;
clay_KeyCode.KP_AT = 1073742030;
clay_KeyCode.KP_EXCLAM = 1073742031;
clay_KeyCode.KP_MEMSTORE = 1073742032;
clay_KeyCode.KP_MEMRECALL = 1073742033;
clay_KeyCode.KP_MEMCLEAR = 1073742034;
clay_KeyCode.KP_MEMADD = 1073742035;
clay_KeyCode.KP_MEMSUBTRACT = 1073742036;
clay_KeyCode.KP_MEMMULTIPLY = 1073742037;
clay_KeyCode.KP_MEMDIVIDE = 1073742038;
clay_KeyCode.KP_PLUSMINUS = 1073742039;
clay_KeyCode.KP_CLEAR = 1073742040;
clay_KeyCode.KP_CLEARENTRY = 1073742041;
clay_KeyCode.KP_BINARY = 1073742042;
clay_KeyCode.KP_OCTAL = 1073742043;
clay_KeyCode.KP_DECIMAL = 1073742044;
clay_KeyCode.KP_HEXADECIMAL = 1073742045;
clay_KeyCode.LCTRL = 1073742048;
clay_KeyCode.LSHIFT = 1073742049;
clay_KeyCode.LALT = 1073742050;
clay_KeyCode.LMETA = 1073742051;
clay_KeyCode.RCTRL = 1073742052;
clay_KeyCode.RSHIFT = 1073742053;
clay_KeyCode.RALT = 1073742054;
clay_KeyCode.RMETA = 1073742055;
clay_KeyCode.MODE = 1073742081;
clay_KeyCode.AUDIONEXT = 1073742082;
clay_KeyCode.AUDIOPREV = 1073742083;
clay_KeyCode.AUDIOSTOP = 1073742084;
clay_KeyCode.AUDIOPLAY = 1073742085;
clay_KeyCode.AUDIOMUTE = 1073742086;
clay_KeyCode.MEDIASELECT = 1073742087;
clay_KeyCode.WWW = 1073742088;
clay_KeyCode.MAIL = 1073742089;
clay_KeyCode.CALCULATOR = 1073742090;
clay_KeyCode.COMPUTER = 1073742091;
clay_KeyCode.AC_SEARCH = 1073742092;
clay_KeyCode.AC_HOME = 1073742093;
clay_KeyCode.AC_BACK = 1073742094;
clay_KeyCode.AC_FORWARD = 1073742095;
clay_KeyCode.AC_STOP = 1073742096;
clay_KeyCode.AC_REFRESH = 1073742097;
clay_KeyCode.AC_BOOKMARKS = 1073742098;
clay_KeyCode.BRIGHTNESSDOWN = 1073742099;
clay_KeyCode.BRIGHTNESSUP = 1073742100;
clay_KeyCode.DISPLAYSWITCH = 1073742101;
clay_KeyCode.KBDILLUMTOGGLE = 1073742102;
clay_KeyCode.KBDILLUMDOWN = 1073742103;
clay_KeyCode.KBDILLUMUP = 1073742104;
clay_KeyCode.EJECT = 1073742105;
clay_KeyCode.SLEEP = 1073742106;
clay_ScanCode.MASK = 1073741824;
clay_ScanCode.UNKNOWN = 0;
clay_ScanCode.KEY_A = 4;
clay_ScanCode.KEY_B = 5;
clay_ScanCode.KEY_C = 6;
clay_ScanCode.KEY_D = 7;
clay_ScanCode.KEY_E = 8;
clay_ScanCode.KEY_F = 9;
clay_ScanCode.KEY_G = 10;
clay_ScanCode.KEY_H = 11;
clay_ScanCode.KEY_I = 12;
clay_ScanCode.KEY_J = 13;
clay_ScanCode.KEY_K = 14;
clay_ScanCode.KEY_L = 15;
clay_ScanCode.KEY_M = 16;
clay_ScanCode.KEY_N = 17;
clay_ScanCode.KEY_O = 18;
clay_ScanCode.KEY_P = 19;
clay_ScanCode.KEY_Q = 20;
clay_ScanCode.KEY_R = 21;
clay_ScanCode.KEY_S = 22;
clay_ScanCode.KEY_T = 23;
clay_ScanCode.KEY_U = 24;
clay_ScanCode.KEY_V = 25;
clay_ScanCode.KEY_W = 26;
clay_ScanCode.KEY_X = 27;
clay_ScanCode.KEY_Y = 28;
clay_ScanCode.KEY_Z = 29;
clay_ScanCode.KEY_1 = 30;
clay_ScanCode.KEY_2 = 31;
clay_ScanCode.KEY_3 = 32;
clay_ScanCode.KEY_4 = 33;
clay_ScanCode.KEY_5 = 34;
clay_ScanCode.KEY_6 = 35;
clay_ScanCode.KEY_7 = 36;
clay_ScanCode.KEY_8 = 37;
clay_ScanCode.KEY_9 = 38;
clay_ScanCode.KEY_0 = 39;
clay_ScanCode.ENTER = 40;
clay_ScanCode.ESCAPE = 41;
clay_ScanCode.BACKSPACE = 42;
clay_ScanCode.TAB = 43;
clay_ScanCode.SPACE = 44;
clay_ScanCode.MINUS = 45;
clay_ScanCode.EQUALS = 46;
clay_ScanCode.LEFTBRACKET = 47;
clay_ScanCode.RIGHTBRACKET = 48;
clay_ScanCode.BACKSLASH = 49;
clay_ScanCode.NONUSHASH = 50;
clay_ScanCode.SEMICOLON = 51;
clay_ScanCode.APOSTROPHE = 52;
clay_ScanCode.GRAVE = 53;
clay_ScanCode.COMMA = 54;
clay_ScanCode.PERIOD = 55;
clay_ScanCode.SLASH = 56;
clay_ScanCode.CAPSLOCK = 57;
clay_ScanCode.F1 = 58;
clay_ScanCode.F2 = 59;
clay_ScanCode.F3 = 60;
clay_ScanCode.F4 = 61;
clay_ScanCode.F5 = 62;
clay_ScanCode.F6 = 63;
clay_ScanCode.F7 = 64;
clay_ScanCode.F8 = 65;
clay_ScanCode.F9 = 66;
clay_ScanCode.F10 = 67;
clay_ScanCode.F11 = 68;
clay_ScanCode.F12 = 69;
clay_ScanCode.PRINTSCREEN = 70;
clay_ScanCode.SCROLLLOCK = 71;
clay_ScanCode.PAUSE = 72;
clay_ScanCode.INSERT = 73;
clay_ScanCode.HOME = 74;
clay_ScanCode.PAGEUP = 75;
clay_ScanCode.DELETE = 76;
clay_ScanCode.END = 77;
clay_ScanCode.PAGEDOWN = 78;
clay_ScanCode.RIGHT = 79;
clay_ScanCode.LEFT = 80;
clay_ScanCode.DOWN = 81;
clay_ScanCode.UP = 82;
clay_ScanCode.NUMLOCKCLEAR = 83;
clay_ScanCode.KP_DIVIDE = 84;
clay_ScanCode.KP_MULTIPLY = 85;
clay_ScanCode.KP_MINUS = 86;
clay_ScanCode.KP_PLUS = 87;
clay_ScanCode.KP_ENTER = 88;
clay_ScanCode.KP_1 = 89;
clay_ScanCode.KP_2 = 90;
clay_ScanCode.KP_3 = 91;
clay_ScanCode.KP_4 = 92;
clay_ScanCode.KP_5 = 93;
clay_ScanCode.KP_6 = 94;
clay_ScanCode.KP_7 = 95;
clay_ScanCode.KP_8 = 96;
clay_ScanCode.KP_9 = 97;
clay_ScanCode.KP_0 = 98;
clay_ScanCode.KP_PERIOD = 99;
clay_ScanCode.NONUSBACKSLASH = 100;
clay_ScanCode.APPLICATION = 101;
clay_ScanCode.POWER = 102;
clay_ScanCode.KP_EQUALS = 103;
clay_ScanCode.F13 = 104;
clay_ScanCode.F14 = 105;
clay_ScanCode.F15 = 106;
clay_ScanCode.F16 = 107;
clay_ScanCode.F17 = 108;
clay_ScanCode.F18 = 109;
clay_ScanCode.F19 = 110;
clay_ScanCode.F20 = 111;
clay_ScanCode.F21 = 112;
clay_ScanCode.F22 = 113;
clay_ScanCode.F23 = 114;
clay_ScanCode.F24 = 115;
clay_ScanCode.EXECUTE = 116;
clay_ScanCode.HELP = 117;
clay_ScanCode.MENU = 118;
clay_ScanCode.SELECT = 119;
clay_ScanCode.STOP = 120;
clay_ScanCode.AGAIN = 121;
clay_ScanCode.UNDO = 122;
clay_ScanCode.CUT = 123;
clay_ScanCode.COPY = 124;
clay_ScanCode.PASTE = 125;
clay_ScanCode.FIND = 126;
clay_ScanCode.MUTE = 127;
clay_ScanCode.VOLUMEUP = 128;
clay_ScanCode.VOLUMEDOWN = 129;
clay_ScanCode.KP_COMMA = 133;
clay_ScanCode.KP_EQUALSAS400 = 134;
clay_ScanCode.INTERNATIONAL1 = 135;
clay_ScanCode.INTERNATIONAL2 = 136;
clay_ScanCode.INTERNATIONAL3 = 137;
clay_ScanCode.INTERNATIONAL4 = 138;
clay_ScanCode.INTERNATIONAL5 = 139;
clay_ScanCode.INTERNATIONAL6 = 140;
clay_ScanCode.INTERNATIONAL7 = 141;
clay_ScanCode.INTERNATIONAL8 = 142;
clay_ScanCode.INTERNATIONAL9 = 143;
clay_ScanCode.LANG1 = 144;
clay_ScanCode.LANG2 = 145;
clay_ScanCode.LANG3 = 146;
clay_ScanCode.LANG4 = 147;
clay_ScanCode.LANG5 = 148;
clay_ScanCode.LANG6 = 149;
clay_ScanCode.LANG7 = 150;
clay_ScanCode.LANG8 = 151;
clay_ScanCode.LANG9 = 152;
clay_ScanCode.ALTERASE = 153;
clay_ScanCode.SYSREQ = 154;
clay_ScanCode.CANCEL = 155;
clay_ScanCode.CLEAR = 156;
clay_ScanCode.PRIOR = 157;
clay_ScanCode.RETURN2 = 158;
clay_ScanCode.SEPARATOR = 159;
clay_ScanCode.OUT = 160;
clay_ScanCode.OPER = 161;
clay_ScanCode.CLEARAGAIN = 162;
clay_ScanCode.CRSEL = 163;
clay_ScanCode.EXSEL = 164;
clay_ScanCode.KP_00 = 176;
clay_ScanCode.KP_000 = 177;
clay_ScanCode.THOUSANDSSEPARATOR = 178;
clay_ScanCode.DECIMALSEPARATOR = 179;
clay_ScanCode.CURRENCYUNIT = 180;
clay_ScanCode.CURRENCYSUBUNIT = 181;
clay_ScanCode.KP_LEFTPAREN = 182;
clay_ScanCode.KP_RIGHTPAREN = 183;
clay_ScanCode.KP_LEFTBRACE = 184;
clay_ScanCode.KP_RIGHTBRACE = 185;
clay_ScanCode.KP_TAB = 186;
clay_ScanCode.KP_BACKSPACE = 187;
clay_ScanCode.KP_A = 188;
clay_ScanCode.KP_B = 189;
clay_ScanCode.KP_C = 190;
clay_ScanCode.KP_D = 191;
clay_ScanCode.KP_E = 192;
clay_ScanCode.KP_F = 193;
clay_ScanCode.KP_XOR = 194;
clay_ScanCode.KP_POWER = 195;
clay_ScanCode.KP_PERCENT = 196;
clay_ScanCode.KP_LESS = 197;
clay_ScanCode.KP_GREATER = 198;
clay_ScanCode.KP_AMPERSAND = 199;
clay_ScanCode.KP_DBLAMPERSAND = 200;
clay_ScanCode.KP_VERTICALBAR = 201;
clay_ScanCode.KP_DBLVERTICALBAR = 202;
clay_ScanCode.KP_COLON = 203;
clay_ScanCode.KP_HASH = 204;
clay_ScanCode.KP_SPACE = 205;
clay_ScanCode.KP_AT = 206;
clay_ScanCode.KP_EXCLAM = 207;
clay_ScanCode.KP_MEMSTORE = 208;
clay_ScanCode.KP_MEMRECALL = 209;
clay_ScanCode.KP_MEMCLEAR = 210;
clay_ScanCode.KP_MEMADD = 211;
clay_ScanCode.KP_MEMSUBTRACT = 212;
clay_ScanCode.KP_MEMMULTIPLY = 213;
clay_ScanCode.KP_MEMDIVIDE = 214;
clay_ScanCode.KP_PLUSMINUS = 215;
clay_ScanCode.KP_CLEAR = 216;
clay_ScanCode.KP_CLEARENTRY = 217;
clay_ScanCode.KP_BINARY = 218;
clay_ScanCode.KP_OCTAL = 219;
clay_ScanCode.KP_DECIMAL = 220;
clay_ScanCode.KP_HEXADECIMAL = 221;
clay_ScanCode.LCTRL = 224;
clay_ScanCode.LSHIFT = 225;
clay_ScanCode.LALT = 226;
clay_ScanCode.LMETA = 227;
clay_ScanCode.RCTRL = 228;
clay_ScanCode.RSHIFT = 229;
clay_ScanCode.RALT = 230;
clay_ScanCode.RMETA = 231;
clay_ScanCode.MODE = 257;
clay_ScanCode.AUDIONEXT = 258;
clay_ScanCode.AUDIOPREV = 259;
clay_ScanCode.AUDIOSTOP = 260;
clay_ScanCode.AUDIOPLAY = 261;
clay_ScanCode.AUDIOMUTE = 262;
clay_ScanCode.MEDIASELECT = 263;
clay_ScanCode.WWW = 264;
clay_ScanCode.MAIL = 265;
clay_ScanCode.CALCULATOR = 266;
clay_ScanCode.COMPUTER = 267;
clay_ScanCode.AC_SEARCH = 268;
clay_ScanCode.AC_HOME = 269;
clay_ScanCode.AC_BACK = 270;
clay_ScanCode.AC_FORWARD = 271;
clay_ScanCode.AC_STOP = 272;
clay_ScanCode.AC_REFRESH = 273;
clay_ScanCode.AC_BOOKMARKS = 274;
clay_ScanCode.BRIGHTNESSDOWN = 275;
clay_ScanCode.BRIGHTNESSUP = 276;
clay_ScanCode.DISPLAYSWITCH = 277;
clay_ScanCode.KBDILLUMTOGGLE = 278;
clay_ScanCode.KBDILLUMDOWN = 279;
clay_ScanCode.KBDILLUMUP = 280;
clay_ScanCode.EJECT = 281;
clay_ScanCode.SLEEP = 282;
clay_ScanCode.APP1 = 283;
clay_ScanCode.APP2 = 284;
clay_ScanCode.scanCodeNames = [null,null,null,null,"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","1","2","3","4","5","6","7","8","9","0","Enter","Escape","Backspace","Tab","Space","-","=","[","]","\\","#",";","'","`",",",".","/","CapsLock","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","PrintScreen","ScrollLock","Pause","Insert","Home","PageUp","Delete","End","PageDown","Right","Left","Down","Up","Numlock","Keypad /","Keypad *","Keypad -","Keypad +","Keypad Enter","Keypad 1","Keypad 2","Keypad 3","Keypad 4","Keypad 5","Keypad 6","Keypad 7","Keypad 8","Keypad 9","Keypad 0","Keypad .",null,"Application","Power","Keypad =","F13","F14","F15","F16","F17","F18","F19","F20","F21","F22","F23","F24","Execute","Help","Menu","Select","Stop","Again","Undo","Cut","Copy","Paste","Find","Mute","VolumeUp","VolumeDown",null,null,null,"Keypad ,","Keypad = (AS400)",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"AltErase","SysReq","Cancel","Clear","Prior","Enter","Separator","Out","Oper","Clear / Again","CrSel","ExSel",null,null,null,null,null,null,null,null,null,null,null,"Keypad 00","Keypad 000","ThousandsSeparator","DecimalSeparator","CurrencyUnit","CurrencySubUnit","Keypad (","Keypad )","Keypad {","Keypad }","Keypad Tab","Keypad Backspace","Keypad A","Keypad B","Keypad C","Keypad D","Keypad E","Keypad F","Keypad XOR","Keypad ^","Keypad %","Keypad <","Keypad >","Keypad &","Keypad &&","Keypad |","Keypad ||","Keypad :","Keypad #","Keypad Space","Keypad @","Keypad !","Keypad MemStore","Keypad MemRecall","Keypad MemClear","Keypad MemAdd","Keypad MemSubtract","Keypad MemMultiply","Keypad MemDivide","Keypad +/-","Keypad Clear","Keypad ClearEntry","Keypad Binary","Keypad Octal","Keypad Decimal","Keypad Hexadecimal",null,null,"Left Ctrl","Left Shift","Left Alt","Left Meta","Right Ctrl","Right Shift","Right Alt","Right Meta",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"ModeSwitch","AudioNext","AudioPrev","AudioStop","AudioPlay","AudioMute","MediaSelect","WWW","Mail","Calculator","Computer","AC Search","AC Home","AC Back","AC Forward","AC Stop","AC Refresh","AC Bookmarks","BrightnessDown","BrightnessUp","DisplaySwitch","KBDIllumToggle","KBDIllumDown","KBDIllumUp","Eject","Sleep"];
clay_GamepadDeviceEventType.UNKNOWN = 0;
clay_GamepadDeviceEventType.DEVICE_ADDED = 1;
clay_GamepadDeviceEventType.DEVICE_REMOVED = 2;
clay_GamepadDeviceEventType.DEVICE_REMAPPED = 3;
clay_TextEventType.UNKNOWN = 0;
clay_TextEventType.EDIT = 1;
clay_TextEventType.INPUT = 2;
clay_WindowEventType.UNKNOWN = 0;
clay_WindowEventType.SHOWN = 1;
clay_WindowEventType.HIDDEN = 2;
clay_WindowEventType.EXPOSED = 3;
clay_WindowEventType.MOVED = 4;
clay_WindowEventType.RESIZED = 5;
clay_WindowEventType.SIZE_CHANGED = 6;
clay_WindowEventType.MINIMIZED = 7;
clay_WindowEventType.MAXIMIZED = 8;
clay_WindowEventType.RESTORED = 9;
clay_WindowEventType.ENTER = 10;
clay_WindowEventType.LEAVE = 11;
clay_WindowEventType.FOCUS_GAINED = 12;
clay_WindowEventType.FOCUS_LOST = 13;
clay_WindowEventType.CLOSE = 14;
clay_WindowEventType.ENTER_FULLSCREEN = 15;
clay_WindowEventType.EXIT_FULLSCREEN = 16;
clay_AppEventType.UNKNOWN = 0;
clay_AppEventType.TERMINATING = 11;
clay_AppEventType.LOW_MEMORY = 12;
clay_AppEventType.WILL_ENTER_BACKGROUND = 13;
clay_AppEventType.DID_ENTER_BACKGROUND = 14;
clay_AppEventType.WILL_ENTER_FOREGROUND = 15;
clay_AppEventType.DID_ENTER_FOREGROUND = 16;
clay_Utils._nextUniqueIntCursor = 0;
clay_Utils._nextUniqueInt0 = Math.random() * 2147483646 | 0;
clay_Utils._nextUniqueInt1 = new Date().getTime() * 0.0001 | 0;
clay_Utils._nextUniqueInt2 = Math.random() * 2147483646 | 0;
clay_Utils._nextUniqueInt3 = Math.random() * 2147483646 | 0;
clay_audio_AudioEvent.END = 0;
clay_audio_AudioEvent.DESTROYED = 1;
clay_audio_AudioEvent.DESTROYED_SOURCE = 2;
clay_audio_AudioFormat.UNKNOWN = 0;
clay_audio_AudioFormat.CUSTOM = 1;
clay_audio_AudioFormat.OGG = 2;
clay_audio_AudioFormat.WAV = 3;
clay_audio_AudioFormat.PCM = 4;
clay_audio_AudioState.INVALID = -1;
clay_audio_AudioState.PAUSED = 0;
clay_audio_AudioState.PLAYING = 1;
clay_audio_AudioState.STOPPED = 2;
clay_buffers_Float32ArrayImplJS.BYTES_PER_ELEMENT = 4;
clay_buffers_Int32ArrayImplJS.BYTES_PER_ELEMENT = 4;
clay_buffers_Uint8ArrayImplJS.BYTES_PER_ELEMENT = 1;
clay_graphics_Texture._nextIndex = 1;
clay_opengl_GLGraphics.DEPTH24_STENCIL8_OES = 35056;
clay_opengl_GLGraphics.TEXTURE_2D_MULTISAMPLE = 37120;
clay_opengl_GLGraphics._boundTexture2D = [];
clay_opengl_GLGraphics._activeTextureSlot = -1;
clay_opengl_GLGraphics._didFetchDefaultBuffers = false;
clay_opengl_web_GL.DEPTH_BUFFER_BIT = 256;
clay_opengl_web_GL.STENCIL_BUFFER_BIT = 1024;
clay_opengl_web_GL.COLOR_BUFFER_BIT = 16384;
clay_opengl_web_GL.POINTS = 0;
clay_opengl_web_GL.LINES = 1;
clay_opengl_web_GL.LINE_LOOP = 2;
clay_opengl_web_GL.LINE_STRIP = 3;
clay_opengl_web_GL.TRIANGLES = 4;
clay_opengl_web_GL.TRIANGLE_STRIP = 5;
clay_opengl_web_GL.TRIANGLE_FAN = 6;
clay_opengl_web_GL.ZERO = 0;
clay_opengl_web_GL.ONE = 1;
clay_opengl_web_GL.SRC_COLOR = 768;
clay_opengl_web_GL.ONE_MINUS_SRC_COLOR = 769;
clay_opengl_web_GL.SRC_ALPHA = 770;
clay_opengl_web_GL.ONE_MINUS_SRC_ALPHA = 771;
clay_opengl_web_GL.DST_ALPHA = 772;
clay_opengl_web_GL.ONE_MINUS_DST_ALPHA = 773;
clay_opengl_web_GL.DST_COLOR = 774;
clay_opengl_web_GL.ONE_MINUS_DST_COLOR = 775;
clay_opengl_web_GL.SRC_ALPHA_SATURATE = 776;
clay_opengl_web_GL.FUNC_ADD = 32774;
clay_opengl_web_GL.BLEND_EQUATION = 32777;
clay_opengl_web_GL.BLEND_EQUATION_RGB = 32777;
clay_opengl_web_GL.BLEND_EQUATION_ALPHA = 34877;
clay_opengl_web_GL.FUNC_SUBTRACT = 32778;
clay_opengl_web_GL.FUNC_REVERSE_SUBTRACT = 32779;
clay_opengl_web_GL.BLEND_DST_RGB = 32968;
clay_opengl_web_GL.BLEND_SRC_RGB = 32969;
clay_opengl_web_GL.BLEND_DST_ALPHA = 32970;
clay_opengl_web_GL.BLEND_SRC_ALPHA = 32971;
clay_opengl_web_GL.CONSTANT_COLOR = 32769;
clay_opengl_web_GL.ONE_MINUS_CONSTANT_COLOR = 32770;
clay_opengl_web_GL.CONSTANT_ALPHA = 32771;
clay_opengl_web_GL.ONE_MINUS_CONSTANT_ALPHA = 32772;
clay_opengl_web_GL.BLEND_COLOR = 32773;
clay_opengl_web_GL.ARRAY_BUFFER = 34962;
clay_opengl_web_GL.ELEMENT_ARRAY_BUFFER = 34963;
clay_opengl_web_GL.ARRAY_BUFFER_BINDING = 34964;
clay_opengl_web_GL.ELEMENT_ARRAY_BUFFER_BINDING = 34965;
clay_opengl_web_GL.STREAM_DRAW = 35040;
clay_opengl_web_GL.STATIC_DRAW = 35044;
clay_opengl_web_GL.DYNAMIC_DRAW = 35048;
clay_opengl_web_GL.BUFFER_SIZE = 34660;
clay_opengl_web_GL.BUFFER_USAGE = 34661;
clay_opengl_web_GL.CURRENT_VERTEX_ATTRIB = 34342;
clay_opengl_web_GL.FRONT = 1028;
clay_opengl_web_GL.BACK = 1029;
clay_opengl_web_GL.FRONT_AND_BACK = 1032;
clay_opengl_web_GL.CULL_FACE = 2884;
clay_opengl_web_GL.BLEND = 3042;
clay_opengl_web_GL.DITHER = 3024;
clay_opengl_web_GL.STENCIL_TEST = 2960;
clay_opengl_web_GL.DEPTH_TEST = 2929;
clay_opengl_web_GL.SCISSOR_TEST = 3089;
clay_opengl_web_GL.POLYGON_OFFSET_FILL = 32823;
clay_opengl_web_GL.SAMPLE_ALPHA_TO_COVERAGE = 32926;
clay_opengl_web_GL.SAMPLE_COVERAGE = 32928;
clay_opengl_web_GL.NO_ERROR = 0;
clay_opengl_web_GL.INVALID_ENUM = 1280;
clay_opengl_web_GL.INVALID_VALUE = 1281;
clay_opengl_web_GL.INVALID_OPERATION = 1282;
clay_opengl_web_GL.OUT_OF_MEMORY = 1285;
clay_opengl_web_GL.CW = 2304;
clay_opengl_web_GL.CCW = 2305;
clay_opengl_web_GL.LINE_WIDTH = 2849;
clay_opengl_web_GL.ALIASED_POINT_SIZE_RANGE = 33901;
clay_opengl_web_GL.ALIASED_LINE_WIDTH_RANGE = 33902;
clay_opengl_web_GL.CULL_FACE_MODE = 2885;
clay_opengl_web_GL.FRONT_FACE = 2886;
clay_opengl_web_GL.DEPTH_RANGE = 2928;
clay_opengl_web_GL.DEPTH_WRITEMASK = 2930;
clay_opengl_web_GL.DEPTH_CLEAR_VALUE = 2931;
clay_opengl_web_GL.DEPTH_FUNC = 2932;
clay_opengl_web_GL.STENCIL_CLEAR_VALUE = 2961;
clay_opengl_web_GL.STENCIL_FUNC = 2962;
clay_opengl_web_GL.STENCIL_FAIL = 2964;
clay_opengl_web_GL.STENCIL_PASS_DEPTH_FAIL = 2965;
clay_opengl_web_GL.STENCIL_PASS_DEPTH_PASS = 2966;
clay_opengl_web_GL.STENCIL_REF = 2967;
clay_opengl_web_GL.STENCIL_VALUE_MASK = 2963;
clay_opengl_web_GL.STENCIL_WRITEMASK = 2968;
clay_opengl_web_GL.STENCIL_BACK_FUNC = 34816;
clay_opengl_web_GL.STENCIL_BACK_FAIL = 34817;
clay_opengl_web_GL.STENCIL_BACK_PASS_DEPTH_FAIL = 34818;
clay_opengl_web_GL.STENCIL_BACK_PASS_DEPTH_PASS = 34819;
clay_opengl_web_GL.STENCIL_BACK_REF = 36003;
clay_opengl_web_GL.STENCIL_BACK_VALUE_MASK = 36004;
clay_opengl_web_GL.STENCIL_BACK_WRITEMASK = 36005;
clay_opengl_web_GL.VIEWPORT = 2978;
clay_opengl_web_GL.SCISSOR_BOX = 3088;
clay_opengl_web_GL.COLOR_CLEAR_VALUE = 3106;
clay_opengl_web_GL.COLOR_WRITEMASK = 3107;
clay_opengl_web_GL.UNPACK_ALIGNMENT = 3317;
clay_opengl_web_GL.PACK_ALIGNMENT = 3333;
clay_opengl_web_GL.MAX_TEXTURE_SIZE = 3379;
clay_opengl_web_GL.MAX_VIEWPORT_DIMS = 3386;
clay_opengl_web_GL.SUBPIXEL_BITS = 3408;
clay_opengl_web_GL.RED_BITS = 3410;
clay_opengl_web_GL.GREEN_BITS = 3411;
clay_opengl_web_GL.BLUE_BITS = 3412;
clay_opengl_web_GL.ALPHA_BITS = 3413;
clay_opengl_web_GL.DEPTH_BITS = 3414;
clay_opengl_web_GL.STENCIL_BITS = 3415;
clay_opengl_web_GL.POLYGON_OFFSET_UNITS = 10752;
clay_opengl_web_GL.POLYGON_OFFSET_FACTOR = 32824;
clay_opengl_web_GL.TEXTURE_BINDING_2D = 32873;
clay_opengl_web_GL.SAMPLE_BUFFERS = 32936;
clay_opengl_web_GL.SAMPLES = 32937;
clay_opengl_web_GL.SAMPLE_COVERAGE_VALUE = 32938;
clay_opengl_web_GL.SAMPLE_COVERAGE_INVERT = 32939;
clay_opengl_web_GL.COMPRESSED_TEXTURE_FORMATS = 34467;
clay_opengl_web_GL.DONT_CARE = 4352;
clay_opengl_web_GL.FASTEST = 4353;
clay_opengl_web_GL.NICEST = 4354;
clay_opengl_web_GL.GENERATE_MIPMAP_HINT = 33170;
clay_opengl_web_GL.BYTE = 5120;
clay_opengl_web_GL.UNSIGNED_BYTE = 5121;
clay_opengl_web_GL.SHORT = 5122;
clay_opengl_web_GL.UNSIGNED_SHORT = 5123;
clay_opengl_web_GL.INT = 5124;
clay_opengl_web_GL.UNSIGNED_INT = 5125;
clay_opengl_web_GL.FLOAT = 5126;
clay_opengl_web_GL.DEPTH_COMPONENT = 6402;
clay_opengl_web_GL.ALPHA = 6406;
clay_opengl_web_GL.RGB = 6407;
clay_opengl_web_GL.RGBA = 6408;
clay_opengl_web_GL.LUMINANCE = 6409;
clay_opengl_web_GL.LUMINANCE_ALPHA = 6410;
clay_opengl_web_GL.UNSIGNED_SHORT_4_4_4_4 = 32819;
clay_opengl_web_GL.UNSIGNED_SHORT_5_5_5_1 = 32820;
clay_opengl_web_GL.UNSIGNED_SHORT_5_6_5 = 33635;
clay_opengl_web_GL.FRAGMENT_SHADER = 35632;
clay_opengl_web_GL.VERTEX_SHADER = 35633;
clay_opengl_web_GL.MAX_VERTEX_ATTRIBS = 34921;
clay_opengl_web_GL.MAX_VERTEX_UNIFORM_VECTORS = 36347;
clay_opengl_web_GL.MAX_VARYING_VECTORS = 36348;
clay_opengl_web_GL.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661;
clay_opengl_web_GL.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660;
clay_opengl_web_GL.MAX_TEXTURE_IMAGE_UNITS = 34930;
clay_opengl_web_GL.MAX_FRAGMENT_UNIFORM_VECTORS = 36349;
clay_opengl_web_GL.SHADER_TYPE = 35663;
clay_opengl_web_GL.DELETE_STATUS = 35712;
clay_opengl_web_GL.LINK_STATUS = 35714;
clay_opengl_web_GL.VALIDATE_STATUS = 35715;
clay_opengl_web_GL.ATTACHED_SHADERS = 35717;
clay_opengl_web_GL.ACTIVE_UNIFORMS = 35718;
clay_opengl_web_GL.ACTIVE_ATTRIBUTES = 35721;
clay_opengl_web_GL.SHADING_LANGUAGE_VERSION = 35724;
clay_opengl_web_GL.CURRENT_PROGRAM = 35725;
clay_opengl_web_GL.NEVER = 512;
clay_opengl_web_GL.LESS = 513;
clay_opengl_web_GL.EQUAL = 514;
clay_opengl_web_GL.LEQUAL = 515;
clay_opengl_web_GL.GREATER = 516;
clay_opengl_web_GL.NOTEQUAL = 517;
clay_opengl_web_GL.GEQUAL = 518;
clay_opengl_web_GL.ALWAYS = 519;
clay_opengl_web_GL.KEEP = 7680;
clay_opengl_web_GL.REPLACE = 7681;
clay_opengl_web_GL.INCR = 7682;
clay_opengl_web_GL.DECR = 7683;
clay_opengl_web_GL.INVERT = 5386;
clay_opengl_web_GL.INCR_WRAP = 34055;
clay_opengl_web_GL.DECR_WRAP = 34056;
clay_opengl_web_GL.VENDOR = 7936;
clay_opengl_web_GL.RENDERER = 7937;
clay_opengl_web_GL.VERSION = 7938;
clay_opengl_web_GL.NEAREST = 9728;
clay_opengl_web_GL.LINEAR = 9729;
clay_opengl_web_GL.NEAREST_MIPMAP_NEAREST = 9984;
clay_opengl_web_GL.LINEAR_MIPMAP_NEAREST = 9985;
clay_opengl_web_GL.NEAREST_MIPMAP_LINEAR = 9986;
clay_opengl_web_GL.LINEAR_MIPMAP_LINEAR = 9987;
clay_opengl_web_GL.TEXTURE_MAG_FILTER = 10240;
clay_opengl_web_GL.TEXTURE_MIN_FILTER = 10241;
clay_opengl_web_GL.TEXTURE_WRAP_S = 10242;
clay_opengl_web_GL.TEXTURE_WRAP_T = 10243;
clay_opengl_web_GL.TEXTURE_2D = 3553;
clay_opengl_web_GL.TEXTURE = 5890;
clay_opengl_web_GL.TEXTURE_CUBE_MAP = 34067;
clay_opengl_web_GL.TEXTURE_BINDING_CUBE_MAP = 34068;
clay_opengl_web_GL.TEXTURE_CUBE_MAP_POSITIVE_X = 34069;
clay_opengl_web_GL.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070;
clay_opengl_web_GL.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071;
clay_opengl_web_GL.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072;
clay_opengl_web_GL.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073;
clay_opengl_web_GL.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074;
clay_opengl_web_GL.MAX_CUBE_MAP_TEXTURE_SIZE = 34076;
clay_opengl_web_GL.TEXTURE0 = 33984;
clay_opengl_web_GL.TEXTURE1 = 33985;
clay_opengl_web_GL.TEXTURE2 = 33986;
clay_opengl_web_GL.TEXTURE3 = 33987;
clay_opengl_web_GL.TEXTURE4 = 33988;
clay_opengl_web_GL.TEXTURE5 = 33989;
clay_opengl_web_GL.TEXTURE6 = 33990;
clay_opengl_web_GL.TEXTURE7 = 33991;
clay_opengl_web_GL.TEXTURE8 = 33992;
clay_opengl_web_GL.TEXTURE9 = 33993;
clay_opengl_web_GL.TEXTURE10 = 33994;
clay_opengl_web_GL.TEXTURE11 = 33995;
clay_opengl_web_GL.TEXTURE12 = 33996;
clay_opengl_web_GL.TEXTURE13 = 33997;
clay_opengl_web_GL.TEXTURE14 = 33998;
clay_opengl_web_GL.TEXTURE15 = 33999;
clay_opengl_web_GL.TEXTURE16 = 34000;
clay_opengl_web_GL.TEXTURE17 = 34001;
clay_opengl_web_GL.TEXTURE18 = 34002;
clay_opengl_web_GL.TEXTURE19 = 34003;
clay_opengl_web_GL.TEXTURE20 = 34004;
clay_opengl_web_GL.TEXTURE21 = 34005;
clay_opengl_web_GL.TEXTURE22 = 34006;
clay_opengl_web_GL.TEXTURE23 = 34007;
clay_opengl_web_GL.TEXTURE24 = 34008;
clay_opengl_web_GL.TEXTURE25 = 34009;
clay_opengl_web_GL.TEXTURE26 = 34010;
clay_opengl_web_GL.TEXTURE27 = 34011;
clay_opengl_web_GL.TEXTURE28 = 34012;
clay_opengl_web_GL.TEXTURE29 = 34013;
clay_opengl_web_GL.TEXTURE30 = 34014;
clay_opengl_web_GL.TEXTURE31 = 34015;
clay_opengl_web_GL.ACTIVE_TEXTURE = 34016;
clay_opengl_web_GL.REPEAT = 10497;
clay_opengl_web_GL.CLAMP_TO_EDGE = 33071;
clay_opengl_web_GL.MIRRORED_REPEAT = 33648;
clay_opengl_web_GL.FLOAT_VEC2 = 35664;
clay_opengl_web_GL.FLOAT_VEC3 = 35665;
clay_opengl_web_GL.FLOAT_VEC4 = 35666;
clay_opengl_web_GL.INT_VEC2 = 35667;
clay_opengl_web_GL.INT_VEC3 = 35668;
clay_opengl_web_GL.INT_VEC4 = 35669;
clay_opengl_web_GL.BOOL = 35670;
clay_opengl_web_GL.BOOL_VEC2 = 35671;
clay_opengl_web_GL.BOOL_VEC3 = 35672;
clay_opengl_web_GL.BOOL_VEC4 = 35673;
clay_opengl_web_GL.FLOAT_MAT2 = 35674;
clay_opengl_web_GL.FLOAT_MAT3 = 35675;
clay_opengl_web_GL.FLOAT_MAT4 = 35676;
clay_opengl_web_GL.SAMPLER_2D = 35678;
clay_opengl_web_GL.SAMPLER_CUBE = 35680;
clay_opengl_web_GL.VERTEX_ATTRIB_ARRAY_ENABLED = 34338;
clay_opengl_web_GL.VERTEX_ATTRIB_ARRAY_SIZE = 34339;
clay_opengl_web_GL.VERTEX_ATTRIB_ARRAY_STRIDE = 34340;
clay_opengl_web_GL.VERTEX_ATTRIB_ARRAY_TYPE = 34341;
clay_opengl_web_GL.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922;
clay_opengl_web_GL.VERTEX_ATTRIB_ARRAY_POINTER = 34373;
clay_opengl_web_GL.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975;
clay_opengl_web_GL.VERTEX_PROGRAM_POINT_SIZE = 34370;
clay_opengl_web_GL.POINT_SPRITE = 34913;
clay_opengl_web_GL.COMPILE_STATUS = 35713;
clay_opengl_web_GL.LOW_FLOAT = 36336;
clay_opengl_web_GL.MEDIUM_FLOAT = 36337;
clay_opengl_web_GL.HIGH_FLOAT = 36338;
clay_opengl_web_GL.LOW_INT = 36339;
clay_opengl_web_GL.MEDIUM_INT = 36340;
clay_opengl_web_GL.HIGH_INT = 36341;
clay_opengl_web_GL.FRAMEBUFFER = 36160;
clay_opengl_web_GL.RENDERBUFFER = 36161;
clay_opengl_web_GL.RGBA4 = 32854;
clay_opengl_web_GL.RGB5_A1 = 32855;
clay_opengl_web_GL.RGB565 = 36194;
clay_opengl_web_GL.DEPTH_COMPONENT16 = 33189;
clay_opengl_web_GL.STENCIL_INDEX = 6401;
clay_opengl_web_GL.STENCIL_INDEX8 = 36168;
clay_opengl_web_GL.DEPTH_STENCIL = 34041;
clay_opengl_web_GL.RENDERBUFFER_WIDTH = 36162;
clay_opengl_web_GL.RENDERBUFFER_HEIGHT = 36163;
clay_opengl_web_GL.RENDERBUFFER_INTERNAL_FORMAT = 36164;
clay_opengl_web_GL.RENDERBUFFER_RED_SIZE = 36176;
clay_opengl_web_GL.RENDERBUFFER_GREEN_SIZE = 36177;
clay_opengl_web_GL.RENDERBUFFER_BLUE_SIZE = 36178;
clay_opengl_web_GL.RENDERBUFFER_ALPHA_SIZE = 36179;
clay_opengl_web_GL.RENDERBUFFER_DEPTH_SIZE = 36180;
clay_opengl_web_GL.RENDERBUFFER_STENCIL_SIZE = 36181;
clay_opengl_web_GL.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048;
clay_opengl_web_GL.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049;
clay_opengl_web_GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050;
clay_opengl_web_GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051;
clay_opengl_web_GL.COLOR_ATTACHMENT0 = 36064;
clay_opengl_web_GL.DEPTH_ATTACHMENT = 36096;
clay_opengl_web_GL.STENCIL_ATTACHMENT = 36128;
clay_opengl_web_GL.DEPTH_STENCIL_ATTACHMENT = 33306;
clay_opengl_web_GL.NONE = 0;
clay_opengl_web_GL.FRAMEBUFFER_COMPLETE = 36053;
clay_opengl_web_GL.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054;
clay_opengl_web_GL.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055;
clay_opengl_web_GL.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057;
clay_opengl_web_GL.FRAMEBUFFER_UNSUPPORTED = 36061;
clay_opengl_web_GL.FRAMEBUFFER_BINDING = 36006;
clay_opengl_web_GL.RENDERBUFFER_BINDING = 36007;
clay_opengl_web_GL.MAX_RENDERBUFFER_SIZE = 34024;
clay_opengl_web_GL.INVALID_FRAMEBUFFER_OPERATION = 1286;
clay_opengl_web_GL.UNPACK_FLIP_Y_WEBGL = 37440;
clay_opengl_web_GL.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441;
clay_opengl_web_GL.CONTEXT_LOST_WEBGL = 37442;
clay_opengl_web_GL.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443;
clay_opengl_web_GL.BROWSER_DEFAULT_WEBGL = 37444;
clay_web_WebAssets.POT = true;
clay_web_WebAudio.HALF_PI = 1.5707;
clay_web_WebRuntime.timestampStart = 0.0;
clay_web_WebRuntime.webWindowId = 1;
clay_web__$WebRuntime_DOMKeys.dom_shift = 16;
clay_web__$WebRuntime_DOMKeys.dom_ctrl = 17;
clay_web__$WebRuntime_DOMKeys.dom_alt = 18;
clay_web__$WebRuntime_DOMKeys.dom_capslock = 20;
clay_web__$WebRuntime_DOMKeys.dom_pageup = 33;
clay_web__$WebRuntime_DOMKeys.dom_pagedown = 34;
clay_web__$WebRuntime_DOMKeys.dom_end = 35;
clay_web__$WebRuntime_DOMKeys.dom_home = 36;
clay_web__$WebRuntime_DOMKeys.dom_left = 37;
clay_web__$WebRuntime_DOMKeys.dom_up = 38;
clay_web__$WebRuntime_DOMKeys.dom_right = 39;
clay_web__$WebRuntime_DOMKeys.dom_down = 40;
clay_web__$WebRuntime_DOMKeys.dom_printscr = 44;
clay_web__$WebRuntime_DOMKeys.dom_insert = 45;
clay_web__$WebRuntime_DOMKeys.dom_delete = 46;
clay_web__$WebRuntime_DOMKeys.dom_lmeta = 91;
clay_web__$WebRuntime_DOMKeys.dom_rmeta = 93;
clay_web__$WebRuntime_DOMKeys.dom_kp_0 = 96;
clay_web__$WebRuntime_DOMKeys.dom_kp_1 = 97;
clay_web__$WebRuntime_DOMKeys.dom_kp_2 = 98;
clay_web__$WebRuntime_DOMKeys.dom_kp_3 = 99;
clay_web__$WebRuntime_DOMKeys.dom_kp_4 = 100;
clay_web__$WebRuntime_DOMKeys.dom_kp_5 = 101;
clay_web__$WebRuntime_DOMKeys.dom_kp_6 = 102;
clay_web__$WebRuntime_DOMKeys.dom_kp_7 = 103;
clay_web__$WebRuntime_DOMKeys.dom_kp_8 = 104;
clay_web__$WebRuntime_DOMKeys.dom_kp_9 = 105;
clay_web__$WebRuntime_DOMKeys.dom_kp_multiply = 106;
clay_web__$WebRuntime_DOMKeys.dom_kp_plus = 107;
clay_web__$WebRuntime_DOMKeys.dom_kp_minus = 109;
clay_web__$WebRuntime_DOMKeys.dom_kp_decimal = 110;
clay_web__$WebRuntime_DOMKeys.dom_kp_divide = 111;
clay_web__$WebRuntime_DOMKeys.dom_kp_numlock = 144;
clay_web__$WebRuntime_DOMKeys.dom_f1 = 112;
clay_web__$WebRuntime_DOMKeys.dom_f2 = 113;
clay_web__$WebRuntime_DOMKeys.dom_f3 = 114;
clay_web__$WebRuntime_DOMKeys.dom_f4 = 115;
clay_web__$WebRuntime_DOMKeys.dom_f5 = 116;
clay_web__$WebRuntime_DOMKeys.dom_f6 = 117;
clay_web__$WebRuntime_DOMKeys.dom_f7 = 118;
clay_web__$WebRuntime_DOMKeys.dom_f8 = 119;
clay_web__$WebRuntime_DOMKeys.dom_f9 = 120;
clay_web__$WebRuntime_DOMKeys.dom_f10 = 121;
clay_web__$WebRuntime_DOMKeys.dom_f11 = 122;
clay_web__$WebRuntime_DOMKeys.dom_f12 = 123;
clay_web__$WebRuntime_DOMKeys.dom_f13 = 124;
clay_web__$WebRuntime_DOMKeys.dom_f14 = 125;
clay_web__$WebRuntime_DOMKeys.dom_f15 = 126;
clay_web__$WebRuntime_DOMKeys.dom_f16 = 127;
clay_web__$WebRuntime_DOMKeys.dom_f17 = 128;
clay_web__$WebRuntime_DOMKeys.dom_f18 = 129;
clay_web__$WebRuntime_DOMKeys.dom_f19 = 130;
clay_web__$WebRuntime_DOMKeys.dom_f20 = 131;
clay_web__$WebRuntime_DOMKeys.dom_f21 = 132;
clay_web__$WebRuntime_DOMKeys.dom_f22 = 133;
clay_web__$WebRuntime_DOMKeys.dom_f23 = 134;
clay_web__$WebRuntime_DOMKeys.dom_f24 = 135;
clay_web__$WebRuntime_DOMKeys.dom_caret = 160;
clay_web__$WebRuntime_DOMKeys.dom_exclaim = 161;
clay_web__$WebRuntime_DOMKeys.dom_quotedbl = 162;
clay_web__$WebRuntime_DOMKeys.dom_hash = 163;
clay_web__$WebRuntime_DOMKeys.dom_dollar = 164;
clay_web__$WebRuntime_DOMKeys.dom_percent = 165;
clay_web__$WebRuntime_DOMKeys.dom_ampersand = 166;
clay_web__$WebRuntime_DOMKeys.dom_underscore = 167;
clay_web__$WebRuntime_DOMKeys.dom_leftparen = 168;
clay_web__$WebRuntime_DOMKeys.dom_rightparen = 169;
clay_web__$WebRuntime_DOMKeys.dom_asterisk = 170;
clay_web__$WebRuntime_DOMKeys.dom_plus = 171;
clay_web__$WebRuntime_DOMKeys.dom_pipe = 172;
clay_web__$WebRuntime_DOMKeys.dom_minus = 173;
clay_web__$WebRuntime_DOMKeys.dom_leftbrace = 174;
clay_web__$WebRuntime_DOMKeys.dom_rightbrace = 175;
clay_web__$WebRuntime_DOMKeys.dom_tilde = 176;
clay_web__$WebRuntime_DOMKeys.dom_audiomute = 181;
clay_web__$WebRuntime_DOMKeys.dom_volumedown = 182;
clay_web__$WebRuntime_DOMKeys.dom_volumeup = 183;
clay_web__$WebRuntime_DOMKeys.dom_comma = 188;
clay_web__$WebRuntime_DOMKeys.dom_period = 190;
clay_web__$WebRuntime_DOMKeys.dom_slash = 191;
clay_web__$WebRuntime_DOMKeys.dom_backquote = 192;
clay_web__$WebRuntime_DOMKeys.dom_leftbracket = 219;
clay_web__$WebRuntime_DOMKeys.dom_rightbracket = 221;
clay_web__$WebRuntime_DOMKeys.dom_backslash = 220;
clay_web__$WebRuntime_DOMKeys.dom_quote = 222;
clay_web__$WebRuntime_DOMKeys.dom_meta = 224;
cornerContour_Contour.smallDotScale = 0.07;
cornerContour_ContourGrad.smallDotScale = 0.07;
var cornerContour_CurveMath_quadStep = 0.03;
var cornerContour_CurveMath_cubicStep = 0.03;
cornerContour_StyleEndLine.no = 0;
cornerContour_StyleEndLine.begin = 1;
cornerContour_StyleEndLine.end = 2;
cornerContour_StyleEndLine.both = 3;
cornerContour_StyleEndLine.halfRound = 4;
cornerContour_StyleEndLine.quadrant = 5;
cornerContour_StyleEndLine.triangleBegin = 6;
cornerContour_StyleEndLine.triangleEnd = 7;
cornerContour_StyleEndLine.triangleBoth = 8;
cornerContour_StyleEndLine.arrowBegin = 9;
cornerContour_StyleEndLine.arrowEnd = 10;
cornerContour_StyleEndLine.arrowBoth = 11;
cornerContour_StyleEndLine.circleBegin = 12;
cornerContour_StyleEndLine.circleEnd = 13;
cornerContour_StyleEndLine.circleBoth = 14;
cornerContour_StyleEndLine.squareBegin = 15;
cornerContour_StyleEndLine.squareEnd = 16;
cornerContour_StyleEndLine.squareBoth = 17;
cornerContour_StyleEndLine.ellipseBegin = 18;
cornerContour_StyleEndLine.ellipseEnd = 19;
cornerContour_StyleEndLine.ellipseBoth = 20;
cornerContourClay_MainCCC.vertShaderData = StringTools.trim("\nattribute vec3 vertexPosition;\nattribute vec4 vertexColor;\n\nvarying vec4 color;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nvoid main(void) {\n\n    gl_Position = vec4(vertexPosition, 1.0);\n    color = vertexColor;\n    gl_PointSize = 1.0;\n\n}\n");
cornerContourClay_MainCCC.fragShaderData = StringTools.trim("\n#ifdef GL_ES\nprecision mediump float;\n#else\n#define mediump\n#endif\n\nvarying vec4 color;\n\nvoid main() {\n    gl_FragColor = color;\n}\n");
cornerContourClay_MainCCC.chooseColors = [];
cornerContourClay_MainCCC.chooseI = 0;
cornerContourClay_MainCCC.theta = 0.;
cornerContourClay_MainCCC.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
